
//<script type="text/javascript">

"Promise"in window||function(){"use strict";function t(t){return"function"==typeof t||"object"==typeof t&&null!==t}function n(t){return"function"==typeof t}function e(t){return"object"==typeof t&&null!==t}function r(t){U=t}function o(t){G=t}function i(){return function(){process.nextTick(f)}}function u(){return function(){N(f)}}function s(){var t=0,n=new Q(f),e=document.createTextNode("");return n.observe(e,{characterData:!0}),function(){e.data=t=++t%2}}function c(){var t=new MessageChannel;return t.port1.onmessage=f,function(){t.port2.postMessage(0)}}function a(){return function(){setTimeout(f,1)}}function f(){for(var t=0;B>t;t+=2){var n=X[t],e=X[t+1];n(e),X[t]=void 0,X[t+1]=void 0}B=0}function l(){try{var t=require,n=t("vertx");return N=n.runOnLoop||n.runOnContext,u()}catch(e){return a()}}function p(){}function _(){return new TypeError("You cannot resolve a promise with itself")}function h(){return new TypeError("A promises callback cannot return that same promise.")}function v(t){try{return t.then}catch(n){return nt.error=n,nt}}function d(t,n,e,r){try{t.call(n,e,r)}catch(o){return o}}function y(t,n,e){G(function(t){var r=!1,o=d(e,n,function(e){r||(r=!0,n!==e?w(t,e):A(t,e))},function(n){r||(r=!0,E(t,n))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,E(t,o))},t)}function m(t,n){n._state===$?A(t,n._result):n._state===tt?E(t,n._result):j(n,void 0,function(n){w(t,n)},function(n){E(t,n)})}function b(t,e){if(e.constructor===t.constructor)m(t,e);else{var r=v(e);r===nt?E(t,nt.error):void 0===r?A(t,e):n(r)?y(t,e,r):A(t,e)}}function w(n,e){n===e?E(n,_()):t(e)?b(n,e):A(n,e)}function g(t){t._onerror&&t._onerror(t._result),S(t)}function A(t,n){t._state===Z&&(t._result=n,t._state=$,0!==t._subscribers.length&&G(S,t))}function E(t,n){t._state===Z&&(t._state=tt,t._result=n,G(g,t))}function j(t,n,e,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=n,o[i+$]=e,o[i+tt]=r,0===i&&t._state&&G(S,t)}function S(t){var n=t._subscribers,e=t._state;if(0!==n.length){for(var r,o,i=t._result,u=0;u<n.length;u+=3)r=n[u],o=n[u+e],r?x(e,r,o,i):o(i);t._subscribers.length=0}}function P(){this.error=null}function T(t,n){try{return t(n)}catch(e){return et.error=e,et}}function x(t,e,r,o){var i,u,s,c,a=n(r);if(a){if(i=T(r,o),i===et?(c=!0,u=i.error,i=null):s=!0,e===i)return void E(e,h())}else i=o,s=!0;e._state!==Z||(a&&s?w(e,i):c?E(e,u):t===$?A(e,i):t===tt&&E(e,i))}function C(t,n){try{n(function(n){w(t,n)},function(n){E(t,n)})}catch(e){E(t,e)}}function M(t,n){var e=this;e._instanceConstructor=t,e.promise=new t(p),e._validateInput(n)?(e._input=n,e.length=n.length,e._remaining=n.length,e._init(),0===e.length?A(e.promise,e._result):(e.length=e.length||0,e._enumerate(),0===e._remaining&&A(e.promise,e._result))):E(e.promise,e._validationError())}function O(t){return new rt(this,t).promise}function k(t){function n(t){w(o,t)}function e(t){E(o,t)}var r=this,o=new r(p);if(!z(t))return E(o,new TypeError("You must pass an array to race.")),o;for(var i=t.length,u=0;o._state===Z&&i>u;u++)j(r.resolve(t[u]),void 0,n,e);return o}function Y(t){var n=this;if(t&&"object"==typeof t&&t.constructor===n)return t;var e=new n(p);return w(e,t),e}function q(t){var n=this,e=new n(p);return E(e,t),e}function F(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function I(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function D(t){this._id=ct++,this._state=void 0,this._result=void 0,this._subscribers=[],p!==t&&(n(t)||F(),this instanceof D||I(),C(this,t))}function K(){var t;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(n){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;e&&"[object Promise]"===Object.prototype.toString.call(e.resolve())&&!e.cast||(t.Promise=at)}var L;L=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var N,U,W,z=L,B=0,G=({}.toString,function(t,n){X[B]=t,X[B+1]=n,B+=2,2===B&&(U?U(f):W())}),H="undefined"!=typeof window?window:void 0,J=H||{},Q=J.MutationObserver||J.WebKitMutationObserver,R="undefined"!=typeof process&&"[object process]"==={}.toString.call(process),V="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,X=new Array(1e3);W=R?i():Q?s():V?c():void 0===H&&"function"==typeof require?l():a();var Z=void 0,$=1,tt=2,nt=new P,et=new P;M.prototype._validateInput=function(t){return z(t)},M.prototype._validationError=function(){return new Error("Array Methods must be provided an Array")},M.prototype._init=function(){this._result=new Array(this.length)};var rt=M;M.prototype._enumerate=function(){for(var t=this,n=t.length,e=t.promise,r=t._input,o=0;e._state===Z&&n>o;o++)t._eachEntry(r[o],o)},M.prototype._eachEntry=function(t,n){var r=this,o=r._instanceConstructor;e(t)?t.constructor===o&&t._state!==Z?(t._onerror=null,r._settledAt(t._state,n,t._result)):r._willSettleAt(o.resolve(t),n):(r._remaining--,r._result[n]=t)},M.prototype._settledAt=function(t,n,e){var r=this,o=r.promise;o._state===Z&&(r._remaining--,t===tt?E(o,e):r._result[n]=e),0===r._remaining&&A(o,r._result)},M.prototype._willSettleAt=function(t,n){var e=this;j(t,void 0,function(t){e._settledAt($,n,t)},function(t){e._settledAt(tt,n,t)})};var ot=O,it=k,ut=Y,st=q,ct=0,at=D;D.all=ot,D.race=it,D.resolve=ut,D.reject=st,D._setScheduler=r,D._setAsap=o,D._asap=G,D.prototype={constructor:D,then:function(t,n){var e=this,r=e._state;if(r===$&&!t||r===tt&&!n)return this;var o=new this.constructor(p),i=e._result;if(r){var u=arguments[r-1];G(function(){x(r,o,u,i)})}else j(e,o,t,n);return o},"catch":function(t){return this.then(null,t)}};var ft=K,lt={Promise:at,polyfill:ft};"function"==typeof define&&define.amd?define(function(){return lt}):"undefined"!=typeof module&&module.exports?module.exports=lt:"undefined"!=typeof this&&(this.ES6Promise=lt),ft()}.call(this);

    MCServiceAPI = window.MCServiceAPI || {};
    MCServiceAPI.channelStates = {
        CONNECTING: "CONNECTING",
        ACTIVE: "ACTIVE",
        TIMEOUT: "TIMEOUT",
        NO_SESSION: "NO_SESSION",
        DISCONNECTED: "DISCONNECTED",
        UNKNOWN: "UNKNOWN"
    };
    MCServiceAPI.DisconnectReason = {
        visitorAction: 'host_action',
        agentAction: 'agent_action',
        visitorNetworkTimeout: 'host_network',
        agentNetworkTimeout: 'join_network'
    };
    MCServiceAPI.configuration = {
        version: "20220325",
        codebase: "RELY",
        defaultLanguage: "1033",
        languageMapping: {"1026":[2,"bg","bg-bg","bgr","bul"],"1028":[30724,3076,31748,4,4100,5124,"chs","cht","zh","zh-chs","zh-cht","zhh","zh-hans","zh-hant","zh-hk","zhi","zhm","zh-mo","zho","zh-sg","zh-tw"],"1029":[5,"ces","cs","cs-cz","csy"],"1030":[6,"da","da-dk","dan"],"1031":[2055,3079,4103,5127,7,"de","dea","de-at","dec","de-ch","de-de","del","de-li","de-lu","des","deu"],"1032":[8,"el","el-gr","ell"],"1033":[10249,11273,12297,13321,14345,15369,16393,17417,18441,3081,4105,5129,6153,7177,8201,9,9225,"en","en-029","ena","en-au","enb","en-bz","enc","en-ca","ene","eng","enh","en-hk","eni","en-id","en-ie","en-in","enj","en-jm","enl","enm","en-my","enn","en-nz","enp","en-ph","ens","en-sg","ent","en-tt","enu","en-us","enw","enz","en-za","en-zw","zzz"],"1035":[11,"fi","fi-fi","fin"],"1036":[10252,11276,12,12300,13324,14348,15372,2060,4108,5132,6156,7180,8204,9228,"fr","fr-029","fra","frb","fr-be","fr-cd","fr-ch","fr-ci","fr-cm","frd","fre","frf","fr-fr","frh","fr-ht","fri","frl","fr-lu","frm","fr-ma","fr-mc","fr-ml","frn","fro","frr","fr-re","frs","fr-sn","zzz"],"1038":[14,"hu","hu-hu","hun"],"1040":[16,2064,"it","ita","it-ch","it-it","its"],"1041":[17,"ja","ja-jp","jpn"],"1042":[18,"ko","ko-kr","kor"],"1043":[19,2067,"nl","nlb","nl-be","nld","nl-nl"],"1044":[20,2068,31764,"nb","nb-no","nn","nn-no","nno","no","nob","non","nor"],"1045":[21,"pl","plk","pl-pl","pol"],"1046":[22,"por","pt","ptb","pt-br"],"1048":[2072,24,"ro","rod","rom","ro-md","ron","ro-ro"],"1049":[2073,25,"ru","rum","ru-md","ru-ru","rus"],"1050":[26,4122,"hr","hrb","hr-ba","hr-hr","hrv"],"1051":[27,"sk","sk-sk","sky","slk"],"1053":[2077,29,"sv","sve","svf","sv-fi","sv-se","swe"],"1054":[30,"th","tha","th-th"],"1055":[31,"tr","trk","tr-tr","tur"],"1058":[34,"uk","ukr","uk-ua"],"1060":[36,"sl","sl-si","slv"],"1061":[37,"est","et","et-ee","eti"],"1062":[38,"lav","lv","lvi","lv-lv"],"1063":[39,"lit","lt","lth","lt-lt"],"2052":[30724,3076,31748,4,4100,5124,"chs","cht","zh","zh-chs","zh-cht","zh-cn","zhh","zh-hans","zh-hant","zh-hk","zhi","zhm","zh-mo","zho","zh-sg"],"2057":[10249,11273,12297,13321,14345,15369,16393,17417,18441,3081,4105,5129,6153,7177,8201,9,9225,"en","en-029","ena","en-au","enb","en-bz","enc","en-ca","ene","eng","en-gb","enh","en-hk","eni","en-id","en-ie","en-in","enj","en-jm","enl","enm","en-my","enn","en-nz","enp","en-ph","ens","en-sg","ent","en-tt","enu","enw","enz","en-za","en-zw","zzz"],"2070":[22,"por","pt","ptb","ptg","pt-pt"],"2074":[10266,11290,12314,28698,31770,6170,7194,9242,"sr","srb","sr-cyrl-ba","sr-cyrl-me","sr-cyrl-rs","srl","sr-latn","sr-latn-ba","sr-latn-cs","sr-latn-me","sr-latn-rs","srm","srn","sro","srp","srq","srs"],"3082":[10,10250,11274,12298,13322,14346,15370,16394,17418,18442,19466,20490,2058,21514,22538,23562,4106,5130,6154,7178,8202,9226,"es","es-419","esa","es-ar","esb","es-bo","esc","es-cl","es-co","es-cr","es-cu","esd","es-do","ese","es-ec","es-es","esf","esg","es-gt","esh","es-hn","esi","esj","esk","esl","esm","es-mx","esn","es-ni","eso","esp","es-pa","es-pe","es-pr","es-py","esr","ess","es-sv","est","esu","es-us","es-uy","esv","es-ve","esy","esz","spa"],"3084":[10252,11276,12,12300,13324,14348,15372,2060,4108,5132,6156,7180,8204,9228,"fr","fr-029","fra","frb","fr-be","frc","fr-ca","fr-cd","fr-ch","fr-ci","fr-cm","frd","fre","frf","frh","fr-ht","fri","frl","fr-lu","frm","fr-ma","fr-mc","fr-ml","frn","fro","frr","fr-re","frs","fr-sn","zzz"]},
        cloudContainer: "https://public.cobrowse.oraclecloud.com",
        dataServerPath: "https://public.cobrowse.oraclecloud.com/edge",
        mainServer: "https://www.livelook.com",
        auth: {
            start: "https://videowlphx01.livelook.com/mcservice/api/v2.0/session"
        },
        video: {
            ringer: 'https://public.cobrowse.oraclecloud.com/rely/mcservice/resources/audio/blackberry.mp3',
            dialer: 'https://public.cobrowse.oraclecloud.com/rely/mcservice/resources/audio/dial.mp3',
            wscAppUri: "/ws/webrtc/cloud",
            authType: "cloud"
        },
        cobrowse: {
            container: 'https://{siteid}.cobrowse.oraclecloud.com',
            forceWidgetPresence: true
        }
    };


    MCServiceAPI.Site = MCServiceAPI.Site || {};


    MCServiceAPI.Events = MCServiceAPI.Events || {};

    (function () {
            "use sctrict";
            var _isHost = true;
            function eventTemplate(name) {
                return {
                    wait: function (callback) {
                        var listeners = this.___internals.listeners;
                        if (listeners.indexOf(callback) === -1) {
                            listeners.push(callback);
                            try {
                                callback.once = true;
                            }
                            catch (e) { }
                        }
                    },
                    listen: function (callback) {
                        var listeners = this.___internals.listeners;
                        if (listeners.indexOf(callback) === -1)
                            listeners.push(callback);
                    },
                    removeListener: function (callback) {
                        var listeners = this.___internals.listeners;
                        for (var i = listeners.length - 1; i >= 0; i--) {
                            if (listeners[i] === callback) {
                                listeners.splice(i, 1);
                            }
                        }
                    },
                    ___internals: {
                        eventName: name,
                        listeners: []
                    }
                }
            }

            var _delay = function (interval) {
                return new Promise(function (resolve) {
                    setTimeout(resolve, interval);
                });
            };

            var _retry = function (fn, fnErrValidator, maxTime, timeout) {
                return fn().catch(function (err) {

                    if (fnErrValidator(err, maxTime)) {
                        return _delay(timeout).then(function () {
                            return _retry(fn, fnErrValidator, maxTime, timeout);
                        })
                    }

                    throw err;
                })
            };

            var _fireEvent = function (evt, params) {
                params.type = evt && evt.___internals ? evt.___internals.eventName : undefined;
                if (evt && evt.___internals && evt.___internals.listeners) {
                    evt.___internals.listeners.forEach(function (listener) {
                        (function (listener, params) {
                            setTimeout(function () {
                                if (listener) {
                                    if (listener.once)
                                        evt.removeListener(listener);
                                    listener.call(this, params);
                                }
                            }, 0);
                        })(listener, params);
                    })
                }
            }

            var _renderJSAndStyles = function (channels, sessionID) {
                var resources = [],
                    session = MCServiceAPI.Sessions[sessionID],
                    siteCode = session ? session.siteCode : null;

                if (false && sessionID === undefined) {
                    var asyncLog = MCServiceAPI.debug.logAsync("Creating list of required resources:");
                }
                else {
                    var asyncLog = MCServiceAPI.debug.logAsync("Creating list of channel resources for " + sessionID + ":");
                }

                Object.keys(channels).forEach(function (channelName) {
                    var channel = MCServiceAPI.Channels[channelName];
                    if (!channel) {
                        asyncLog.reject("Unrecognized channel name: " + channelName);
                        throw "Unrecognized channel name: " + channelName;
                    }
                    if (session && !session.channels[channelName])
                        return;
                    if (channel.supported) {
                        if (channel.resources)
                            resources = resources.concat(channel.resources);
                    }
                });

                asyncLog.resolve(resources.join(", "));
                asyncLog = MCServiceAPI.debug.logAsync("Loading resources...");

                _loadAllResources(resources).then(function () {
                    var connectedPromises = [],
                        disconnectedPromises = [];

                    Object.keys(channels).forEach(function (channelName) {
                        var channel = MCServiceAPI.Channels[channelName];
                        if (!channel) {
                            asyncLog.reject("Unrecognized channel name: " + channelName);
                            throw "Unrecognized channel name: " + channelName;
                        }
                        if (session && !session.channels[channelName]) {
                            //TODO: log?
                            return;
                        }
                        if (channel.supported) {
                            _injectView(channelName, channels[channelName], sessionID);

                            if (session !== undefined) {
                                (function (channel, channelName, sessionID) {
                                    var channelConnectPromise = new Promise(function (resolve, reject) {
                                        var done = false,
                                            connected_listener = function (evt) {
                                                if (!done) {
                                                    if (evt.sessionID === sessionID) {
                                                        //this is what we are waiting for
                                                        done = true;
                                                        resolve();
                                                    } else {
                                                        //connected for another session fired - ignore and listen more
                                                        channel.Events.Connected.wait(connected_listener);
                                                    }
                                                }
                                            },
                                            disconnected_listener = function (evt) {
                                                if (!done) {
                                                    if (evt.sessionID === sessionID) {
                                                        //DISCONNECTED for this session fired before CONNECTED - reject the promise
                                                        if (evt.type === "Error") {
                                                            MCServiceAPI.debug.error("Channel " + channelName + " reported error: " + evt.code);
                                                        }
                                                        done = true;
                                                        //reject({ channel: channelName, code: evt.code ? evt.code : "ERR_DISCONNECTED", nestedEvent: evt });
                                                    } else {
                                                        //connected for another session fired - ignore and listen more
                                                        channel.Events[evt.type].wait(disconnected_listener);
                                                    }
                                                }
                                            };
                                        channel.Events.Connected.wait(connected_listener);
                                        channel.Events.Disconnected.wait(disconnected_listener);
                                        channel.Events.Error.wait(disconnected_listener);
                                    });

                                    var channelDisconnectPromise = new Promise(function (resolve, reject) {
                                        var disconnected_listener = function (evt) {
                                            if (evt.sessionID === sessionID) {
                                                if (evt.reason || evt.code) {
                                                    MCServiceAPI.Sessions[sessionID].disconnectReason = evt.reason || evt.code;
                                                }
                                                resolve();
                                            }
                                            else {
                                                channel.Events[evt.type].wait(disconnected_listener);
                                            }
                                        };
                                        channel.Events.Disconnected.wait(disconnected_listener);
                                        channel.Events.Error.wait(disconnected_listener);
                                    });

                                    connectedPromises.push(channelConnectPromise);
                                    disconnectedPromises.push(channelDisconnectPromise);

                                })(channel, channelName, sessionID);
                            }
                        }
                    });

                    asyncLog.resolve();

                    if (sessionID !== undefined) {
                        (function (connectedPromises, disconnectedPromises, sessionID) {
                            Promise.all(connectedPromises).then(function () {
                                MCServiceAPI.debug.info("Fired MCServiceAPI.Connected for " + sessionID);
                                _fireEvent(MCServiceAPI.Events.Connected, {
                                    sessionID: sessionID,
                                    agent: false 
                            });
                            }).catch(function (err) {
                                var session = MCServiceAPI.Sessions[sessionID],
                                    isDisconnected = session ? session.terminating === true : true;
                                if (!isDisconnected) {
                                    session.terminating = true;
                                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnected for " + sessionID);
                                    _fireEvent(MCServiceAPI.Events.Disconnected, {
                                        sessionID: sessionID,
                                        siteCode: siteCode,
                                        reason: _processDisconnectReason(session.disconnectReason),
                                        agent: false 
                                });
                                }
                            })
                            Promise.all(disconnectedPromises).then(function () {
                                var session = MCServiceAPI.Sessions[sessionID],
                                    isDisconnected = session ? session.terminating === true : true;
                                if (!isDisconnected) {
                                    session.terminating = true;
                                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnected for " + sessionID);
                                    _fireEvent(MCServiceAPI.Events.Disconnected, {
                                        sessionID: sessionID,
                                        siteCode: siteCode,
                                        reason: session.disconnectReason,
                                        agent: false 
                                });
                                }
                            });
                        })(connectedPromises, disconnectedPromises, sessionID);
                    }
            });
        }

        var _injectView = function (channelName, params, sessionID) {
            var view = MCServiceAPI.Channels[channelName].view;
            _renderView(view, channelName, params, sessionID);
        }

        var _processDisconnectReason = function(reason) {
            if (!reason) 
                return reason;

            if (reason == MCServiceAPI.DisconnectReason.agentAction || 
                reason == MCServiceAPI.DisconnectReason.visitorAction)
                return reason;
            
            if (reason == 'TimeoutNoOK') 
                return  MCServiceAPI.DisconnectReason.visitorNetworkTimeout;

        }
        var _loadAllResources = function (resources) {
            return resources.reduce(function (prev, current) {
                return prev.then(function () {
                    return _appendResource(current);
                });

            }, Promise.resolve());
        }

        var _preloadResources = function (resources) {
            if (!document || !document.head)
                return;

            resources.forEach(function (resource) {
                if (!_resourceAlreadyLoaded(resource, false)) {
                    var preloadLink = document.createElement("link");
                    preloadLink.href = resource;
                    preloadLink.rel = "preload";
                    preloadLink.as = resource.indexOf(".js") !== -1 ? "script" : "style";
                    document.head.appendChild(preloadLink);
                };
            });
        }

        var _resourceAlreadyLoaded = function (url, excludePreloadTags) {
            var wildcards = ['[href="' + url + '"]', '[src="' + url + '"]'],
                alreadyLoaded = false;

            wildcards.forEach(function (elmnt) {
                if (!alreadyLoaded) {
                    var tags = document.querySelectorAll(elmnt);
                    if (tags.length > 0) {
                        if (excludePreloadTags) {
                            for (var i = 0; i < tags.length; i++) {
                                var relAttribute = tags[i].rel;
                                if (typeof relAttribute === "string" && relAttribute.toLowerCase() === "preload")
                                    continue;
                                else {
                                    alreadyLoaded = true;
                                    break;
                                }
                            }
                        }
                        else 
                            alreadyLoaded = true;
                    }
                }
            });

            return alreadyLoaded;
        }

        var _appendResource = function (url) {

            // Do not append the same resource twice
            if (_resourceAlreadyLoaded(url, true))
                return;

            return new Promise(function (resolve, reject) {
                var body = document.getElementsByTagName("body")[0],
                    head = document.getElementsByTagName("head")[0],
                    type = url.indexOf(".js") !== -1 ? "script" : "link",
                    resource = document.createElement(type);

                resource.type = type === "script" ? "text/javascript" : "text/css";

                if (resource.readyState) { //IE
                    resource.onreadystatechange = function () {
                        if (resource.readyState === "loaded" || resource.readyState === "complete") {
                            resource.onreadystatechange = null;
                            resolve();
                        }
                    };
                } else { //Others
                    resource.onload = function () {
                        resolve();
                    };
                }

                if (type === "script") {
                    resource.src = url;
                    head.appendChild(resource);
                } else {
                    resource.href = url;
                    resource.rel = "stylesheet";
                    head.appendChild(resource);
                }
            });
        }

        var _removeAlreadyAppendedScripts = function (url) {
            if (document.querySelectorAll('[src="' + url + '"]').length > 0) {
                var script = document.querySelectorAll('[src="' + url + '"]')[0];
                script.parentNode.removeChild(script);
            }
        }

        var _renderView = function (view, channelName, params, sessionID) {
            var channelViewAsync = MCServiceAPI.debug.logAsync("Loading view for channel " + channelName);
            var container = params.container,
                cntElement = typeof container === "string" ? document.querySelector(container) : container;

            if (cntElement) {
                view = _setLanguageTextStrings(view);
                cntElement.innerHTML = unescape(view);
            }

            var channel = MCServiceAPI.Channels[channelName];
            if (channel && channel.Events["Load"]) {
                console.log(Utils.getTimeString() + ": firing onload for: " + channelName + " as " + (params.agent ? "agent" : "visitor"));
                _fireEvent(channel.Events.Load, {
                    context: channel,
                    sessionID: sessionID,
                    params: params,
                    session: MCServiceAPI.Sessions[sessionID],
                    agent: params.agent
                });
            }
            channelViewAsync.resolve();
        }

        var _setLanguageTextStrings = function(view) {
            var textsMap = MCServiceAPI.Channels["webrtc_video"].UI.textMappings;
            Object.keys(textsMap).forEach(function(key) {
                view = view.replace(new RegExp('{{' + key + '}}', 'gi'), textsMap[key]);
            });
            return view;
        }

        var _toggleFullScreenButton = function(show) {
            if(Utils.$("toggleFullScreenButtonContainer")) {
                Utils.css(Utils.$("toggleFullScreenButtonContainer"), {
                    display: show ? "block" : "none"
                });
            }
        }

        var _toggleNoVideoClasses = function() {
            var videoTagForLocalStream = Utils.$("videoTagForLocalStream");
            var videoTagForSound = Utils.$("videoTagForSound");
            var ll_webrtc_video = Utils.$("ll_webrtc_video");
            var toggleVideo = Utils.$("toggleVideo");
            if (videoTagForLocalStream) {
                Utils.addClass(videoTagForLocalStream, "noVideo");
            }
            if (videoTagForSound) {
                Utils.addClass(videoTagForSound, "noVideo");
            }
            if (ll_webrtc_video) {
                Utils.addClass(ll_webrtc_video, "noVideo");
            }
            if (toggleVideo && _noVideoCameraAvailable()) {
                Utils.css(toggleVideo, {
                    "display": "none"
                });
            } 
        }

        var _toggleNoVideoMessage = function(params, hide, twoWayVideo, selfMute) {
          
            var videoElement = Utils.$("videoSectionWrapper");

            if(hide) {
                if(Utils.$("ll_webrtc_noVideoContainer") && !selfMute) {
                    var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                    Utils.css(noVideoElement, {
                        display: "none"
                    });
                }
                if(Utils.$("ll_webrtc_noVideoContainer_small") && selfMute) {
                    var noVideoElementSmall = Utils.$("ll_webrtc_noVideoContainer_small");
                    Utils.css(noVideoElementSmall, {
                        display: "none"
                    });
                }
                if(Utils.$("ll_webrtc_noVideoContainer") && selfMute && !twoWayVideo) {
                    var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                    Utils.css(noVideoElement, {
                        display: "none"
                    });
                }
                if((twoWayVideo || params.agent) && !selfMute) {
                    _toggleFullScreenButton(true);
                    _toggleNoVideoClasses();
                } else if(!selfMute && !params.agent) {
                    _toggleFullScreenButton(true);
                }
            } else if(Utils.$("ll_webrtc_noVideoContainer") && !selfMute) {
                var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                Utils.css(noVideoElement, {
                    display: "block"
                });
                _toggleNoVideoClasses();
                _toggleFullScreenButton(false);
            } else if(Utils.$("ll_webrtc_noVideoContainer_small") && selfMute) {
                var noVideoElementSmall = Utils.$("ll_webrtc_noVideoContainer_small");
                Utils.css(noVideoElementSmall, {
                    display: "block"
                });
            } else if(Utils.$("ll_webrtc_noVideoContainer") && selfMute && !twoWayVideo) {
                var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                Utils.css(noVideoElement, {
                    display: "block"
                });
                _toggleNoVideoClasses();
            } else if(Utils.$("ll_webrtc_noVideoContainer_small") && selfMute && !twoWayVideo) {
                var noVideoElementSmall = Utils.$("ll_webrtc_noVideoContainer_small");
                Utils.css(noVideoElementSmall, {
                    display: "block"
                });
            }
            else if(twoWayVideo && selfMute) {
                var template = document.createElement("div");

                template.id = "ll_webrtc_noVideoContainer_small";

                Utils.css(template, {
                    width: "100px",
                    top: "35px"
                });

                template.innerHTML = "No Video";

                videoElement.append(template);
            } else {
                  
                var template = document.createElement("div");

                template.id = "ll_webrtc_noVideoContainer";

                Utils.css(template, {
                    width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                    top: ((params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) / 2 - 11) + "px"
                });

                template.innerHTML = "No Video";

                videoElement.append(template);

                _toggleFullScreenButton(false);
                _toggleNoVideoClasses();
            }
        }

        var _sendNoVideoMessage = function (caller, message) {
            var that = this,
            peer = MCServiceAPI.Channels.webrtc_video.communicationHandler.peer;

            peer.send(caller, message);
        }

        var _noVideoCameraAvailable = function() {
            return MCServiceAPI.Channels.webrtc_video.videoInputDevices.length === 0;
        }

	    var _elementsWithAddedEventListeners = [];
        var _request = function (method, url, params, headers) {
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open(method, url, true);
                xhr.onload = function () {
                    if (this.status >= 200 && this.status < 300) {
                        resolve(xhr.response);
                    } else {
                        reject({
                            status: this.status,
                            statusText: xhr.statusText
                        });
                    }
                };
                xhr.onerror = function () {
                    reject({
                        status: this.status,
                        statusText: xhr.statusText
                    });
                };

                var hasContentType = false;
                if (headers) {
                    Object.keys(headers).forEach(function (key) {
                        if (key.toLowerCase() === "content-type")
                            hasContentType = true;
                        xhr.setRequestHeader(key, headers[key]);
                    });
                }

                if (method === "POST" && !hasContentType)
                    xhr.setRequestHeader("Content-type", "application/json");

                if (params && typeof params === 'object') {
                    params = Object.keys(params).map(function (key) {
                        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
                    }).join('&');
                }

                try {
                    xhr.send(params);
                }
                catch (err) {
                    reject({
                        status: 500,
                        error: err,
                        statusText: err.message
                    });
                }
            });
        }

        var _terminateSession = function (sessionID, isVisitor) {
            var session = MCServiceAPI.Sessions[sessionID];
            if (!session || session.terminated === true)
                return;

            localStorage.removeItem("accessToken");
            localStorage.removeItem("apiKey");
            localStorage.removeItem("sessionIdentifier");

            MCServiceAPI.Sessions[sessionID].terminated = true;

            _request("DELETE", MCServiceAPI.configuration.auth.start + (isVisitor ? "/visitor/" : "/agent/") + sessionID, null,
                {
                    "x-api-key": MCServiceAPI.Sessions[sessionID].siteCode,
                    "x-access-token": MCServiceAPI.Sessions[sessionID].accessToken
                })
                .catch(function (err) { });

            setTimeout(function (id) {
                delete MCServiceAPI.Sessions[id];
            }, 2000, sessionID);
        };

        var _removeChannels = function (sessionID, channelList, isVisitor) {
            var session = MCServiceAPI.Sessions[sessionID];
            if (!session || session.terminated === true)
                return;

            var channelsToRemove = JSON.stringify(channelList.reduce(
                function (object, key) {
                    object[key] = false;
                    return object
                }, {}));

            _request("POST", MCServiceAPI.configuration.auth.start + (isVisitor ? "/visitor/" : "/agent/") + sessionID,
                channelsToRemove,
                {
                    "x-access-token": MCServiceAPI.Sessions[sessionID].accessToken,
                    "x-http-method-override": "PATCH"
                })
                .then(function () {

                })
                .catch(function (err) {
                    MCServiceAPI.debug.error("Error contacting auth server");
                });
        }

        var _amAlive = function () {
            if (!_isHost) 
                return;

            return;
            /* rewrite for multiple sessions on host side */
            if (MCServiceAPI.StorageManager !== undefined && Object.keys(MCServiceAPI.Sessions).length > 0) {
                _pingTimer = setTimeout(_amAlive, 30000);

                MCServiceAPI.StorageManager.getItemAsync("mcservice.host", "sessionID").then(function (value) {
                    var validValue = false;
                    if (value) {
                        try {
                            var json = JSON.parse(value);
                            if (json && json.sessionID)
                                validValue = true;
                        }
                        catch (e) { }

                        if (validValue && MCServiceAPI.Sessions[json.sessionID] !== undefined) {
                            json.lastActiveTime = new Date().getTime();
                            MCServiceAPI.StorageManager.setItemAsync("mcservice.host", "sessionID", JSON.stringify(json));
                        }
                        else {
                            if (_pingTimer !== 0)
                                clearTimeout(_pingTimer);
                            _pingTimer = 0;
                        }
                    }
                });
            }
            else {
                if (_pingTimer !== 0)
                    clearTimeout(_pingTimer);
                _pingTimer = 0;
            }

        };

        var _pingTimer = 0;
        var _additionalConfig = null;

        var _setAdditionalConfig = function(config) {
            _additionalConfig = config;
        }

        var _getAdditionalConfig = function() {
            return _additionalConfig;
        }

        var _getFirstActiveSession = function (channelName) {
            var sessionID = undefined;
            Object.keys(MCServiceAPI.Sessions).forEach(function (session) {
                if (sessionID === undefined) {
                    var channels = MCServiceAPI.Sessions[session].channels;
                    if (channels && channels[channelName]) {
                        /* looks to be an active session for this channel */
                        sessionID = session;
                    }
                }
            });

            return sessionID;
        }

        var events = MCServiceAPI.Events;
        events.Ready = new eventTemplate("Ready");
        events.Connecting = new eventTemplate("Connecting");
        events.Connected = new eventTemplate("Connected");
        events.Disconnecting = new eventTemplate("Disconnecting");
        events.Disconnected = new eventTemplate("Disconnected");
        events.Error = new eventTemplate("Error");

        MCServiceAPI.Channels = MCServiceAPI.Channels || {};
        MCServiceAPI.supportedChannels = [];

        MCServiceAPI.Sessions = {};
        MCServiceAPI.Channels.cobrowse = {
            abstract: false,
            ready: false,
            supported: false,
            view: "",
            requiredDevices: {},
            environmentErrorReason: [],
            resources: [],
            Events: {},
            listenersReady: false,
            hostStateQueues: {},
            getFrameBySession: function (sessionID) {
                sessionID = (typeof sessionID === "string") ? sessionID.toLowerCase() : undefined;
                if (sessionID)
                    return document.getElementById("LL.cobrowse.frame." + encodeURIComponent(sessionID));

                return undefined;

            },
            stop: function (descriptor) {
                var that = this,
                    sessionID = (typeof descriptor.sessionID === "string") ? descriptor.sessionID.toLowerCase() : undefined;
                if (!sessionID)
                    //NOTHING to do
                    return;

                if ("CoBrowseLauncher" in window) {
                    CoBrowseLauncher.stopCoBrowse(sessionID);
                }

                var agentFrame = that.getFrameBySession(sessionID);
                if (agentFrame && ("messageManager" in window)) {
                    var message = "Disconnect from MCService: ";
                    if (descriptor.reason)
                        message += descriptor.reason;
                    else if (descriptor.status)
                        message += descriptor.status;
                    else
                        message += "(no explanation)";

                    var reason = descriptor.reason || descriptor.status;
                    if (!reason)
                        reason = message;

                    var command = { command: "MCService.disconnect", reason: reason, message: message };
                    if (!descriptor.soft)
                        command.sessionID = sessionID; 

                    messageManager.send(agentFrame.contentWindow, command, { scope: "*" });
                }

                setTimeout(function (id) {
                    if (MCServiceAPI.Sessions[id] && MCServiceAPI.Sessions[id].channels.cobrowse)
                        delete MCServiceAPI.Sessions[id].channels["cobrowse"];
                }, 2999, sessionID);
            },

            getState: function (sessionID) {
                var that = this,
                    stateList = MCServiceAPI.channelStates;

                return new Promise(function (resolve, reject) {
                    if (sessionID === undefined) {
                        sessionID = _getFirstActiveSession("cobrowse");
                        if (sessionID === undefined) {
                            resolve(stateList.NO_SESSION);
                            return;
                        }
                    }

                    sessionID = sessionID.toLowerCase();

                    if (_isHost) {
                        if ("Cobrowse" in window) {
                            // host, easiest scenario
                            Cobrowse.ready().then(function () {
                                var isKnown = Cobrowse.API.Session.SID === sessionID;
                                if (!isKnown) {
                                    resolve(stateList.NO_SESSION);
                                    return;
                                }
                                var state = Cobrowse.API.Session.getState();

                                if (state === Cobrowse.States.ACTIVE || state === Cobrowse.States.ACTIVE_WAIT || state === Cobrowse.States.STARTING) {
                                    resolve(stateList.CONNECTING);
                                }
                                else if (state === Cobrowse.States.ACTIVE_ACTIVE || state === Cobrowse.States.ACTIVE_ESCALATING || state === Cobrowse.States.ACTIVE_ESCALATED || state === Cobrowse.States.DISCONNECTING) {
                                    resolve(stateList.ACTIVE);
                                }
                                else if (state === Cobrowse.States.READY) {
                                    resolve(stateList.DISCONNECTED);
                                }
                                else if (state === Cobrowse.States.ERROR) {
                                    resolve(stateList.DISCONNECTED);
                                }
                                else {
                                    resolve(stateList.NO_SESSION);
                                }

                                return;
                            });
                        }
                        else if ("CoBrowseLauncher" in window) {
                            return CoBrowseLauncher.getState({ SID: sessionID })
                                .then(function (stateDescriptor) {
                                    resolve(stateDescriptor.state);
                                    return;
                                })
                                .catch(function (stateDescriptor) {
                                    resolve(stateDescriptor.state);
                                    return;
                                });
                        }
                        else {
                            resolve(stateList.NO_SESSION);
                            return;
                        }
                    }
                    else {
                        /* not supported for agent side */
                    }

                    resolve(stateList.NO_SESSION);
                });
            },

            checkEnvironment: function () {
                var elem = document.createElement('canvas'),
                    validationPassed = "postMessage" in window
                        && "addEventListener" in window
                        && "JSON" in window
                        && "history" in window
                        && "pushState" in window.history
                        && "keys" in Object
                        && "forEach" in Array.prototype
                        && "indexOf" in Array.prototype
                        && "performance" in window
                        && "now" in window.performance
                        && (typeof elem !== undefined) && !!(elem.getContext && elem.getContext('2d'));

                if (!validationPassed) {
                    this.environmentErrorReason.push("HTML5_REQUIRED");
                    return false;
                }

                return true;
            },

            embedAgentView: function (container, url, siteid, sid, jwt) {
                var that = this,
                    iframe = that.getFrameBySession(sid),
                    frameLoadTimer = 0;

                var cntElement = typeof container === "string" ? document.querySelector(container) : container;
                if (!cntElement) {
                    MCServiceAPI.debug.error("Error embedding agent view: cobrowse container not found");
                    throw "Cobrowse init erorr E0001";
                }

                if (!iframe) {
                    var sessionID = typeof sid === "string" ? sid.toLowerCase() : undefined;

                    iframe = document.createElement("iframe");
                    iframe.setAttribute("id", "LL.cobrowse.frame." + encodeURIComponent(sessionID));
                    iframe.width = "100%";
                    iframe.height = "100%";
                    iframe.scrolling = "no";
                    iframe.frameborder = "0";
                    iframe.marginheight = "0";
                    iframe.marginwidth = "0";
                    iframe.style.border = "0";
                    iframe.setAttribute("allowfullscreen", true);
                    // for reverse cobrowse
                    iframe.setAttribute('allow', "display-capture 'src' " + MCServiceAPI.configuration.mainServer);
                    iframe.addEventListener("load", function () {
                        clearTimeout(frameLoadTimer);
                        frameLoadTimer = 0;
                        iframe.setAttribute("loaded", true);
                    }, false);

                    cntElement.appendChild(iframe);
                }

                frameLoadTimer = setTimeout(function (_container, _url, _siteid, _sid, _jwt) {
                    if (iframe.loaded)
                        return;

                    MCServiceAPI.debug.warn("Agent view loading timeout, retrying");
                    MCServiceAPI.Channels.cobrowse.embedAgentView(_container, _url, _siteid, _sid, _jwt);
                }, 7000, container, url, siteid, sid, jwt);

                var additionalConfig = _getAdditionalConfig(),
                    selectedLanguage = MCServiceAPI.configuration.defaultLanguage;

                if (additionalConfig && additionalConfig.lang) 
                    selectedLanguage = Utils.mapLangToLCID(additionalConfig.lang);

                iframe.setAttribute("loaded", false);
                iframe.src = "";
                iframe.src = url + (url.indexOf("?") === -1 ? "?" : "&") + "token=" + encodeURIComponent(jwt) + "&siteid=" + encodeURIComponent(siteid) + "&sid=" + encodeURIComponent(sid) + "&lang=" + encodeURIComponent(selectedLanguage);
            },

            init: function (isVisitor) {
                var that = this;
                return new Promise(function (resolve, reject) {
                    that.supported = that.checkEnvironment();
                    if (isVisitor) {
                        var integrationReady = ("StorageManager" in MCServiceAPI);
                        if (!integrationReady)
                            that.environmentErrorReason.push("MISSING_REQUIRED_COBROWSE_COMPONENTS");

                        that.supported = that.supported && integrationReady;

                        window.CoBrowseLauncher = window.CoBrowseLauncher || {};
                        if (typeof CoBrowseLauncher.startCoBrowse !== "function") {
                            CoBrowseLauncher.startCoBrowse = function (SID, agentEnv) {
                                /*parameter agentEnv is ignored*/
                                MCServiceAPI.StorageManager.emitDOMEvent("MCService.Cobrowse.startRequested", { SID: SID }, true);
                                return false;
                            }
                        }

                        if (typeof CoBrowseLauncher.stopCoBrowse !== "function") {
                            CoBrowseLauncher.stopCoBrowse = function (SID) {
                                MCServiceAPI.StorageManager.emitDOMEvent("MCService.Cobrowse.stopRequested", { SID: SID }, true);
                            }
                        }

                        if (typeof CoBrowseLauncher.getEnvironment !== "function") {
                            CoBrowseLauncher.getEnvironment = function () {
                                return "icb:" + that.supported;
                            }
                        }

                        if (typeof CoBrowseLauncher.isEnvironmentSupported !== "function") {
                            CoBrowseLauncher.isEnvironmentSupported = function () {
                                return that.supported;
                            }
                        }

                        if (typeof CoBrowseLauncher.getState !== "function") {
                            CoBrowseLauncher.getState = function (entity) {
                                if (!entity)
                                    return Promise.resolve(MCServiceAPI.channelStates.NO_SESSION);

                                var SID = entity.SID,
                                    siteID = entity.apiKey,
                                    sid = typeof (SID) === "string" ? SID.toLowerCase() : undefined,
                                    siteid = typeof (siteID) === "string" ? siteID.toLowerCase() : undefined;

                                return new Promise(function (resolve, reject) {

                                    if (!sid && !siteid) {
                                        resolve(MCServiceAPI.channelStates.NO_SESSION);
                                        return;
                                    }

                                    MCServiceAPI.StorageManager.ready()
                                        .then(function () {
                                            if (["SESSION_STORAGE", "COOKIE"].indexOf(MCServiceAPI.StorageManager.providerName) !== -1) {
                                                /* 3rd party storage disabled, but we still might be able to communicate via window.opener */
                                                try {
                                                    if (!window.opener || window.opener == window) {
                                                        /* no luck */
                                                        resolve({ state: MCServiceAPI.channelStates.UNKNOWN });
                                                        return;
                                                    }
                                                }
                                                catch (e) { }
                                            }

                                            var lookupKey = sid || siteid;

                                            var queue = that.hostStateQueues[lookupKey];
                                            if (queue === undefined) {
                                                queue = [];
                                                that.hostStateQueues[lookupKey] = queue;
                                            }

                                            var callDescriptor = {
                                                success: resolve,
                                                failure: reject,
                                                SID: sid,
                                                siteCode: siteid
                                            };

                                            queue.push(callDescriptor);

                                            var getStateTimeout = setTimeout(function (descriptor) {

                                                // no window called back with update
                                                var callback = descriptor.failure,
                                                    key = descriptor.SID || descriptor.siteCode,
                                                    sessionQueue = that.hostStateQueues[key],
                                                    idx = sessionQueue.indexOf(descriptor);

                                                if (idx !== -1) {
                                                    //remove descriptor from the queue
                                                    sessionQueue.splice(idx);
                                                }

                                                // call the failure callback 
                                                callback({ state: MCServiceAPI.channelStates.TIMEOUT });

                                            }, 5000, callDescriptor);

                                            callDescriptor.timer = getStateTimeout;

                                            MCServiceAPI.StorageManager.emitDOMEvent("Cobrowse.stateRequested", { siteCode: siteid, SID: sid }, true);

                                        });

                                });
                            }
                        }

                        if (that.supported) {
                            window.addEventListener("Cobrowse.state", function (evt) {
                                var SID = evt && evt.detail ? evt.detail.SID : null,
                                    siteCode = evt && evt.detail ? evt.detail.siteCode : null,
                                    sid = typeof (SID) === "string" ? SID.toLowerCase() : undefined,
                                    siteid = typeof (siteCode) === "string" ? siteCode.toLowerCase() : undefined,
                                    requestor = that.hostStateQueues[sid] ? that.hostStateQueues[sid].shift() : undefined;

                                if (!requestor)
                                    requestor = that.hostStateQueues[siteid] ? that.hostStateQueues[siteid].shift() : undefined;

                                if (requestor) {
                                    clearTimeout(requestor.timer);
                                    requestor.timer = 0;
                                    var state = evt && evt.detail ? evt.detail.mcServiceState : undefined,
                                        serializedState = MCServiceAPI.channelStates[state] || MCServiceAPI.channelStates.UNKNOWN,
                                        response = { state: serializedState, SID: evt.detail ? evt.detail.SID : undefined };

                                    requestor.success(response);
                                }
                                else {
                                    console.log("orphaned Cobrowse.state: ", evt.detail);
                                }
                            }, false);

                            window.addEventListener("Cobrowse.connected", function (evt) {
                                var scope = evt && evt.detail ? evt.detail.scope : null,
                                    SID = scope ? scope.SID : null;
                                if (SID && MCServiceAPI.Sessions[SID]) {
                                    MCServiceAPI.debug.info("Firing Connected for cobrowse #" + SID);
                                    _fireEvent(that.Events.Connected, {
                                        agent: false,
                                        context: that,
                                        sessionID: SID,
                                        accessCode: scope.accessCode
                                    });
                                }
                            }, false);

                            window.addEventListener("Cobrowse.disconnecting", function (evt) {
                                var scope = evt && evt.detail ? evt.detail.scope : null,
                                    SID = scope ? scope.SID : null;
                                if (SID && MCServiceAPI.Sessions[SID]) {
                                    MCServiceAPI.debug.info("Firing Disconnecting for cobrowse #" + SID);
                                    _fireEvent(that.Events.Disconnecting, {
                                        agent: false,
                                        context: that,
                                        sessionID: SID,
                                        accessCode: scope.accessCode
                                    });
                                }
                            }, false);
                            window.addEventListener("Cobrowse.disconnected", function (evt) {
                                if (evt && evt.detail) {
                                    var scope = evt.detail.scope,
                                        SID = (scope && scope.SID) || evt.detail.SID;
                                    if (SID && MCServiceAPI.Sessions[SID]) {
                                        MCServiceAPI.debug.info("Firing Disconnected for cobrowse #" + SID);
                                        _fireEvent(that.Events.Disconnected, {
                                            agent: false,
                                            context: that,
                                            code: evt.detail.reason,
                                            reason: evt.detail.reason,
                                            sessionID: SID,
                                            accessCode: scope.accessCode
                                        });
                                    }
                                }
                            }, false);
                        }
                    }
                    else {
                        that.resources.push(MCServiceAPI.configuration.mainServer + "/product/scripts/utils.js");
                        that.resources.push(MCServiceAPI.configuration.mainServer + "/product/scripts/messageManager.js");
                    }

                    that.Events["Preload"] = new eventTemplate("Preload");
                    that.Events["Load"] = new eventTemplate("Load");
                    that.Events["Connected"] = new eventTemplate("Connected");
                    that.Events["Connecting"] = new eventTemplate("Connecting");
                    that.Events["Disconnecting"] = new eventTemplate("Disconnecting");
                    that.Events["Disconnected"] = new eventTemplate("Disconnected");
                    that.Events["Error"] = that.Events["Failed"] = new eventTemplate("Failed");

                    MCServiceAPI.ready().then(function () {
                        that.Events.Error.listen(function (evt) {
                            var descriptor = {
                                channel: 'cobrowse',
                                error: evt
                            }
                            _fireEvent(MCServiceAPI.Events.Error, descriptor)
                        });
                        that.Events.Preload.listen(function (evt) {
                            if (evt.agent) {
                                //just preload the resources
                                _preloadResources(that.resources);
                            }
                        });
                        that.Events.Load.listen(function (evt) {
                            //start loading cobrowse here
                            var channelMetadata = evt.session.channels.cobrowse,
                                channelServer = channelMetadata.channelServer,
                                token = channelMetadata.token,
                                siteID = evt.session.siteCode,
                                sid = (typeof evt.sessionID === "string") ? evt.sessionID.toLowerCase() : undefined;

                            if (!isVisitor) {
                                if (channelMetadata) {
                                    if (!channelServer) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error E0002";
                                    }

                                    if (!token) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error E0003";
                                    }
                                    if (!("messageManager" in window)) {
                                        MCServiceAPI.debug.error("Dependencies not loaded for cobrowse (E0006)");
                                        throw "Cobrowse init error (E0006)";
                                    }

                                    that.embedAgentView(evt.params.container, "https://" + channelServer + "/welcome/jwt/join.aspx", evt.session.siteCode, sid, token);

                                    var frame = that.getFrameBySession(sid);
                                    if (!frame) {
                                        throw new Error("Error embedding co-browse condole");
                                    }

                                    var additionalConfig = _getAdditionalConfig();
                                    if (additionalConfig && additionalConfig.css) {
                                        messageManager.send(frame.contentWindow, {command: 'MCService', customCss: additionalConfig.css}, { scope: "*" });
                                    } else {
                                        messageManager.send(frame.contentWindow, "MCService", { scope: "*" });
                                    }

                                    if (!that.listenersReady) {
                                        messageManager.listen("MCService.loaded", function (evt) {
                                        });

                                        messageManager.listen("MCService.connecting", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Connecting for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Connecting, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.connected", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Connected for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Connected, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.disconnecting", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Disconnecting for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Disconnecting, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.disconnected", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Disconnected for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Disconnected, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode,
                                                code: evt.code,
                                                reason: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.error", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Error for cobrowse " + evt.SID);
                                            _fireEvent(that.Events.Error, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });
                                        that.listenersReady = true;
                                    }
                                }
                                else {
                                    if (that.supported && that.ready) {
                                        MCServiceAPI.debug.error("Cobrowse is not supported by authserver");
                                        throw "Cobrowse init error E0004";
                                    }
                                }
                            }
                            else {
                                if (!("CoBrowseLauncher" in window)) {
                                    MCServiceAPI.debug.error("Missing cobrowse integration launcher");
                                    throw "Cobrowse init error E0005";
                                }
                                else if (!that.supported) {
                                    MCServiceAPI.debug.error("Cobrowse channel is not supported");
                                    _fireEvent(that.Events.Error, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_SUPPORTED"
                                    });
                                    _fireEvent(that.Events.Disconnected, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_SUPPORTED",
                                        reason: "ERR_NOT_SUPPORTED"
                                    });
                                }
                                else if (!that.ready) {
                                    MCServiceAPI.debug.error("Cobrowse channel is not ready");
                                    _fireEvent(that.Events.Error, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_READY"
                                    });
                                    _fireEvent(that.Events.Disconnected, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_READY",
                                        reason: "ERR_NOT_READY"
                                    });
                                }
                                else {

                                    new Promise(function (resolve, reject) {
                                        if (MCServiceAPI.configuration.cobrowse.forceWidgetPresence !== true) {
                                            resolve();
                                        } else if ("Cobrowse" in window && "Deployment" in window.Cobrowse) {
                                            resolve();
                                        }
                                        else {
                                            //load cobrowse launcher for DCS
                                            if (!siteID) {
                                                throw "Cobrowse: invalid session configuration";
                                            }
                                            var siteCode = siteID.toLowerCase().replace(/:/g, ""),
                                                launcher = MCServiceAPI.configuration.cobrowse.container.replace("{siteid}", siteCode) + "/launcher.js";

                                            _loadAllResources([launcher]).then(function () {
                                                Cobrowse.ready().then(function () {
                                                    Cobrowse.API.DefaultUI.liveExpertPanelEnabled = false;
                                                    Cobrowse.API.DefaultUI.sessionEndedPopupEnabled = false;
                                                    resolve();
                                                });
                                            });
                                        }
                                    }).then(function () {
                                        var sid = typeof evt.sessionID === "string" ? evt.sessionID : "";
                                        CoBrowseLauncher.getState({ apiKey: siteID })
                                            .then(function (stateDescriptor) {
                                                /* check if there is a session already */
                                                if ([MCServiceAPI.channelStates.CONNECTING, MCServiceAPI.channelStates.ACTIVE].indexOf(stateDescriptor.state) !== -1) {
                                                    //check if it's the same session
                                                    var foreignSID = typeof stateDescriptor.SID === "string" ? stateDescriptor.SID.toLowerCase() : undefined;
                                                    if (foreignSID === sid.toLowerCase()) {
                                                        MCServiceAPI.debug.warn("Cobrowse session " + sid + " is already active");
                                                        return;
                                                    }

                                                    var message = "Another co-browse session is currently active for apiKey: " + siteID;
                                                    console.error(message);
                                                    MCServiceAPI.debug.error(message);
                                                    _fireEvent(that.Events.Error, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_BUSY"
                                                    });
                                                    _fireEvent(that.Events.Disconnected, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_NO_RESPONSE",
                                                        reason: "ERR_COBROWSE_NO_RESPONSE"
                                                    });
                                                    return;
                                                }
                                                else if (stateDescriptor.state === MCServiceAPI.channelStates.UNKNOWN) {
                                                    /* storage cannot provide reliable results - co-browse start will probably fail, but attempt anyways */
                                                    var message = "Cannot communicate with the co-browse widget";
                                                    MCServiceAPI.debug.warn(message);
                                                    console.warn(message);
                                                }

                                                CoBrowseLauncher.startCoBrowse(sid.toLowerCase());
                                            })
                                            .catch(function (errState) {
                                                if (errState && errState.state === MCServiceAPI.channelStates.TIMEOUT) {
                                                    var message = "No co-browse widget detected for apiKey: " + siteID;
                                                    MCServiceAPI.debug.error(message);
                                                    console.error(message);
                                                    _fireEvent(that.Events.Error, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_NO_RESPONSE"
                                                    });
                                                    _fireEvent(that.Events.Disconnected, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_NO_RESPONSE",
                                                        reason: "ERR_COBROWSE_NO_RESPONSE"
                                                    });
                                                }
                                                else
                                                    throw errState;
                                            });


                                    });

                                }
                            }
                        });
                    });

                    MCServiceAPI.Events.Disconnecting.listen(function (evt) {
                        var sessionID = evt.sessionID,
                            session = MCServiceAPI.Sessions[sessionID];
                        if (!session || !session.channels || !session.channels.cobrowse || !that.supported)
                            //nothing to do
                            return;

                        evt.context = that;
                        _fireEvent(that.Events.Disconnecting, evt);

                        if (evt.stopSession) {
                            MCServiceAPI.Channels.cobrowse.stop(evt);
                        }
                        else if (!_isHost) {
                            evt.soft = true;
                            MCServiceAPI.Channels.cobrowse.stop(evt);
                        }
                    });

                    MCServiceAPI.Events.Disconnected.listen(function (evt) {
                        var sessionID = evt.sessionID,
                            session = sessionID ? MCServiceAPI.Sessions[sessionID] : null;
                        if (!session || !session.channels || !session.channels.cobrowse || !that.supported)
                            //nothing to do
                            return;

                        evt.context = that;
                        if (evt.code && !evt.reason) {
                            evt.reason = evt.code;
                        }
                        if (!evt.code && evt.reason) {
                            evt.code = evt.reason;
                        }
                        _fireEvent(that.Events.Disconnected, evt);
                        MCServiceAPI.Channels.cobrowse.stop(evt);
                    });

                    that.ready = true;
                    resolve();
                });
            }
        }

        MCServiceAPI.Channels.standalone_cobrowse = {
            abstract: false,
            ready: false,
            supported: false,
            view: "",
            requiredDevices: {},
            environmentErrorReason: [],
            resources: [
                MCServiceAPI.configuration.mainServer + "/product/scripts/utils.js",
                MCServiceAPI.configuration.mainServer + "/product/scripts/messageManager.js"],
            Events: {},
            listenersReady: false,
            checkEnvironment: MCServiceAPI.Channels.cobrowse.checkEnvironment,

            embedAgentView: function (container, url, siteCode, token) {
                var iframe = document.getElementById("LL.cobrowse.frame.standalone"),
                    frameLoadTimer = 0;

                if (!container) {
                    MCServiceAPI.debug.error("Error embedding agent view: standalone cobrowse container not found");
                    throw "Cobrowse init erorr ES001";
                }
                var cntElement = typeof container === "string" ? document.querySelector(container) : container;
                if (!cntElement) {
                    MCServiceAPI.debug.error("Error embedding agent view: cobrowse container not found");
                    throw "Cobrowse init erorr ES011";
                }

                container = cntElement;

                if (token !== undefined) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + "token=" + encodeURIComponent(token);
                }

                if (siteCode !== undefined) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + "siteID=" + encodeURIComponent(siteCode);
                }

                var additionalConfig = _getAdditionalConfig(),
                    selectedLanguage = MCServiceAPI.configuration.defaultLanguage;

                if (additionalConfig && additionalConfig.lang)
                    selectedLanguage = Utils.mapLangToLCID(additionalConfig.lang);

                if (!iframe) {
                    var div = document.createElement("DIV");
                    div.style.width = "100%";
                    div.style.height = "100%";
                    container.appendChild(div);

                    iframe = document.createElement("iframe");
                    iframe.setAttribute("id", "LL.cobrowse.frame.standalone");
                    iframe.width = "100%";
                    iframe.height = "100%";
                    iframe.scrolling = "no";
                    iframe.frameborder = "0";
                    iframe.marginheight = "0";
                    iframe.marginwidth = "0";
                    iframe.style.border = "0";
                    iframe.setAttribute("allowfullscreen", true);
                    // for reverse cobrowse
                    iframe.setAttribute('allow', "display-capture 'src' " + MCServiceAPI.configuration.mainServer);
                    iframe.addEventListener("load", function () {
                        clearTimeout(frameLoadTimer);
                        frameLoadTimer = 0;
                        iframe.setAttribute("loaded", true);
                    }, false);

                    div.appendChild(iframe);
                }

                frameLoadTimer = setTimeout(function (_container, _url) {
                    if (iframe.loaded)
                        return;

                    MCServiceAPI.debug.warn("Standalone Agent view loading timeout, retrying");
                    MCServiceAPI.Channels.standalone_cobrowse.embedAgentView(_container, _url);
                }, 7000, container, url);

                iframe.setAttribute("loaded", false);
                iframe.src = "";
                iframe.src = url + (url.indexOf("?") === -1 ? "?" : "&") + "lang=" + encodeURIComponent(selectedLanguage);

            },

            init: function (isVisitor) {
                var that = this;
                return new Promise(function (resolve, reject) {
                    that.supported = that.checkEnvironment();

                    that.Events["Load"] = new eventTemplate("Load");
                    that.Events["Connected"] = new eventTemplate("Connected");
                    that.Events["Connecting"] = new eventTemplate("Connecting");
                    that.Events["Disconnecting"] = new eventTemplate("Disconnecting");
                    that.Events["Disconnected"] = new eventTemplate("Disconnected");
                    that.Events["Error"] = that.Events["Failed"] = new eventTemplate("Failed");

                    MCServiceAPI.ready().then(function () {
                        if (isVisitor) {
                            //standalone events for cobrowse host
                            window.addEventListener("Cobrowse.connected", function (evt) {
                                var scope = evt.detail ? evt.detail.scope : null;
                                if (scope) {
                                    if (scope.SID)
                                        return; /*not a standalone session*/
                                    var descriptor = {
                                        accessCode: scope.accessCode,
                                        context: that,
                                        agent: false
                                    }
                                    if (!descriptor.accessCode)
                                        return;

                                    MCServiceAPI.debug.info("Firing Connected for standalone cobrowse #" + descriptor.accessCode);
                                    _fireEvent(that.Events.Connected, descriptor);

                                }
                            }, false);
                            window.addEventListener("Cobrowse.disconnecting", function (evt) {
                                var scope = evt.detail ? evt.detail.scope : null;
                                if (scope) {
                                    if (scope.SID)
                                        return; /*not a standalone session*/

                                    var descriptor = {
                                        accessCode: scope.accessCode,
                                        context: that,
                                        agent: false
                                    }
                                    if (!descriptor.accessCode)
                                        return;

                                    MCServiceAPI.debug.info("Firing Disconnecting for standalone cobrowse #" + descriptor.accessCode);
                                    _fireEvent(that.Events.Disconnecting, descriptor);
                                }
                            }, false);

                            window.addEventListener("Cobrowse.disconnected", function (evt) {
                                var scope = evt.detail ? evt.detail.scope : null;
                                if (scope) {
                                    if (scope.SID)
                                        return; /*not a standalone session*/
                                    /*
                                    else if (!evt.detail.agentCount)
                                        return; /* no agents */
                                    if (!scope.accessCode)
                                        return;

                                    MCServiceAPI.debug.info("Firing Disconnected for standalone cobrowse #" + scope.accessCode + ", code: " + evt.detail.reason);
                                    _fireEvent(that.Events.Disconnected, {
                                        agent: false,
                                        context: that,
                                        accessCode: scope.accessCode,
                                        code: evt.detail.reason,
                                        reason: evt.detail.reason
                                    });
                                }
                            }, false);
                        }
                        else {
                            that.Events.Load.listen(function (evt) {
                                //start loading cobrowse here

                                if (evt.params) {
                                    var channelServer = evt.params.channelServer,
                                        token = evt.params.token,
                                        siteCode = evt.params.siteCode;

                                    if (!channelServer) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error ES002";
                                    }

                                    if (!token) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error ES003";
                                    }

                                    if (!siteCode) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error ES004";
                                    }

                                    if (!("messageManager" in window)) {
                                        MCServiceAPI.debug.error("Dependencies not loaded for cobrowse (ES006)");
                                        throw "Cobrowse init error (ES006)";
                                    }

                                    that.embedAgentView(evt.params.container, "https://" + channelServer + "/welcome/jwt/join.aspx", siteCode, token);

                                    var frame = document.getElementById("LL.cobrowse.frame.standalone");
                                    messageManager.send(frame.contentWindow, "MCService", { scope: "*" });

                                    if (!that.listenersReady) {
                                        messageManager.listen("MCService.loaded", function (evt) {});

                                        messageManager.listen("MCService.connecting", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Firing Connecting for standalone cobrowse #" + evt.accessCode);
                                            _fireEvent(that.Events.Connecting, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.connected", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Firing Connected for standalone cobrowse #" + evt.accessCode);
                                            _fireEvent(that.Events.Connected, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.disconnecting", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Disconnecting for standalone cobrowse #" + evt.accessCode + ", code: " + evt.code);
                                            _fireEvent(that.Events.Disconnecting, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.disconnected", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Disconnected for standalone cobrowse #" + evt.accessCode + ", code: " + evt.code);
                                            _fireEvent(that.Events.Disconnected, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode,
                                                code: evt.code,
                                                reason: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.error", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Firing Error for standalone cobrowse " + evt.accessCode + ", code: " + evt.code);
                                            _fireEvent(that.Events.Error, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });
                                        that.listenersReady = true;
                                    }
                                }
                                else {
                                    if (that.supported && that.ready) {
                                        MCServiceAPI.debug.error("standalone_cobrowse is not supported by authserver");
                                        throw "Cobrowse init error ES004";
                                    }
                                }
                            });
                        }
                        that.Events.Error.listen(function (evt) {
                            var descriptor = {
                                channel: 'standalone_cobrowse',
                                error: evt
                            }
                            _fireEvent(MCServiceAPI.Events.Error, descriptor)
                        });

                    });

                    that.ready = true;
                    resolve();
                });
            }
        }

        MCServiceAPI.Channels["webrtc_video"] = {
            abstract: false,
            ready: false,
            supported: false,
            view: "\u003clink href=\u0027https://fonts.googleapis.com/css?family=Open+Sans:300\u0027 rel=\u0027stylesheet\u0027 type=\u0027text/css\u0027\u003e\u003clink href=\u0027https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css\u0027 rel=\u0027stylesheet\u0027 type=\u0027text/css\u0027\u003e\u003cdiv id=\"videoSectionWrapper\" oncontextmenu=\"return false\" aria-label=\"{{videoChatWidget}}\" tabindex=\"0\"\u003e\u003cvideo id=\"ll_webrtc_video\"\u003e\u003c/video\u003e\u003cdiv id=\"initializingVideo\" aria-live=\"assertive\"\u003e\u003ci class=\"fa fa-spinner fa-pulse fa-3x fa-fw initSpinner\"\u003e\u003c/i\u003e\u003c/div\u003e\u003cdiv id=\"toggleFullScreenButtonContainer\" class=\"mcHidden\"\u003e\u003ca href=\"javascript:;\" role=\"button\" class=\"controlButton last\" tabindex=\"0\" aria-label=\"{{toggleFullScreen}}\" id=\"toggleFullScreen\" title=\"{{toggleFullScreen}}\"\u003e\u003ci class=\"fa fa-arrows-alt\"\u003e\u003c/i\u003e\u003cspan\u003e{{fullScreen}}\u003c/span\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv id=\"buttonsWrapper\" class=\"mcHidden\" aria-assertive=\"live\" aria-label=\"{{videoChatStart}}\"\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"javascript:;\" tabindex=\"0\" role=\"button\" aria-label=\"{{endCall}}\" class=\"controlButton mcHidden\" id=\"endCall\" title=\"{{endCall}}\"\u003e\u003ci class=\"fa fa-phone\"\u003e\u003c/i\u003e\u003cspan\u003e{{endCall}}\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"javascript:;\" tabindex=\"0\" role=\"button\" aria-label=\"{{muteCall}}\" class=\"controlButton mcHidden last\" id=\"muteCall\" title=\"{{muteCall}}\"\u003e\u003ci class=\"fa fa-microphone\"\u003e\u003c/i\u003e\u003cspan\u003e{{muteCall}}\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003cli class=\"last\"\u003e\u003ca href=\"javascript:;\" role=\"button\" aria-label=\"{{toggleVideo}}\" tabindex=\"0\" class=\"controlButton mcHidden last\" id=\"toggleVideo\" title=\"{{disableVideo}}\"\u003e\u003ci class=\"fa fa-video-camera\"\u003e\u003c/i\u003e\u003cspan\u003e{{video}}\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cdiv class=\"clear\"\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
            initial_view: "\u003clink href=\u0027https://fonts.googleapis.com/css?family=Open+Sans:300\u0027 rel=\u0027stylesheet\u0027 type=\u0027text/css\u0027\u003e\u003cstyle\u003e#videoStartWrapper {font-family: \u0027Open Sans\u0027;position: relative;margin: 0 auto;}#startingVideo {background-color: #fff;font-size: 18px;color: #666;vertical-align: middle;text-align: center;}\u003c/style\u003e\u003cdiv id=\"videoStartWrapper\" oncontextmenu=\"return false\" aria-label=\"{{videoChatWidget}}\" tabindex=\"0\"\u003e\u003cdiv id=\"startingVideo\" aria-live=\"assertive\"\u003e{{connecting}}\u003c/div\u003e\u003c/div\u003e",
            requiredDevices: {
                videoInput: false,
                audioInput: true,
                audioOutput: true
            },
            stop: function (descriptor) {
                try {
                    MCServiceAPI.Channels.webrtc_video.communicationHandler.stopCall();
                }
                catch (e) { }
                setTimeout(function (id) {
                    if (MCServiceAPI.Sessions[id] && MCServiceAPI.Sessions[id].channels.webrtc_video)
                        delete MCServiceAPI.Sessions[id].channels.webrtc_video;
                }, 999, descriptor.sessionID);
            },
            getState: function (sessionID) {
                return new Promise(function (resolve) {
                    var that = this,
                        stateList = MCServiceAPI.channelStates,
                        peer = that.communicationHandler.peer;

                    if (sessionID === undefined) {
                        sessionID = _getFirstActiveSession("webrtc_video");
                        if (sessionID === undefined) {
                            resolve(stateList.NO_SESSION);
                            return;
                        }
                    }

                    if (!peer || !peer.session || sessionID !== that.communicationHandler.sessionID) {
                        resolve(stateList.NO_SESSION);
                        return;
                    }
                    else if (peer.session.sessionState === 'CONNECTED') {
                        var remoteVideoElement = document.querySelector('#videoTagForSound');
                        if (!remoteVideoElement) {
                            remoteVideoElement = document.querySelector('#ll_webrtc_video');
                        }
                        if (!remoteVideoElement || !remoteVideoElement.srcObject || remoteVideoElement.srcObject.active !== true) {
                            resolve(stateList.CONNECTING);
                            return;
                        }
                        else {
                            resolve(stateList.ACTIVE);
                            return;
                        }
                    }
                    else if (peer.session.sessionState === 'CLOSED') {
                        resolve(stateList.DISCONNECTED);
                        return;
                    }

                    resolve(stateList.NO_SESSION);
                });
            },
            UI: {
                endBtn: null,
                endBtnClicked: false,
                toggleSound: null,
                toggleVideoBtn: null,
                buttonsContainer: null,
                video: null,
                initializingContainer: null,
                videoContainer: null,
                toggleFullScreen: null,
                toggleFullScreenButtonWrapper: null,
                textMappings: {
                    'videoChatWidget': 'Video Chat Widget',
                    'videoChatStart': 'Video Chat Started, Video Chat Control Buttons Appeared',
                    'endCall': 'End Call',
                    'muteCall': 'Mute Call',
                    'toggleVideo': 'Toggle Video',
                    'disableVideo': 'Disable Video',
                    'video': 'Video',
                    'toggleFullScreen': 'Toggle Full Screen',
                    'fullScreen': 'Full Screen',
                    'connecting': 'Connecting...',
                    'initializing': 'Initializing...',
                    'unmuteCall': 'Unmute Call',
                    'enableVideo': 'Enable Video',
                    'callEnded': 'Call Ended'
                },

                //DragDrop feature
                xSmallDelta: 0,
                ySmallDelta: 0,

                allowDrop: function(e) {
                    e.preventDefault();
                },
                dropVideo: function(e) {
                    var channel = MCServiceAPI.Channels.webrtc_video;
                    e.preventDefault();
                 
                    var element = document.querySelector('#videoTagForLocalStream');
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }

                    var llWebRTCBlock = document.getElementById("ll_webrtc_video");
                    
                    var top = e.clientY - llWebRTCBlock.getBoundingClientRect().top;
                    var left = e.clientX - llWebRTCBlock.getBoundingClientRect().left;
                    
                    element.style.right = "0px";
                    // element.style.top = (top-channel.UI.ySmallDelta) + "px";
                    element.style.top = (top-channel.UI.ySmallDelta)+(channel.UI.videoContainer.offsetHeight-llWebRTCBlock.offsetHeight)/2 + "px";

                    // element.style.left = (left-channel.UI.xSmallDelta) + "px"; 
                    element.style.left = (left-channel.UI.xSmallDelta)+(channel.UI.videoContainer.offsetWidth-llWebRTCBlock.offsetWidth)/2 + "px";                
                },

                dragStart: function(e) {
                    var channel = MCServiceAPI.Channels.webrtc_video;

                    var element = document.querySelector('#videoTagForLocalStream');
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }

                    channel.UI.xSmallDelta = e.clientX - element.getBoundingClientRect().left;
                    channel.UI.ySmallDelta = e.clientY - element.getBoundingClientRect().top; 
                },

               
                dbclick: function() {
                    var element = document.querySelector('#videoTagForLocalStream');
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }
                    if(element && element.clientWidth < 25) {
                        element.style.width='100px';
                        element.style.height='75px';     
                        element.classList.remove("pulse");                  
                    }else if(element) {
                        element.style.width='20px';
                        element.style.height='20px';
                        element.classList.add("pulse");
                        element.style.top = "7px";
                        element.style.left = "auto";
                        element.style.right = "7px";
                    }
                },
                hideShowSelfView: function(status, videoDirectionClient) {

                    if (videoDirectionClient) {
                        return;
                    }

                    var element = document.querySelector('#videoTagForLocalStream');
                    var textNoVideo = document.querySelector('#ll_webrtc_noVideoContainer_small')
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }
                    if(element) {
                        if(status === 'hide') {
                            element.style.display="none";
                            if(textNoVideo)
                                textNoVideo.style.display="none";
                        }else {
                            element.style.display="block";
                        }
                    }
                },

                enableDragDrop: function(element) {
                    var dragableElement = document.querySelector('#'+element);

                    if(dragableElement) {
                        dragableElement.setAttribute('draggable', true);
                        var llWEBRTCVideo = document.getElementById("ll_webrtc_video");
                        
                        llWEBRTCVideo.addEventListener('dragover', this.allowDrop, false);
                        llWEBRTCVideo.addEventListener('drop', this.dropVideo, false);
                        dragableElement.addEventListener('dragstart', this.dragStart, false);
                        dragableElement.addEventListener("dblclick", this.dbclick);                    
                    }
                },

                init: function (params, session) {
                    var that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        isVisitor = !params.agent,
                        peer = channel.communicationHandler.peer,
                        uiInitUpdater = MCServiceAPI.debug.logAsync("Initializing webrtc UI for " + (isVisitor ? "Visitor" : "Agent"));

                    params = params.params || {};
                    var videoOnBothSides = params && params.callConfiguration ? params.callConfiguration.video === "both" : false;
                    var videoDirectionClient = params ? params.videoDirection === "visitor" : false;
                    var audioOnly = params && params.videoDirection ? params.videoDirection === "none" : false;
                    // Enabling full screen for all
                    params.isFullScreenEnabled = true;

                    that.currentParams = params;
                    that.endBtn = Utils.$('endCall');
                    that.toggleSound = Utils.$('muteCall');
                    that.toggleVideoBtn = Utils.$('toggleVideo');
                    that.buttonsContainer = Utils.$('buttonsWrapper');
                    that.video = document.querySelector('#ll_webrtc_video');
                    that.videoForFullScreen = document.querySelector('#ll_webrtc_video');
                    that.initializingContainer = Utils.$("initializingVideo");
                    that.videoContainer = Utils.$("videoSectionWrapper");
                    that.toggleFullScreen = Utils.$("toggleFullScreen");
                    that.toggleFullScreenButtonWrapper = Utils.$("toggleFullScreenButtonContainer");

                    if (that.initializingContainer) {
                        that.initializingContainer.innerHTML = that.textMappings.initializing;
                    }
                    Utils.addClass([that.toggleSound, that.toggleVideoBtn, that.endBtn], "disabled");

                    if (!isVisitor && videoOnBothSides) {
                        // If Video On Both Sides is enabled - change the video tag in use
                        if(!Utils.$("videoTagForSound")) {
                            var remoteSoundTag = document.createElement("video");

                            remoteSoundTag.className = "hidden";
                            remoteSoundTag.id = "videoTagForSound";
                            that.videoContainer.appendChild(remoteSoundTag);
                            that.video = remoteSoundTag;
                            // Accessibility
                            that.video.setAttribute('tabindex', 0);
                            that.video.setAttribute('title', 'Visitor\'s video screen.');
                            that.video.setAttribute('aria-label', 'Visitor\'s video screen.');
                            // Done to be able to control the small window expand/collapse with keyboard
                            that.video.addEventListener('keyup', function (e) {
                                if (e.which === 13) {
                                    that.dbclick();
                                }
                            });
                        } else {
                            that.video = Utils.$("videoTagForSound");
                        }
                            //Safari support
                            if(that.video){
                                that.video.setAttribute('webkit-playsinline', 'webkit-playsinline');
                                that.video.setAttribute('playsinline', 'playsinline');
                                that.video.allowsInlineMediaPlayback = true;
                                that.video.autoplay = true;
                            }
                    }

                    if((!isVisitor && !videoOnBothSides && !videoDirectionClient) || (isVisitor && !videoOnBothSides && videoDirectionClient)) {
                        Utils.addClass(that.video, "mirroringFix");
                    }

                    // If Full Screen is enabled in config - show the button and attach the click event listeners
                    if (params.isFullScreenEnabled) {
                        if(_elementsWithAddedEventListeners.indexOf("toggleFullScreen") < 0) {
                            _elementsWithAddedEventListeners.push("toggleFullScreen");
                            Utils.listen("click", that.toggleFullScreen, function () {
                                if (peer)
                                    peer.enterFullScreen(that.videoForFullScreen);
                            });
                        }
                    }

                    // Setting the Video tag sizes
                    Utils.css(that.video, {
                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                    });

                    //add Safari support for iOS
                    if(that.video) {
                        that.video.setAttribute('webkit-playsinline', 'webkit-playsinline');
                        that.video.setAttribute('playsinline', 'playsinline');
                        that.video.allowsInlineMediaPlayback = true;
                        that.video.autoplay = true;
                    }


                    // Setting the "Initializing" block size
                    Utils.css(that.initializingContainer, {
                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                        display: "table-cell"
                    });

                    // Setting the "videoSectionWrapper" block size
                    Utils.css(that.videoContainer, {
                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                    });


                    if(_elementsWithAddedEventListeners.indexOf("muteCall") < 0) {
                        _elementsWithAddedEventListeners.push("muteCall");
                        Utils.listen("click", that.toggleSound, function () {
                            var ll_caller = channel.communicationHandler.ll_caller;
                            if (peer && ll_caller) {
                                peer.toggleSound(ll_caller);
                                var status = peer.soundStatus(ll_caller);
                                if (status) {
                                    Utils.removeClass(that.toggleSound, "disabled");
                                    that.toggleSound.setAttribute("title", that.textMappings.muteCall);
                                } else {
                                    Utils.addClass(that.toggleSound, "disabled");
                                    that.toggleSound.setAttribute("title", that.textMappings.unmuteCall);
                                }

                                // Callback for state change
                                if (channel) {
                                    console.log(Utils.getTimeString() + ": firing AudioStateChange for video for " + (isVisitor ? "Visitor" : "Agent") + ", state: " + (status ? "unmute" : "mute"));
                                    _fireEvent(channel.Events.AudioStateChange, {
                                        state: status ? "unmute" : "mute",
                                        context: channel,
                                        agent: !isVisitor
                                    });
                                }
                                // Fixes an issue with JAWS in FireFox
                                that.toggleSound.blur();
                                that.toggleSound.focus();
                            }
                        });
                    }

                    if(_elementsWithAddedEventListeners.indexOf("toggleVideo") < 0) {
                        _elementsWithAddedEventListeners.push("toggleVideo");
                        Utils.listen("click", that.toggleVideoBtn, function () {
                            var ll_caller = channel.communicationHandler.ll_caller;
                            if (peer && ll_caller) {
                                peer.toggleVideo(ll_caller);
                                var status = peer.videoStatus(ll_caller);
                                if (status) {
                                    Utils.removeClass(that.toggleVideoBtn, "disabled");
                                    that.toggleVideoBtn.setAttribute("title", that.textMappings.disableVideo);
                                    _toggleNoVideoMessage(params, true, videoOnBothSides, true);
                                    _sendNoVideoMessage(ll_caller, '{"videoStateChange" : "enabled"}');
                                    if (videoOnBothSides) {
                                        channel.UI.hideShowSelfView('show', videoDirectionClient);
                                    }
                                } else {
                                    Utils.addClass(that.toggleVideoBtn, "disabled");
                                    that.toggleVideoBtn.setAttribute("title", that.textMappings.enableVideo);
                                    _toggleNoVideoMessage(params, false, videoOnBothSides, true);
                                    _sendNoVideoMessage(ll_caller, '{"videoStateChange" : "disabled"}');
                                    if (videoOnBothSides) {
                                        channel.UI.hideShowSelfView('hide', videoDirectionClient);
                                    }
                                }

                                // Callback for state change
                                if (channel) {
                                    console.log(Utils.getTimeString() + ": firing VideoStateChange for " + (isVisitor ? "Visitor" : "Agent") + ", state: " + (status ? "resume" : "pause"));
                                    _fireEvent(channel.Events.VideoStateChange, {
                                        state: status ? "resume" : "pause",
                                        videoTag: that.video,
                                        context: channel,
                                        agent: !isVisitor
                                    });
                                }
                                // Fixes an issue with JAWS in FireFox
                                that.toggleVideoBtn.blur();
                                that.toggleVideoBtn.focus();
                            }
                        });
                    }

                    if(_elementsWithAddedEventListeners.indexOf("endCall") < 0) {
                        _elementsWithAddedEventListeners.push("endCall");
                        Utils.listen("click", that.endBtn, function () {
                            channel.communicationHandler.stopCall();
                            channel.UI.endBtnClicked = true;
                            _elementsWithAddedEventListeners = [];
                        });
                    }

                    channel.Events.Disconnecting.listen(function (evt) {
                        channel.UI.toggleVideo();
                        if (evt.agent) {
                            Utils.addClass([that.endBtn, that.toggleSound, that.toggleVideoBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "mcHidden");
                        }
                        else {
                            Utils.addClass([that.toggleSound, that.endBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "disabled mcHidden");
                        }
                        if (Utils.$("chatMessageBox")) {
                            Utils.$("chatMessageBox").setAttribute("disabled", "disabled");
                        }
                    });

                    channel.Events.Disconnected.listen(function (evt) {
                        channel.UI.toggleVideo();
                        if (that.initializingContainer) {
                            that.initializingContainer.innerHTML = that.textMappings.callEnded;
                        }
                        if (evt.agent) {
                            Utils.addClass([that.endBtn, that.toggleSound, that.toggleVideoBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "mcHidden");
                            // Removing the messages if any
                            if (Utils.$("chatMessageBox"))
                                Utils.$("chatMessageBox").setAttribute("disabled", "disabled");
                        }
                        else {
                            Utils.addClass([that.toggleSound, that.endBtn, that.toggleVideoBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "mcHidden");
                        }
                    });

                    channel.Events.Connecting.listen(function (evt) {
                        // Changed for Client to Agent Video
                        if (evt.agent && !videoDirectionClient) {
                            Utils.removeClass([that.toggleSound, that.toggleVideoBtn, that.buttonsContainer], "mcHidden disabled");
                        }
                        if (evt.agent && videoDirectionClient) {
                            Utils.removeClass([that.toggleSound, that.buttonsContainer], "mcHidden disabled");
                        }
                        if (!evt.agent && videoDirectionClient) {
                            Utils.removeClass([that.toggleSound, that.toggleVideoBtn, that.buttonsContainer], "mcHidden disabled");
                        }
                    });

                    channel.Events.Connected.listen(function (evt) {
                        channel.UI.toggleVideo(true);

                        // Audio Only case
                        if (audioOnly) {
                            Utils.css(that.buttonsContainer, {
                                'margin-top': 0,
                                'bottom': 0
                            });
                            Utils.css(that.toggleVideoBtn, {
                                'display': 'none'
                            });
                            Utils.css(that.toggleFullScreenButtonWrapper, {
                                'display': 'none'
                            });
                        }

                        // Visitor to Agent case
                        if (evt.agent && videoDirectionClient) {
                            Utils.css(that.toggleVideoBtn, {
                                'display': 'none'
                            });
                        }
                        // Visitor to Agent case

                        var ll_caller = channel.communicationHandler.ll_caller;
                        // Changed for Client to Agent Video
                        if((params.isFullScreenEnabled && videoOnBothSides) || (params.isFullScreenEnabled && !evt.agent && !videoDirectionClient) || (params.isFullScreenEnabled && evt.agent && videoDirectionClient)) {
                            Utils.removeClass(that.toggleFullScreenButtonWrapper, "mcHidden");
                        }

                        if(_noVideoCameraAvailable() && (videoOnBothSides || evt.agent)) {
                            _toggleNoVideoMessage(params, false, videoOnBothSides, true);
                            _toggleNoVideoClasses();
                        }

                        if (evt.agent) {
                            Utils.removeClass(that.endBtn, "mcHidden disabled");
                        }
                        else {
                            // Enabling the control buttons
                            Utils.removeClass([that.toggleSound, that.endBtn, that.buttonsContainer], "mcHidden disabled");
                        
                            // Show the video pause/display buttons only if video on both sides is enabled
                            if (videoOnBothSides) {
                                Utils.removeClass(that.toggleVideoBtn, "mcHidden disabled");
                            }
                        }
                    });

                    uiInitUpdater.resolve();
                },

                renderLocalVideoTag: function (stream) {
                    var localVideoTag = document.createElement("video"),
                        localVideoElement = null,
                        that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        remoteVideoElement = null;

                    localVideoTag.id = "videoTagForLocalStream";
                    that.videoContainer.appendChild(localVideoTag);

                    // Accessibility
                    localVideoTag.setAttribute('tabindex', 0);
                    localVideoTag.setAttribute('title', 'Your video screen.');
                    localVideoTag.setAttribute('aria-label', 'Your video screen.');
                    // Done to be able to control the small window expand/collapse with keyboard
                    localVideoTag.addEventListener('keyup', function (e) {
                        if (e.which === 13) {
                            that.dbclick();
                        }
                    });

                    localVideoElement = localVideoTag;

                    try {
                        localVideoElement.srcObject = stream;
                        localVideoElement.load();
                        localVideoElement.play();
                        localVideoElement.controls = false;
                        localVideoElement.muted = true;
                    } catch (ex) { }

                    Utils.css(localVideoElement, {
                        width: 100 + "px",
                        height: 75 + "px",
                        display: "block",
                        position: "absolute",
                        top: 7 + "px",
                        right: 7 + "px",
                        cursor: "pointer"
                    });

                    //DragDrop feature 
                    try{
                        channel.UI.enableDragDrop("videoTagForLocalStream");
                    } catch(ex){}

                    console.log(Utils.getTimeString() + ": local tag rendered  aaaaa");
                },

                renderRemoteVideoTag: function (stream, params, session) {
                    var that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        remoteVideoElement = null,
                        videoDirectionClient = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "visitor" : false,
                        videoOnBothSides = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "both" : false;

                    if (videoOnBothSides) {
                        remoteVideoElement = document.querySelector("#ll_webrtc_video"),
                            localVideoElement = Utils.$("videoTagForSound");

                        // Setting the Video tag sizes
                        Utils.css(remoteVideoElement, {
                            width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                            height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                            display: "block"
                        });

                        //add Safari support for iOS
                        if(remoteVideoElement) {
                            remoteVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                            remoteVideoElement.setAttribute('playsinline', 'playsinline');
                            remoteVideoElement.allowsInlineMediaPlayback = true;
                            remoteVideoElement.autoplay = true;
                        }

                        //add Safari support for iOS
                        if(localVideoElement) {
                            localVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                            localVideoElement.setAttribute('playsinline', 'playsinline');
                            localVideoElement.allowsInlineMediaPlayback = true;
                            localVideoElement.autoplay = true;
                        }

                        Utils.css(localVideoElement, {
                            width: 100 + "px",
                            height: 75 + "px",
                            display: "block",
                            position: "absolute",
                            top: 7 + "px",
                            right: 7 + "px",
                            cursor: "pointer"
                        });

                    }
                    else {
                        if (!videoDirectionClient) { // Agent to Client Video
                            if(!Utils.$("videoTagForSound")) {
                                var remoteSoundTag = document.createElement("video");

                                remoteSoundTag.className = "hidden";
                                remoteSoundTag.id = "videoTagForSound";
                                that.videoContainer.appendChild(remoteSoundTag);

                                remoteVideoElement = remoteSoundTag;
                            } else {
                                remoteVideoElement = Utils.$("videoTagForSound");
                            }
                        } else { // Client to Agent Video
                            remoteVideoElement = Utils.$("ll_webrtc_video");
                        } 
                            //Safari support
                            if(remoteVideoElement) {
                                remoteVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                                remoteVideoElement.setAttribute('playsinline', 'playsinline');
                                remoteVideoElement.allowsInlineMediaPlayback = true;
                                remoteVideoElement.autoplay = true;
                            }
                    }

                    //DragDrop feature 
                    try{
                        channel.UI.enableDragDrop("videoTagForSound");
                    } catch(ex){}

                    try {
                   
                     //remoteVideoElement.volume = 0;
                     remoteVideoElement.pause();

                     setTimeout(function () {      
 
                        remoteVideoElement.srcObject = stream;
                        remoteVideoElement.load();
                        remoteVideoElement.play();
                        remoteVideoElement.controls = false;
                      }, 450);

                    } catch (ex) { }

                    console.log(Utils.getTimeString() + ": remote tag rendered");
                },

                toggleVideo: function (show) {
                    var that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        videoContainer = that.video,
                        initializingContainer = that.initializingContainer,
                        hasVideo = channel ? channel.hasVideo : true,
                        videoDirectionClient = that.currentParams ? that.currentParams.videoDirection === "visitor" : false,
                        videoOnBothSides = that.currentParams && that.currentParams.callConfiguration ? that.currentParams.callConfiguration.video === "both" : false;

                    if (show) {
                        if (hasVideo) {
                            Utils.css(videoContainer, {
                                display: "block"
                            });
                        }
                        Utils.css(initializingContainer, {
                            display: "none"
                        });
                    } else {
                        if (hasVideo) {
                            Utils.css(videoContainer, {
                                display: "none"
                            });
                            if (videoOnBothSides)
                                Utils.css(document.querySelector("#ll_webrtc_video"), {
                                    display: "none"
                                });
                        }
                        Utils.css(initializingContainer, {
                            display: "table-cell"
                        });

                        if (initializingContainer) {
                            initializingContainer.innerHTML = that.textMappings.callEnded;
                        }

                        if (Utils.$("videoTagForSound")) {
                            Utils.css(Utils.$("videoTagForSound"), {
                                display: "none"
                            });
                        }
                        if (Utils.$("videoTagForLocalStream")) {
                            Utils.css(Utils.$("videoTagForLocalStream"), {
                                display: "none"
                            });
                        }
                    }
                },
                appendCancelButton: function (text, globalStream) {
                    var initializingContainer = Utils.$("initializingVideo"),
                        initializingVideoContainerHTML = initializingContainer.innerHTML,
                        cancelButtonHTML = '<br /><a href="javascript:;" tabindex="0" role="button" aria-label="Cancel" title="Cancel" id="cancelVideoChatSession"><i class="fa fa-close"></i></a>',
                        updatedContent = initializingVideoContainerHTML + cancelButtonHTML;

                    if (initializingContainer) {
                        initializingContainer.innerHTML = updatedContent;
                    }

                if(_elementsWithAddedEventListeners.indexOf("cancelVideoChatSession") < 0) {
                    _elementsWithAddedEventListeners.push("cancelVideoChatSession");
                    Utils.listen("click", Utils.$("cancelVideoChatSession"), function () {
                        var channel = MCServiceAPI.Channels.webrtc_video;
                        // Removing the elemenet
                        Utils.$("videoSectionWrapper").parentNode.innerHTML = "";
                        globalStream.getVideoTracks()[0].stop();
                        globalStream.getAudioTracks()[0].stop();
                        if (channel) {
                            channel.UI.toggleVideo();
                        }
                    });
                }
            }
            },
            communicationHandler: {
                peer: null,
                ll_caller: null,
                agent: false,
                sessionID: null,
                currentState: 0,
                setConfig: function (evtData) {
                    var channel = MCServiceAPI.Channels.webrtc_video;
                    evtData.params.ringer = {
                        url: MCServiceAPI.configuration.video.ringer
                    };
                    evtData.params.dialer = {
                        url: MCServiceAPI.configuration.video.dialer
                    };

                    var channelMetadata = evtData.session.channels.webrtc_video,
                        channelServer = channelMetadata ? channelMetadata.channelServer: null;

                    evtData.params.serverConfiguration = {
                        serverUrl: channelServer,
                        isSecureConnection: true,
                        serverPort: null,
                        wscAppUri: MCServiceAPI.configuration.video.wscAppUri,
                        authType: MCServiceAPI.configuration.video.authType
                    }
                    evtData.params.callConfiguration = {
                        audio: "both",
                        video: evtData.params.agent ? "send" : "receive",
                        videoWidth: evtData.params.videoWidth,
                        videoHeight: evtData.params.videoHeight,
                        uiVideoWidth: evtData.params.uiVideoWidth,
                        uiVideoHeight: evtData.params.uiVideoHeight,
                        frameRateFPS: "",
                        sendBitrate: evtData.params.sendBitrate,
                        recvBitrate: evtData.params.recvBitrate
                    }

                    this.sessionID = evtData.sessionID;
                    this.agent = evtData.params.agent;
                    var videoDirection = evtData.session.channels.webrtc_video.videoDirection;
                    if (videoDirection === "both") {
                        evtData.params.callConfiguration.video = "both";
                        channel.hasVideo = true;
                    }
                    else if (videoDirection === "agent" || videoDirection === "visitor") {
                        channel.hasVideo = true;
                    }
                    else {
                        channel.hasVideo = false;
                    }

                    if (videoDirection === "visitor" && !evtData.params.agent) {
                        evtData.params.callConfiguration.video = "send";
                    } else if (videoDirection === "visitor" && evtData.params.agent) {
                        evtData.params.callConfiguration.video = "receive";
                    }

                    LLPeer.setConfiguration(evtData.params);
                },

                startVideoCall: function (stream, peerID) {
                    this.peer.partyGone = false;
                    this.currentState = 0;
                    var peer = this.peer;
                    peer.dialer.play();
                    peer.call(peerID, "VIDEO", stream);
                },
                acceptCall: function (peer, caller) {
                    var channel = MCServiceAPI.Channels.webrtc_video,
                        agent = this.agent ? true : false;
                    peer.accept(caller,
                        function (evt) {   // Accept callback
                            if (channel) {
                                console.log(Utils.getTimeString() + ": firing SessionStateChange for video for " + (agent ? "Agent" : "Visitor") + ", state: accept");
                                _fireEvent(channel.Events.SessionStateChange, {
                                    state: "accept",
                                    context: channel,
                                    agent: agent
                                });
                                _fireEvent(channel.Events.Connecting, {
                                    agent: agent,
                                    sessionID: channel.communicationHandler.sessionID,
                                    context: channel
                                });
                            }
                        },
                        function (evt) {   // Decline callback
                            if (channel) {
                                console.log(Utils.getTimeString() + ": firing SessionStateChange for video for " + (agent ? "Agent" : "Visitor") + ", state: decline");
                                _fireEvent(channel.Events.SessionStateChange, {
                                    state: "decline",
                                    context: channel,
                                    agent: agent
                                });
                            }
                            _fireEvent(channel.Events.Error, {
                                agent: agent,
                                context: channel,
                                code: "ERR_PERMISSION_DENIED",
                                error: evt,
                                sessionID: channel.communicationHandler.sessionID
                            });
                        }
                    );
                    peer.ringer.stop();
                },

                stopCall: function () {
                    var channel = MCServiceAPI.Channels.webrtc_video,
                        peer = this.peer,
                        currentState = this.currentState;

                    if (!peer)
                        return;

                    if (currentState !== -1) {
                        this.currentState = 0;

                        if (channel) {
                            console.log(Utils.getTimeString() + ": firing DISCONNECTING for video for " + (this.agent ? "Agent" : "Visitor"));
                            _fireEvent(channel.Events.Disconnecting, {
                                agent: this.agent,
                                context: channel,
                                sessionID: channel.communicationHandler.sessionID
                            });

                            if (currentState === 0) {
                                //video not connected, just wrap it up then
                                _fireEvent(channel.Events.Disconnected, {
                                    agent: this.agent,
                                    context: channel,
                                    sessionID: channel.communicationHandler.sessionID
                                });

                                this.currentState = -1;
                            }
                        }

                        peer.end(this.ll_caller);
                        peer.getSession().close();
                        if (!this.agent)
                            peer.ringer.stop();

                    }

                },
                getTracks: function (stream) {
                    var trackList = "";
                    try {
                        if (stream && stream.getTracks) {
                            var tracks = stream.getTracks();
                            if (tracks.length > 0) {
                                tracks.forEach(function (track) {
                                    var trackKind = track.kind ? track.kind : "";
                                    if (trackKind)
                                        trackList += (trackList.length > 0 ? ", " : "") + trackKind;
                                })
                            }
                        }
                    }
                    catch (e) {
                        trackList = "";
                    }
                    return trackList;
                },

                handleReconnect: function (sessionID, peerID) {
                    return new Promise(function (resolve, reject) {
                        var that = this;
                        that.isActive = true;
                        if (MCServiceAPI.Sessions[sessionID]) {
                            /*session still active*/
                            var videoObject = MCServiceAPI.Channels.webrtc_video.UI.video;
                            var peer = MCServiceAPI.Channels.webrtc_video.communicationHandler.peer;
                            peer.call(peerID, "VIDEO", videoObject.captureStream());
                            setTimeout(function (that) {
                                //give up in 5.5 seconds
                                if (that.isActive) {
                                    that.isActive = false;
                                    reject();
                                }

                            }, 5500, that);
                            peer.on('call:started', function (caller, state) {
                                setTimeout(function (that) {
                                    if (that.isActive) {
                                        that.isActive = false;
                                        reject();
                                    }
                                }, 3500, that);
                            });
                            peer.on("call:ringing", function () {
                                if (that.isActive) {
                                    console.log("CALL RECONNECTED");
                                    that.isActive = false;
                                    resolve();
                                }
                            });
                        }
                        else {
                            that.isActive = false;
                            resolve();
                        }
                    });
                },

                init: function (params, session) {

                    this.peer = new LLPeer({
                        peerId: params.peerID
                    });

                    var channel = MCServiceAPI.Channels.webrtc_video,
                        that = this,
                        agent = that.agent ? true : false,
                        peer = that.peer,
                        callStarted = false,
                        hintShown = false,
                        connectingUpdater = null,
                        connectionUpdater = null,
                        currentStream = null,
                        videoDirectionClient = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "visitor" : false,
                        videoOnBothSides = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "both" : false;

                    peer.on('open', function () {
                        console.log(Utils.getTimeString() + ": peer:open");
                        if (channel) {
                            console.log(Utils.getTimeString() + ": firing Render for video for " + (agent ? "Agent" : "Visitor"));
                            _fireEvent(channel.Events.Render, {
                                agent: agent,
                                context: channel,
                                params: params
                            });
                        }

                        if (agent) {
                            // Triggering the event that the device permission request can be shown
                            setTimeout(function () {
                                if (!callStarted) {
                                    if (channel) {
                                        _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                            show: true,
                                            context: channel
                                        });
                                    }
                                    hintShown = true;
                                }
                            }, 999);

                            var reconnectTimer = null;

                            // Getting the user Media
                            peer.on('stream', function (stream) {
                                connectionUpdater = MCServiceAPI.debug.logAsync("Routing accepted video call");
                                currentStream = stream;
                                if (channel) {
                                    try {
                                        channel.UI.video.srcObject = stream;
                                        channel.UI.video.play();
                                        channel.UI.video.controls = false;
                                        channel.UI.video.muted = !videoDirectionClient ? true : false;
                                    } catch (ex) {
                                        MCServiceAPI.debug.error("Error rendering local video: ", ex);
                                    }
                                }

                                if (_getFirstActiveSession("webrtc_video")) {
                                //if (Object.keys(MCServiceAPI.Sessions).length !== 0) {
                                    that.startVideoCall(stream, params.visitorPeerID);  // SET THE PEER ID OF THE OPPOSITE SIDE

                                    setTimeout(function () {
                                        if (!callStarted) {
                                            channel.UI.appendCancelButton("Cancel", stream);
                                        }
                                    }, 6999);

                                    // Triggering the event that the device permission request can be hidden
                                    callStarted = true;
                                    if (hintShown) {
                                        if (channel) {
                                            _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                show: false,
                                                context: channel
                                            });
                                        }
                                    }

                                    peer.on('call:started', function (caller, state) {
                                        console.log(Utils.getTimeString() + ": call:started");
                                        that.ll_caller = caller;
                                    });

                                    peer.on('call:ringing', function (caller) {
                                        console.log(Utils.getTimeString() + ": call:ringing");
                                        that.ll_caller = caller;
                                    });

                                    peer.on('call:responded', function (caller) {
                                        that.currentState = 1;
                                        if (channel) {
                                            /*
                                            console.log(Utils.getTimeString() + ": firing Connecting for video for Agent");
                                            _fireEvent(channel.Events.Connecting, { agent: agent });
                                            */
                                        }
                                    });

                                    peer.on('call:established', function (caller) {
                                        that.currentState = 1;
                                        connectingUpdater = MCServiceAPI.debug.logAsync("Waiting for remote stream...");
                                        if (channel) {
                                            _fireEvent(channel.Events.Connecting, {
                                                agent: agent,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID
                                            });
                                        }
                                    });

                                    peer.on('call:close', function (caller) {
                                        if (that.peer.partyGone) {
                                            //we are already processing it
                                            return;
                                        }

                                        that.currentState = 0;
                                        console.error("Host disappeared", caller);
                                        that.peer.partyGone = true;
                                        _retry(function () {
                                                var sessionID = _getFirstActiveSession("webrtc_video");
                                                if (sessionID) {
                                                    var session = MCServiceAPI.Sessions[sessionID];
                                                    return that.handleReconnect(session, session.channels.webrtc_video.visitorPeerID)
                                                }
                                                else {
                                                    console.error("Session was disconnected");
                                                    throw new Error("No active sessions found");
                                                }
                                            },
                                            function () {
                                                //retry until it times out - no conditions
                                                return true;
                                            }, 60 * 1000 * 3, 7000)
                                        .then(function () {
                                            console.log("OK");
                                        })
                                        .catch(function(err) {
                                            console.log("ERROR: ", err);
                                        });                                    
                                    });

                                    peer.on('call:ended', function (caller) {
                                        if (that.peer) {
                                            that.peer.partyGone = false;
                                        }
                                        _elementsWithAddedEventListeners = [];
                                        that.currentState = 0;

                                        if (channel) {
                                            _fireEvent(channel.Events.Disconnected, {
                                                agent: false,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID
                                            });
                                            //that.peer = null;
                                        }
                                        if (connectionUpdater) {
                                            connectionUpdater.reject("received call:ended");
                                        }

                                        // Hiding the "No Video" message if it's visible
                                        _toggleNoVideoMessage(params, true, undefined, true);
                                    
                                        //release media access on endcall
		                                try {
                                            setTimeout(function() {
				                                if(currentStream) {
					                                currentStream.getTracks().filter(function(track){
											            track.stop();
										            });
				                                }
								            }, 3333);
		                                }catch(ex) {}
                                    });

                                    peer.on('call:failed', function (caller, state) {
                                        that.currentState = 0;
                                        peer.dialer.stop();
                                        if (connectionUpdater) {
                                            connectionUpdater.reject("received call:failed");
                                        }
                                        if (connectingUpdater) {
                                            connectingUpdater.reject("received call:ended");
                                        }
                                    });

                                    // MESSAGING FOR NO VIDEO MESSAGE TRANSMISSION
                                    peer.on('messaging:open', function (caller) {
                                        if(_noVideoCameraAvailable()) {
                                            _sendNoVideoMessage(caller, '{"videoStateChange" : "disabled"}');
                                        }
                                        peer.on('message', function (caller, message) {
                                            var message = JSON.parse(message);
                                            if(message.videoStateChange && message.videoStateChange == "disabled") {
                                                _toggleNoVideoMessage(params, false, videoOnBothSides, false);
                                            } else if(message.videoStateChange && message.videoStateChange == "enabled") {
                                                _toggleNoVideoMessage(params, true, videoOnBothSides, false);
                                            }
                                        });
                                    });
                                } else {
                                    stream.getVideoTracks()[0].stop();
                                    stream.getAudioTracks()[0].stop();
                                }
                            });

                            // Sound from client to Agent (also if video is enabled for both sides)
                            peer.on('remote:stream:added', function (caller, stream) {
                                MCServiceAPI.debug.logAsync("Remote stream added").resolve(that.getTracks(stream));
                                if (channel) {
                                    channel.UI.renderRemoteVideoTag(stream, params, session);
                                    _fireEvent(channel.Events.Connected, {
                                        agent: agent,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }
                                if (connectingUpdater) {
                                    connectingUpdater.resolve();
                                }
                                if (connectionUpdater) {
                                    connectionUpdater.resolve();
                                }
                            });
                        }
                        else {
                            //Visitor
                            //Handler for incoming call
                            var visitorConnectionUpdater = MCServiceAPI.debug.logAsync("Requesting webrtc connection..");
                            peer.on('incoming:call', function (caller) {
                                that.currentState = 1;

                                if (_getFirstActiveSession("webrtc_video")) { //QA 170907-000124
                                //if (Object.keys(MCServiceAPI.Sessions).length !== 0) { //QA 170907-000124
                                    connectingUpdater = MCServiceAPI.debug.logAsync("Waiting for the remote stream...");

                                    setTimeout(function () {
                                        if (!callStarted) {
                                            if (channel) {
                                                _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                    show: true,
                                                    context: channel
                                                });
                                            }
                                            hintShown = true;
                                        }
                                    }, 999);

                                    that.ll_caller = caller;
                                    peer.ringer.play();

                                    // Accepting the call    
                                    that.acceptCall(peer, caller);
                                }
                            });

                            peer.on('call:state:change', function (caller, state) {
                                if (state && state.state === "FAILED" && that.currentState === 1) {
                                    that.currentState = 0;
                                    peer.dialer.stop();
                                    MCServiceAPI.debug.error("Videocall failed");
                                    _fireEvent(channel.Events.Disconnected, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                    _fireEvent(channel.Events.Error, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }

                            });
                            peer.on('call:failed', function (caller) {
                                if (that.currentState === 1) {
                                    that.currentState = 0;
                                    peer.dialer.stop();
                                    MCServiceAPI.debug.error("Videocall failed");
                                    _fireEvent(channel.Events.Disconnected, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                    _fireEvent(channel.Events.Error, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }
                            });

                            if (!videoDirectionClient) { // Agent to Client Video
                                peer.on('remote:stream:added', function (caller, stream) {
                                    that.currentState = 1;
                                    MCServiceAPI.debug.log("Remote stream added", that.getTracks(stream));
                                    // Hiding the "Allow" hint if it was shown
                                    if (hintShown) {
                                        if (channel) {
                                            _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                show: false,
                                                context: channel
                                            });
                                        }
                                    }
                                    callStarted = true;
                                    if (channel) {

                                        //debugger;
                                        try {
                                            channel.UI.video.srcObject = stream;
                                            channel.UI.video.load();
                                            channel.UI.video.play();
                                            channel.UI.video.controls = false;
                                            _fireEvent(channel.Events.Connected, {
                                                agent: agent,
                                                sessionID: channel.communicationHandler.sessionID,
                                                context: channel
                                            });

                                            if (visitorConnectionUpdater) {
                                                visitorConnectionUpdater.resolve("CONNECTED");
                                            }
                                            if (connectingUpdater) {
                                                connectingUpdater.resolve();
                                            }
                                        }
                                        catch (e) {
                                            //connection failed
                                            console.log(Utils.getTimeString() + ": connection error: ", e);
                                            _fireEvent(channel.Events.Error, {
                                                agent: agent,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID,
                                                error: e,
                                                code: "ERR_CONNECTION_FAILED"
                                            });
                                            _fireEvent(channel.Events.Disconnected, {
                                                agent: agent,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID
                                            });

                                            if (visitorConnectionUpdater) {
                                                visitorConnectionUpdater.reject("Call connected but stream render failed");
                                            }
                                            if (connectingUpdater) {
                                                connectingUpdater.reject();
                                            }
                                        }
                                    }
                                });
                            } else if (videoDirectionClient && !agent) { // Client to Agent Video
                                peer.on('remote:stream:added', function(caller, stream) {
                                    var remoteVideoElement = null;
                                    if(!Utils.$("videoTagForSound")) {
                                        var remoteSoundTag = document.createElement("video");
                                        var videoContainer = Utils.$("videoSectionWrapper");

                                        remoteSoundTag.className = "hidden";
                                        remoteSoundTag.id = "videoTagForSound";
                                        videoContainer.appendChild(remoteSoundTag);

                                        remoteVideoElement = remoteSoundTag;
                                        // Accessibility
                                        remoteVideoElement.setAttribute('tabindex', 0);
                                        remoteVideoElement.setAttribute('title', 'Visitor\'s video screen.');
                                        remoteVideoElement.setAttribute('aria-label', 'Visitor\'s video screen.');
                                        // Done to be able to control the small window expand/collapse with keyboard
                                        remoteVideoElement.addEventListener('keyup', function (e) {
                                            if (e.which === 13) {
                                                that.dbclick();
                                            }
                                        })
                                    } else {
                                        remoteVideoElement = Utils.$("videoTagForSound");
                                    }

                                    //remoteVideoElement.volume = 0;
                                    remoteVideoElement.pause();
                                    setTimeout(function () {
                                        remoteVideoElement.srcObject = stream;
                                        remoteVideoElement.load();
                                        remoteVideoElement.play();
                                        remoteVideoElement.controls = false;
                                    }, 450);

                                    //Safari support
                                    if(remoteVideoElement){
                                        remoteVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                                        remoteVideoElement.setAttribute('playsinline', 'playsinline');
                                        remoteVideoElement.allowsInlineMediaPlayback = true;
                                        remoteVideoElement.autoplay = true;
                                    }

                                });

                                peer.on('local:stream:added', function (caller, stream) {
                                    that.currentState = 1;
                                    MCServiceAPI.debug.log("Remote stream added", that.getTracks(stream));
                                    // Hiding the "Allow" hint if it was shown
                                    if (hintShown) {
                                        if (channel) {
                                            _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                show: false,
                                                context: channel
                                            });
                                        }
                                    }
                                    callStarted = true;
                                    if (channel) {

                                        //debugger;
                                        try {
                                            channel.UI.video.srcObject = stream;
                                            channel.UI.video.load();
                                            channel.UI.video.play();
                                            channel.UI.video.muted = true;
                                            channel.UI.video.controls = false;
                                            _fireEvent(channel.Events.Connected, {
                                                agent: agent,
                                                sessionID: channel.communicationHandler.sessionID,
                                                context: channel
                                            });

                                            if (visitorConnectionUpdater) {
                                                visitorConnectionUpdater.resolve("CONNECTED");
                                            }
                                            if (connectingUpdater) {
                                                connectingUpdater.resolve();
                                            }
                                        }
                                        catch (e) {
                                                //connection failed
                                                console.log(Utils.getTimeString() + ": connection error: ", e);
                                                _fireEvent(channel.Events.Error, {
                                                    agent: agent,
                                                    context: channel,
                                                    sessionID: channel.communicationHandler.sessionID,
                                                    error: e,
                                                    code: "ERR_CONNECTION_FAILED"
                                                });
                                                _fireEvent(channel.Events.Disconnected, {
                                                    agent: agent,
                                                    context: channel,
                                                    sessionID: channel.communicationHandler.sessionID
                                                });

                                                if (visitorConnectionUpdater) {
                                                    visitorConnectionUpdater.reject("Call connected but stream render failed");
                                                }
                                                if (connectingUpdater) {
                                                    connectingUpdater.reject();
                                                }
                                        }
                                    }
                            })
                        };

                            peer.on('call:declined', function (caller, state) {
                                that.currentState = 0;
                                peer.dialer.stop();
                                if (channel) {
                                    _fireEvent(channel.Events.Disconnected, {
                                        agent: agent,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }
                                if (visitorConnectionUpdater) {
                                    visitorConnectionUpdater.reject("Received call:declined");
                                }
                                if (connectingUpdater) {
                                    connectingUpdater.reject();
                                }
                            });

                            peer.on('call:ended', function (caller) {
                                that.currentState = 0;
								_elementsWithAddedEventListeners = [];
                                if (channel) {
                                    if (channel.UI.endBtnClicked) {
                                        _fireEvent(channel.Events.Disconnected, {
                                            agent: false,
                                            context: channel,
                                            sessionID: channel.communicationHandler.sessionID
                                        });
                                        channel.UI.endBtnClicked = false;
                                    } else {
                                        _fireEvent(channel.Events.Disconnected, {
                                            agent: true,
                                            context: channel,
                                            sessionID: channel.communicationHandler.sessionID
                                        });
                                    }
                                }
                                if (visitorConnectionUpdater) {
                                    visitorConnectionUpdater.reject("Received call:ended");
                                }
                                if (connectingUpdater) {
                                    connectingUpdater.reject();
                                }
                            
                                // Hiding the "No Video" message if it's visible
                                _toggleNoVideoMessage(params, true, undefined, true);

                                //release media access on endcall
					            try {
						            setTimeout(function() {
							            if(currentStream) {
								            currentStream.getTracks().filter(function(track){
									            track.stop();
								            });
							            }
						            }, 3333);
					            }catch(ex) {}
                            });

                            peer.on('error', function (err) { 
                                that.currentState = 0;
                                if(err.name == "PermissionDeniedError") {
                                    if (channel) {
                                        console.log(Utils.getTimeString() + ": firing SessionStateChange for video for " + (agent ? "Agent" : "Visitor") + ", state: decline");
                                        _fireEvent(channel.Events.SessionStateChange, {
                                            state: "decline",
                                            context: channel,
                                            agent: agent
                                        });
                                        _fireEvent(channel.Events.Error, {
                                            agent: agent,
                                            context: channel,
                                            code: "ERR_PERMISSION_DENIED",
                                            sessionID: channel.communicationHandler.sessionID
                                        });

                                    }
                                }
                            });

                            // MESSAGING FOR NO VIDEO MESSAGE TRANSMISSION
                            peer.on('messaging:open', function (caller) {
                                if(_noVideoCameraAvailable() && videoOnBothSides) {
                                    _sendNoVideoMessage(caller, '{"videoStateChange" : "disabled"}');
                                }
                                peer.on('message', function (caller, message) {
                                    var message = JSON.parse(message);
                                    if(message.videoStateChange && message.videoStateChange == "disabled") {
                                        _toggleNoVideoMessage(params, false, videoOnBothSides, false);
                                    } else if(message.videoStateChange && message.videoStateChange == "enabled") {
                                        _toggleNoVideoMessage(params, true, videoOnBothSides, false);
                                    }
                                });
                            });


                            // Video on both sides
                            if (videoOnBothSides) {
                                peer.on('local:stream:added', function (caller, stream) {
                                    console.log(Utils.getTimeString() + ": local:stream:added");
                                    channel.UI.renderLocalVideoTag(stream, params);
                                });
                            }
                        }
                    });
                }
            },
            init: function (isVisitor) {
                // VIDEO AND AUDIO 
                var that = this,
                    audioInputDevices = [],
                    audioOutputDevices = [],
                    videoInputDevices = [],
                    canEnumerate = false,
                    hasMicrophone = false,
                    hasSpeakers = false,
                    hasWebcam = false,
                    isWebsiteHasMicrophonePermissions = false,
                    isWebsiteHasWebcamPermissions = false;

                if (isVisitor) {
                    that.requiredDevices.videoInput = false;
                }

                //check if webrtc is supported and check devices availability
                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                    // Firefox 38+ seems having support of enumerateDevices
                    // Thanks @xdumaine/enumerateDevices
                    navigator.enumerateDevices = function (callback) {
                        navigator.mediaDevices.enumerateDevices().then(callback).catch(function () {
                            callback([]);
                        });
                    };
                }

                /*global MediaStreamTrack:true */
                if (typeof MediaStreamTrack !== 'undefined' && 'getSources' in MediaStreamTrack) {
                    canEnumerate = true;
                } else if (navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices) {
                    canEnumerate = true;
                }

                // http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediadevices
                function checkDeviceSupport(callback) {
                    if (!canEnumerate) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    if (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources) {
                        navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack);
                    }

                    if (!navigator.enumerateDevices && navigator.enumerateDevices) {
                        navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator);
                    }

                    if (!navigator.enumerateDevices) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    var Browser = Utils.DetectBrowser(),
                        browserName = Browser.BrowserName,
                        browserVersion = parseFloat(Browser.BrowserVersion);
                    if (isNaN(browserVersion)) {
                        browserVersion = 0;
                    }

                    if (!(browserName == "Chrome" && browserVersion >= 70) && !(browserName == "Firefox" && browserVersion >= 60)
                        && !(browserName == "Safari" && browserVersion >= 12) ) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    // Marking EDGE as unsupported
                    if (/Edge/.test(navigator.userAgent)) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    var MediaDevices = [];
                    audioInputDevices = [];
                    audioOutputDevices = [];
                    videoInputDevices = [];

                    navigator.enumerateDevices(function (devices) {
                        devices.forEach(function (_device) {
                            var device = {};
                            for (var d in _device) {
                                device[d] = _device[d];
                            }

                            // if it is MediaStreamTrack.getSources
                            if (device.kind === 'audio') {
                                device.kind = 'audioinput';
                            }

                            if (device.kind === 'video') {
                                device.kind = 'videoinput';
                            }

                            var skip;
                            MediaDevices.forEach(function (d) {
                                if (d.id === device.id && d.kind === device.kind) {
                                    skip = true;
                                }
                            });

                            if (skip) {
                                return;
                            }

                            if (!device.deviceId) {
                                device.deviceId = device.id;
                            }

                            if (!device.id) {
                                device.id = device.deviceId;
                            }

                            if (!device.label) {
                                device.label = 'Please invoke getUserMedia once.';
                                if (location.protocol !== 'https:') {
                                    if (document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                                        device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
                                    }
                                }
                            } else {
                                if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
                                    isWebsiteHasWebcamPermissions = true;
                                }

                                if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
                                    isWebsiteHasMicrophonePermissions = true;
                                }
                            }

                            if (device.kind === 'audioinput') {
                                hasMicrophone = true;

                                if (audioInputDevices.indexOf(device) === -1) {
                                    audioInputDevices.push(device);
                                }
                            }

                            if (device.kind === 'audiooutput') {
                                hasSpeakers = true;

                                if (audioOutputDevices.indexOf(device) === -1) {
                                    audioOutputDevices.push(device);
                                }
                            }

                            if (device.kind === 'videoinput') {
                                hasWebcam = true;

                                if (videoInputDevices.indexOf(device) === -1) {
                                    videoInputDevices.push(device);
                                }
                            }

                            // there is no 'videoouput' in the spec.
                            if (MediaDevices.indexOf(device) === -1) {
                                MediaDevices.push(device);
                            }
                        });

                        that.hasMicrophone = hasMicrophone;
                        that.hasSpeakers = hasSpeakers;
                        that.hasWebcam = hasWebcam;
                        that.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                        that.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;
                        that.audioInputDevices = audioInputDevices;
                        that.audioOutputDevices = audioOutputDevices;
                        that.videoInputDevices = videoInputDevices;
                        that.MediaDevices = MediaDevices;

                        var missingDeviceString = [],
                            requiredDevices = that.requiredDevices;

                        if (requiredDevices.videoInput && !hasWebcam) {
                            missingDeviceString.push("NO_CAMERA");
                        }
                        if (requiredDevices.audioInput && !hasMicrophone) {
                            missingDeviceString.push("NO_MICROPHONE");
                        }

                        if (requiredDevices.audioOutput && !hasSpeakers) {
                            //FF doesn't enumerate audiooutput as of Sep 25, 2016
                            //Safari doesn't do it either as of Aug 26, 2019
                            var bypassUA = ['android'];
                            var bypassBrowsers = ["Firefox", "Safari"];
                            var showWarning = true;
                            for (var i = 0; i < bypassUA.length; i++) {
                                var env = bypassUA[i];
                                if (navigator.userAgent.toLowerCase().indexOf(env) !== -1) {
                                    showWarning = false;
                                    break;
                                }
                            }
                            if (showWarning) {
                                for (var i = 0; i < bypassBrowsers.length; i++) {
                                    if (browserName === bypassBrowsers[i]) {
                                        showWarning = false;
                                        break;
                                    }
                                }
                            }

                            if (showWarning)
                                missingDeviceString.push("NO_SPEAKERS");
                        }

                        var isWebRTCSupported = false;
                        ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
                            if (isWebRTCSupported) {
                                return;
                            }

                            if (item in window) {
                                isWebRTCSupported = true;
                            }
                        });
                        that.isWebRTCSupported = isWebRTCSupported;
                        that.environmentErrorReason = missingDeviceString;
                        that.supported = isWebRTCSupported && missingDeviceString.length === 0;

                        // Marking EDGE as unsupported
                        if (/Edge/.test(navigator.userAgent)) {
                            that.isWebRTCSupported = false;
                        }

                        if (callback) {
                            callback();
                        }
                    });
                }

                that.Events = new Object();
                that.Events["Preload"] = new eventTemplate("Preload");
                that.Events["Unload"] = new eventTemplate("Unload");
                that.Events["Load"] = new eventTemplate("Load");
                that.Events["Render"] = new eventTemplate("Render");
                that.Events["AudioStateChange"] = new eventTemplate("AudioStateChange");
                that.Events["VideoStateChange"] = new eventTemplate("VideoStateChange");
                that.Events["SessionStateChange"] = new eventTemplate("SessionStateChange");
                that.Events["Connected"] = new eventTemplate("Connected");
                that.Events["Connecting"] = new eventTemplate("Connecting");
                that.Events["Disconnecting"] = new eventTemplate("Disconnecting");
                that.Events["Disconnected"] = new eventTemplate("Disconnected");
                that.Events["MediaDevicePermissionRequested"] = new eventTemplate("MediaDevicePermissionRequested");
                that.Events["Error"] = that.Events["Failed"] = new eventTemplate("Failed");

                MCServiceAPI.ready().then(function () {
                    that.Events.Error.listen(function (evt) {
                        var descriptor = {
                            channel: 'webrtc_video',
                            error: evt
                        }
                        _fireEvent(MCServiceAPI.Events.Error, descriptor)
                    });
                    that.Events.Unload.listen(function (evt) {
                        var params = evt.params,
                            container = params.container;
                        if (!container)
                            return;
                        var cntElement = typeof container === "string" ? document.querySelector(container) : container;

                        if (cntElement)
                            cntElement.innerHTML = "";
                    });
                    that.Events.Preload.listen(function (evt) {
                        var params = evt.params,
                            container = params.container,
                            cntElement = typeof container === "string" ? document.querySelector(container) : container,
                            view = that.initial_view,
                            additionalConfig = _getAdditionalConfig();

                        if (additionalConfig && additionalConfig.lang) {
                            var selectedLanguage = additionalConfig.lang,
                                languageFileName = Utils.mapLangToLCID(selectedLanguage),
                                languageFileToLoad = [
                                    MCServiceAPI.configuration.cloudContainer + "/rely/mcservice/resources/lang/" + languageFileName + ".js"
                                ];

                            _loadAllResources(languageFileToLoad).then(function () {
                                if (cntElement) {
                                    view = _setLanguageTextStrings(view);
                                    cntElement.innerHTML = unescape(view);
                                    // Setting the "Connecting" block size
                                    var startingVideoWrapper = Utils.$("startingVideo");
                                    var videoStartWrapper = Utils.$("videoStartWrapper");
                                    Utils.css(startingVideoWrapper, {
                                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                                        borderWidth: "1px",
                                        borderStyle: "solid",
                                        borderColor: "#3a3a3a",
                                        display: "table-cell"
                                    });
                                    Utils.css(videoStartWrapper, {
                                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                                    });
                                    // Adding a class name to the webrtc container
                                    Utils.addClass(cntElement, "ll_webrtc_parent_container");
                                }
                            });
                        } else {
                            if (cntElement) {
                                view = _setLanguageTextStrings(view);
                                cntElement.innerHTML = unescape(view);
                                // Setting the "Connecting" block size
                                var startingVideoWrapper = Utils.$("startingVideo");
                                var videoStartWrapper = Utils.$("videoStartWrapper");
                                Utils.css(startingVideoWrapper, {
                                    width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                    height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                                    borderWidth: "1px",
                                    borderStyle: "solid",
                                    borderColor: "#3a3a3a",
                                    display: "table-cell"
                                });
                                Utils.css(videoStartWrapper, {
                                    width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                    height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                                });
                                // Adding a class name to the webrtc container
                                Utils.addClass(cntElement, "ll_webrtc_parent_container");
                            }
                        }

                    });
                    that.Events.Load.listen(function (evt) {

                        var channelMetadata = evt.session.channels.webrtc_video,
                            channelServer = undefined,
                            token = undefined;
                        if (channelMetadata) {
                            channelServer = channelMetadata.channelServer;
                            token = channelMetadata.token;
                        }
                        if (!channelServer) {
                            MCServiceAPI.debug.error("Required metadata missing for webrtc");
                            throw "WebRTC init error E0012";
                        }
                        if (!token) {
                            MCServiceAPI.debug.error("Required metadata missing for webrtc");
                            throw "WebRTC init error E0013";
                        }

                        if (_isHost) {
                            /* check if we already have webRTC session */
                            var sessionInProgress = undefined;
                            Object.keys(MCServiceAPI.Sessions).forEach(function (session) {
                                if (session !== evt.sessionID && sessionInProgress === undefined) {
                                    var channels = MCServiceAPI.Sessions[session].channels;
                                    if (channels && channels.webrtc_video) {
                                        /* looks to be an active session for this channel */
                                        sessionInProgress = session;
                                    }
                                }
                            });

                            if (sessionInProgress) {
                                var message = "WebRTC session " + sessionInProgress + " is already active";
                                console.error(message);
                                MCServiceAPI.debug.error(message);
                                _fireEvent(that.Events.Disconnected, {
                                    agent: false,
                                    context: that,
                                    code: "ERR_ALREADY_STARTED",
                                    reason: "ERR_ALREADY_STARTED",
                                    sessionID: evt.sessionID
                                });
                                _fireEvent(that.Events.Error, {
                                    agent: false,
                                    context: that,
                                    code: "ERR_ALREADY_STARTED",
                                    sessionID: evt.sessionID
                                });
                                return;
                            }
                        }
                        that.communicationHandler.setConfig(evt);
                        sessionStorage.setItem('CloudAuthJWTKey', evt.params.token);
                        sessionStorage.setItem('CloudAuthTenantKey', evt.params.tenantName || "ServiceCloudQA");
                        sessionStorage.setItem('CloudUserNameKey', evt.params.peerID);
                        that.communicationHandler.init(evt.params, evt.session);
                    });
                });
                MCServiceAPI.Events.Disconnecting.listen(function (evt) {
                    evt.context = that;
                    _fireEvent(that.Events.Disconnecting, evt);
                    if (evt.stopSession) {
                        that.stop(evt);
                    }
                    else {
                        try {
                            if (that.communicationHandler.peer)
                                that.communicationHandler.peer.close();
                        }
                        catch (e) { }
                        if (evt.code && !evt.reason) {
                            evt.reason = evt.code;
                        }
                        if (!evt.code && evt.reason) {
                            evt.code = evt.reason;
                        }
                        _fireEvent(that.Events.Disconnected, evt);
                    }
                });

                MCServiceAPI.Events.Disconnected.listen(function (evt) {
                    that.stop(evt);
                });

                that.Events.Render.listen(function (params) {
                    //init UI
                    that.UI.init(params);
                });

                that.ready = true;

                return new Promise(function (resolve, reject) {
                    checkDeviceSupport(function () {
                        resolve();
                    });
                });
            },
            hasMicrophone: false,
            hasSpeakers: false,
            hasWebcam: false,
            hasVideo: false,
            isWebsiteHasWebcamPermissions: false,
            isWebsiteHasMicrophonePermissions: false,
            MediaDevices: [],
            audioInputDevices: [],
            audioOutputDevices: [],
            videoInputDevices: [],
            isWebRTCSupported: false,
            environmentErrorReason: [],
            resources: [
                MCServiceAPI.configuration.cloudContainer + "/rely/video/vlauncher_baremetal.js",
                MCServiceAPI.configuration.cloudContainer + "/rely/mcservice/resources/css/mcsstyle.css"
                // "https://webvipdv101.livelook.net/webinterfaces/mcservice/vlauncher_baremetal1.js",
                // "https://webvipdv101.livelook.net/ilia/mcservice/resources/css/mcsstyle.css"
            ],
            Events: {}
        };

        var globalEnvironmentReason = [],
            initComplete = false,
            readyChecked = false;

        MCServiceAPI.init = function (isVisitor) {
            var initAsyncUpdater = MCServiceAPI.debug.logAsync("Checking environment");
            var supportedChannels = [],
                asyncWaitList = [];
            if (!("Promise" in window))
                globalEnvironmentReason.push("UNSUPPORTED_BROWSER");
            if (window.location.protocol === "http:") {
                var disallowHttp = true;
                if (document && document.currentScript) {
                    var attrValue = document.currentScript.getAttribute("data-isWebRtcHttp");
                    if (attrValue && attrValue.toLowerCase() === "on")
                        disallowHttp = false;
                }
                if (disallowHttp)
                    globalEnvironmentReason.push("INSECURE_ORIGIN");
            }
            if (globalEnvironmentReason.length !== 0) {
                MCServiceAPI.Channels.webrtc_video.environmentErrorReason = MCServiceAPI.Channels.webrtc_video.environmentErrorReason.concat(globalEnvironmentReason);
                initAsyncUpdater.reject("ENV_ERROR: " + MCServiceAPI.Channels.webrtc_video.environmentErrorReason.join(", "));
                return;
            }

            initAsyncUpdater.resolve("OK");
            initAsyncUpdater = MCServiceAPI.debug.logAsync("Initializing channels...");

            for (var channelName in MCServiceAPI.Channels) {
                if (!MCServiceAPI.Channels.hasOwnProperty(channelName))
                    continue;

                var channel = MCServiceAPI.Channels[channelName];
                if (channel.abstract)
                    continue;

                var channelUpdater = MCServiceAPI.debug.logAsync("Initializing " + channelName);

                var promise = channel.init(isVisitor);
                asyncWaitList.push(promise);

                (function (cn, cname, promise, channelUpdater) {
                    promise.then(function () {
                        if (cn.supported) {
                            channelUpdater.resolve();
                            supportedChannels.push(cname);
                        }
                        else {
                            channelUpdater.reject("not supported");
                        }
                    });
                })(channel, channelName, promise, channelUpdater);
            }

            if (typeof (MCServiceAPI.StorageManager) === "object")
                asyncWaitList.push(MCServiceAPI.StorageManager.ready());

            Promise.all(asyncWaitList).then(function () {
                Object.defineProperty(MCServiceAPI, "supportedChannels", {
                    get: function () {
                        return supportedChannels.concat();
                    }
                });

                if (supportedChannels.length === 0) {
                    initAsyncUpdater.reject("NO_SUPPORTED_CHANNELS");
                }
                else {
                    initAsyncUpdater.resolve(MCServiceAPI.supportedChannels.join(", "));
                    MCServiceAPI.debug.info("Fired MCServiceAPI.Ready");
                    _fireEvent(MCServiceAPI.Events.Ready, { type: "Ready" });
                    initComplete = true;
                }
            });

            if (isVisitor) {
                MCServiceAPI.ready().then(function () {
                    MCServiceAPI.StorageManager.getItemAsync("mcservice.host", "sessionID").then(function (value) {
                        if (value) {
                            try {
                                var json = JSON.parse(value),
                                    expired = (typeof json.lastActiveTime !== "number") || (new Date().getTime() - json.lastActiveTime > 200000),
                                    resumeMessage = MCServiceAPI.debug.logAsync("Found session: " + json.sessionID);

                                if (expired || true) {
                                    resumeMessage.reject("Expired");
                                    MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                                }
                                else {
                                    MCServiceAPI.Site.resume({ session: json.sessionID, apiKey: json.siteCode, accessToken: json.accessToken }, json.channels)
                                        .then(function () {
                                            resumeMessage.resolve();
                                        })
                                        .catch(function (err) {
                                            resumeMessage.reject(err.status);
                                            MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                                        });
                                }
                            }
                            catch (e) {
                                MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                            }
                        }
                    })
                });
            }
        }

        MCServiceAPI.ready = function () {
            var readyWait = readyChecked ? null : MCServiceAPI.debug.logAsync("Waiting for the READY state...");
            readyChecked = true;
            return new Promise(function (resolve, reject) {
                if (initComplete) {
                    resolve();
                }
                else {
                    /*TMP_DEBUG: ugly fix for Field Service*/
                    MCServiceAPI.Channels.webrtc_video_both = MCServiceAPI.Channels.webrtc_video;
                    if (globalEnvironmentReason.length !== 0) {
                        //READY will never fire here
                        if (readyWait)
                            readyWait.reject("ENV_ERROR");
                        reject({ reason: "ENV_ERROR", code: globalEnvironmentReason.join(", ") });
                    }
                    else {
                        MCServiceAPI.Events.Ready.wait(function () {
                            if (readyWait)
                                readyWait.resolve("READY");

                            resolve();
                        });
                    }

                }
            });
        }


        var _storeSessionData = function (session, channels) {
            var storedChannels = {};
            Object.keys(channels).forEach(function (channel) {
                storedChannels[channel] = channels[channel].constructor();
                for (var attr in channels[channel]) {
                    if (channels[channel].hasOwnProperty(attr))
                        storedChannels[channel][attr] = channels[channel][attr];
                }
                if (storedChannels[channel].container && typeof storedChannels[channel].container !== "string") {
                    var id = storedChannels[channel].container.getAttribute("id");
                    if (!id) {
                        id = "mcservice.host." + Math.random.toString(36).slice(2);
                        storedChannels[channel].container.setAttribute("id", id);
                    }
                    storedChannels[channel].container = "#" + id;
                }
                delete storedChannels[channel].token;
            })
            var resumeData = {
                accessToken: MCServiceAPI.Sessions[session].accessToken,
                sessionID: session,
                siteCode: MCServiceAPI.Sessions[session].siteCode,
                channels: storedChannels
            };

            MCServiceAPI.StorageManager.setItemAsync("mcservice.host", "sessionID", JSON.stringify(resumeData)).then(function () {
                /*start pings*/
                _amAlive();
            });

            MCServiceAPI.Events.Disconnected.wait(function (evt) {
                var sessionID = evt.sessionID;
                if (sessionID) {
                    MCServiceAPI.StorageManager.getItemAsync("mcservice.host", "sessionID").then(function (value) {
                        if (value) {
                            try {
                                var json = JSON.parse(value);
                                if (json.sessionID === sessionID) {
                                    _terminateSession(sessionID, true);
                                    MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                                }
                            }
                            catch (e) {
                                MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                            }
                        }
                    })
                }
            });
        };

        var _responseParser = function (channels, authData, responseData, reject) {
            var responseParserMessage = MCServiceAPI.debug.logAsync("Parsing response"),
                parseError = false,
                sessionID = authData.session;

            var newData = JSON.parse(responseData);
            if (MCServiceAPI.Sessions[sessionID] && MCServiceAPI.Sessions[sessionID].channels) {
                Object.keys(newData.channels).forEach(function (newChannel) {
                    if (!MCServiceAPI.Sessions[sessionID].channels[newChannel])
                        MCServiceAPI.Sessions[sessionID].channels[newChannel] = newData.channels[newChannel]
                });

                if (newData.accessToken)
                    MCServiceAPI.Sessions[sessionID].accessToken = newData.accessToken;
            }
            else {
                MCServiceAPI.Sessions[sessionID] = newData;
            }

            MCServiceAPI.Sessions[sessionID].siteCode = authData.apiKey;

            // Storing the auth data into the local storage
            localStorage.setItem("accessToken", MCServiceAPI.Sessions[sessionID].accessToken);
            localStorage.setItem("apiKey", authData.apiKey);
            localStorage.setItem("sessionIdentifier", sessionID);

            Object.keys(channels).forEach(function (key) {
                if (parseError)
                    return;

                var userChannel = channels[key],
                    serverChannel = newData.channels[key],
                    mcChannel = MCServiceAPI.Channels[key];

                var channelMessage = MCServiceAPI.debug.logAsync("Parsing metadata for " + key);

                if (serverChannel && userChannel && mcChannel) {

                    if (!serverChannel.token) {
                        parseError = true;
                        channelMessage.reject("501 Unavailable");
                        responseParserMessage.reject();
                        MCServiceAPI.debug.error("Channel " + key + " not implemented");

                        if (mcChannel.Events.Error) {
                            _fireEvent(mcChannel.Events.Error, {
                                code: "ERR_MISSING_METADATA",
                                context: mcChannel,
                                sessionID: authData.session,
                                responseText: "Server failed to supply required data. Channel will not start."
                            });
                        }

                        reject({ code: "501", channel: key, reason: "ERR_NOT_IMPLEMENTED" });
                        return;
                    }
    
                    // Parsing the token to get the peerID
                    var peerID = serverChannel.peerID,
                        iss = "example.com"; //serverChannel.iss;

                    Object.keys(serverChannel).forEach(function (serverKey) {
                        userChannel[serverKey] = serverChannel[serverKey];
                    });

                    if (peerID) {
                        userChannel.peerID = peerID + "@" + iss;
                        channels.webrtc_video.peerID = MCServiceAPI.Sessions[sessionID].channels.webrtc_video.peerID = peerID + "@" + iss;
                        MCServiceAPI.Sessions[sessionID].channels.webrtc_video.videoDirection = serverChannel.videoDirection;
                    }

                    channelMessage.resolve();
                };
            })

            responseParserMessage.resolve();
        };

        MCServiceAPI.Site.resume = function (authData, channels) {
            return new Promise(function (resolve, reject) {
                /*
                if (MCServiceAPI.Sessions && Object.keys(MCServiceAPI.Sessions).length > 0) {
                    //visitor side can't have two simultaneous sessions 
                    MCServiceAPI.debug.error("Session is already in progress");
                    reject({ code: "IN_PROGRESS", reason: "Another session is already in progress" });
                    return;
                };
                */

                var authAsyncLog = MCServiceAPI.debug.logAsync("Fetching session metadata"),
                    sessionID = typeof authData.session === "string" ? authData.session.toLowerCase() : "";

                MCServiceAPI.ready()
                    .then(function () {
                        var channelsToStart = JSON.stringify(Object.keys(channels).reduce(
                            function (object, key) {
                                object[key] = true;
                                return object
                            }, {}));

                        return _request("GET", MCServiceAPI.configuration.auth.start + "/visitor/" + sessionID,
                            channelsToStart,
                            {
                                "x-api-key": authData.apiKey,
                                "x-access-token": authData.accessToken
                            });
                    })
                    .then(function (data) {
                        authAsyncLog.resolve("200 OK");
                        _responseParser(channels, authData, data, reject);
                        // Appending the needed resources
                        _renderJSAndStyles(channels, sessionID);
                        _storeSessionData(authData.session, channels);
                        resolve();
                    }).catch(function (result) {
                        var errorObject = { code: result && result.status ? result.status : "403", reason: result && result.statusText ? result.statusText : "Authentication error" };
                        authAsyncLog.reject(errorObject.code + " (" + errorObject.reason + ")");
                        reject(errorObject);
                    });
            });

        };

        MCServiceAPI.Site.start = function (authData, channels, config) {
            if (config) {
                _setAdditionalConfig(config);
            }

            return new Promise(function (resolve, reject) {
                //check if another session is in progress
                var sessionUpgrade = false,
                    existingSessions = MCServiceAPI.Sessions ? Object.keys(MCServiceAPI.Sessions) : [];

                authData.session = (typeof authData.session === "string" ? authData.session.toLowerCase() : "");

                existingSessions.forEach(function (existingSID) {
                    if (!sessionUpgrade)
                        sessionUpgrade = authData.session === existingSID;
                });

                MCServiceAPI.ready().then(function () {
                    //check if requested channels are supported
                    var validateLog = MCServiceAPI.debug.logAsync("Validating requested channels"),
                        invalidChannels = [];
                    if (channels["webrtc_video_both"] !== undefined && channels["webtrc_video"] === undefined) {
                        console.error("Channel webrtc_video_both is deprecated, and its support will be discontinued. Please refer to the documentation on how to make bi-directional video calls in a supported way.");
                        channels.webrtc_video = channels.webrtc_video_both;
                        delete channels.webrtc_video_both;
                    }
                    Object.keys(channels).forEach(function (channel) {
                        if (!MCServiceAPI.Channels[channel].supported) {
                            invalidChannels.push(channel);
                        }
                    });
                    if (invalidChannels.length !== 0) {
                        validateLog.reject("ENV_ERROR: " + invalidChannels.join(", "));
                        reject({ code: "ENV_ERROR", reason: JSON.stringify(invalidChannels) });
                        return;
                    }

                    _fireEvent(MCServiceAPI.Events.Connecting, {});
                    validateLog.resolve("OK");

                    // Showing an initial view until the components are initialized
                    Object.keys(channels).forEach(function (channel) {
                        var mcChannel = MCServiceAPI.Channels[channel];
                        if (mcChannel && mcChannel.Events["Preload"]) {
                            console.log(Utils.getTimeString() + ": firing onpreload for: " + channel + " as visitor");
                            _fireEvent(mcChannel.Events.Preload, {
                                context: mcChannel,
                                sessionID: authData.session,
                                apiKey: authData.apiKey,
                                params: channels[channel],
                                agent: false
                            });
                        }
                    });

                    var authAsyncLog = MCServiceAPI.debug.logAsync("Authenticating visitor connection"),
                        channelsToStart = JSON.stringify(Object.keys(channels).reduce(
                            function (object, key) {
                                object[key] = true;
                                return object
                            }, {})),
                        headers = {
                            "x-jwt-token": authData.authToken,
                            "x-api-key": authData.apiKey
                        };
                    if (sessionUpgrade)
                        headers["x-http-method-override"] = "PATCH";

                    _request("POST", MCServiceAPI.configuration.auth.start + "/visitor/" + authData.session, channelsToStart, headers)
                        .then(function (data) {
                            authAsyncLog.resolve("200 OK");

                            _responseParser(channels, authData, data, reject);
                            // Appending the needed resources
                            _renderJSAndStyles(channels, authData.session);
                            _storeSessionData(authData.session, channels);
                            resolve();
                        }).catch(function (result) {
                            var storedAccessToken = localStorage.getItem("accessToken");
                            if (!sessionUpgrade && result.status === 409 && storedAccessToken) {   // Retrieving the session if it's alive
                                authAsyncLog.resolve("409 ALREADY_EXISTS", "warning");
                                authData.accessToken = storedAccessToken;
                                MCServiceAPI.Site.resume(authData, channels)
                                    .then(function () {
                                        resolve();
                                    }).catch(function (errorObject) {
                                        Object.keys(channels).forEach(function (channel) {
                                            var mcChannel = MCServiceAPI.Channels[channel];
                                            if (mcChannel && mcChannel.Events["Unload"]) {
                                                console.log(Utils.getTimeString() + ": firing onunload for: " + channel + " as visitor");
                                                _fireEvent(mcChannel.Events.Unload, {
                                                    context: mcChannel,
                                                    sessionID: authData.session,
                                                    apiKey: authData.apiKey,
                                                    params: channels[channel],
                                                    agent: false
                                                });
                                            }
                                        });
                                        reject(errorObject);
                                    })
                            } else {
                                if (typeof ((result.stack) !== "undefined") && (typeof (result.message) !== "undefined"))
                                    MCServiceAPI.debug.error(result);

                                var errorObject = { code: result && result.status ? result.status : "403", reason: result && result.statusText ? result.statusText : "Authentication error" };
                                authAsyncLog.reject(errorObject.code + " (" + errorObject.reason + ")");
                                Object.keys(channels).forEach(function (channel) {
                                    var mcChannel = MCServiceAPI.Channels[channel];
                                    if (mcChannel && mcChannel.Events["Unload"]) {
                                        console.log(Utils.getTimeString() + ": firing onunload for: " + channel + " as visitor");
                                        _fireEvent(mcChannel.Events.Unload, {
                                            context: mcChannel,
                                            sessionID: authData.session,
                                            apiKey: authData.apiKey,
                                            params: channels[channel],
                                            agent: false
                                        });
                                    }
                                });
                                reject(errorObject);
                            }
                        });
                });
            });
        }

        MCServiceAPI.Site.endSession = function (descriptor) {
            return new Promise (function (resolve, reject) {
                var id = undefined,
                    reason = undefined;
                if (descriptor && typeof descriptor === "object") {
                    id = typeof descriptor.sessionID === "string" ? descriptor.sessionID.toLowerCase() : descriptor.sessionID;
                    reason = descriptor.reason;
                }

                if (id === undefined)
                    id = Object.keys(MCServiceAPI.Sessions)[0];
                if (id === undefined || MCServiceAPI.Sessions[id] === undefined) {
                    //no active session
                    MCServiceAPI.debug.error("No active session found");
                    reject("No active session found");
                }
                var allChannels = true,
                    channels = [];
                if (descriptor && typeof descriptor === "object" && "channels" in descriptor && descriptor.channels.length) {
                    descriptor.channels.forEach(function (channel) {
                        if (channel === "*") {
                            Object.keys(MCServiceAPI.Sessions[id]).forEach(function (sessionChannel) {
                                if (channels.indexOf(sessionChannel) === -1)
                                    channels.push(sessionChannel);
                            });
                        }
                        else if (channels.indexOf(channel) === -1)
                            channels.push(channel);
                    });
                    if (channels.length !== Object.keys(MCServiceAPI.Sessions[id].channels).length)
                        allChannels = false;
                }

                if (allChannels) {
                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnecting for " + id);
                    _fireEvent(MCServiceAPI.Events.Disconnecting, {
                        reason: reason,
                        agent: false,
                        stopSession: true,
                        sessionID: id
                    });

                    _terminateSession(id, true);
                }
                else {
                    channels.forEach(function (channel) {
                        if (MCServiceAPI.Channels[channel] && typeof MCServiceAPI.Channels[channel].stop === "function") {
                            MCServiceAPI.Channels[channel].stop({ sessionID: id, reason: descriptor.reason });
                        }
                        else {
                            MCServiceAPI.debug.error("Can't terminate channel " + channel);
                        }
                    })
                    _removeChannels(id, channels, true);
                }

                resolve();
            });
        }


        var _logAsyncOperation = function (message, type) {
            var element = null,
                finished = false,
                that = MCServiceAPI.debug,
                div = that.container,
                msg = document.createElement("span"),
                span = document.createElement("span"),
                p = document.createElement("p"),
                progressTimer = 0;

            if (that.enabled) {
                if (typeof div !== "object") {
                    that.initContainer();
                    div = that.container;
                }

                msg.innerHTML = msg.innerText = Utils.getTimeString() + ": " + message;
                span.id = "log" + Math.random() * 1000;
                Utils.css(span, {
                    "font-weight": "bold",
                    position: "relative",
                    float: "right",
                    left: "-30px",
                    "text-align": "right",
                    "max-width": "250px",
                    "word-wrap": "break-word"
                });
                Utils.css(p, {
                    "vertical-align": "top",
                    "margin-top": "3px",
                    "margin-bottom": 0,
                    "margin-left": "10px",
                    "clear": "both",
                    color: "inherit"
                });

                if (type === "warning")
                    p.style.color = "orange";
                else if (type === "info") {
                    p.style.color = "white";
                }
                else if (type === "error")
                    p.style.color = "red";

                p.appendChild(msg);
                p.appendChild(span);
                span.style.setProperty("float", "right"); //mac firefox bug

                div.appendChild(p);
                div.scrollTop = div.scrollHeight;

                span.start = performance.now();
                element = span;

                progressTimer = setTimeout(function () {
                    span.innerHTML = "<span style='color:lightslategray;font-style:italic'>Pending...</span>"
                }, 1000);
            }

            return {
                resolve: function (message, type) {
                    if (progressTimer !== 0) {
                        clearTimeout(progressTimer);
                        progressTimer = 0;
                    }

                    if (!MCServiceAPI.debug.enabled || finished || !element)
                        return;
                    var startTime = element.start,
                        elapsedTime = startTime ? performance.now() - startTime : 0;

                    var timeMessage = "",
                        timeColor = "";
                    if (elapsedTime > 50) {
                        timeMessage += "(" + elapsedTime.toFixed(3) + " ms) ";
                        if (elapsedTime > 10000) {
                            timeColor = "Red";
                        }
                        else if (elapsedTime > 5000)
                            timeColor = "Orange";
                        else if (elapsedTime > 1000)
                            timeColor = "Yellow";

                        if (timeColor)
                            timeMessage = "<span style='color:" + timeColor + ";'>" + timeMessage + "</span>";
                    }

                    if (type === "warning") {
                        timeColor = "Orange";
                        element.innerHTML = timeMessage + "<span style='color:orange;'>" + (message !== undefined ? message : "SUCCESS") + "</span>";
                    } else {
                        element.innerHTML = timeMessage + (message !== undefined ? message : "SUCCESS");
                    }
                    finished = true;
                },
                reject: function (message) {
                    if (progressTimer !== 0) {
                        clearTimeout(progressTimer);
                        progressTimer = 0;
                    }

                    if (!MCServiceAPI.debug.enabled || finished || !element)
                        return;
                    Utils.css(element, {
                        color: "Red",
                        "font-weight": "Normal"
                    });
                    element.innerHTML = message ? message : "FAILED";
                    finished = true;
                }
            }
        }

        MCServiceAPI.debug = {
            enabled: false,
            container: "#log",
            messages: {},
            initContainer: function () {
                var container = this.container;
                if (typeof (container) === "string") {
                    container = document.querySelector(this.container);
                    if (!container) {
                        container = document.createElement("DIV");
                        if (document.body)
                            document.body.appendChild(container)
                        else {
                            var _bodyCheckTimer = function () {
                                if (document.body)
                                    document.body.appendChild(container);
                                else
                                    setTimeout(_bodyCheckTimer, 1000);
                            }
                            setTimeout(_bodyCheckTimer, 1000);
                        }
                    }
                    this.container = container;
                }

                container.innerHTML = "TRACE LOG<br />----------<br />";
                Utils.css(container, {
                    "min-height": "100px",
                    "max-height": "480px",
                    "overflow-y": "auto",
                    width: "40%",
                    padding: "10px",
                    border: "1px solid #000",
                    color: "green",
                    position: "absolute",
                    "background-color": "black",
                    font: "normal 12px 'Lucida Console', Monaco"
                });
            },
            logAsync: function (message) {
                return new _logAsyncOperation(message);
            },
            info: function (message, result) {
                new _logAsyncOperation(message, "info").resolve(result === undefined ? "" : result);
            },
            log: function (message, result) {
                new _logAsyncOperation(message, "log").resolve(result === undefined ? "" : result);
            },
            warn: function (message) {
                new _logAsyncOperation(message, "warning").resolve("");
            },
            error: function (message) {
                new _logAsyncOperation(message, "error").resolve("");
            }
        };

        if (document && typeof document.currentScript !== "undefined") {
            var src = document.currentScript.src || "",
                search = src.indexOf("?") === -1 ? "" : src.substr(src.indexOf("?") + 1),
                params = search.split('&'),
                urlObject = params.reduce(function (acc, val) {
                    var parts = val.split("=");
                    acc[parts[0]] = parts[1];
                    return acc;
                }, {});
            if (urlObject.debug === "yes" || urlObject.debug === "true")
                MCServiceAPI.debug.enabled = true;
    
        }
})();

/* compiled output of storageManager.ts for compatibility purposes with legacy MCService and legacy engine */
!function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=12)}([function(e,t,n){"use strict";t.__esModule=!0,t.formatValue=function(e,t){void 0===t&&(t=2);for(var n=e.toString();n.length<t;)n="0"+n;return n},t.getCurrentTime=function(){return(new Date).getTime()},t.getTimeString=function(){var e=new Date;return t.formatValue(e.getHours())+":"+t.formatValue(e.getMinutes())+":"+t.formatValue(e.getSeconds())+"."+t.formatValue(e.getMilliseconds(),3)},t.getDateTimeString=function(){var e=new Date,n=t.formatValue(e.getHours()),r=t.formatValue(e.getMinutes()),i=t.formatValue(e.getSeconds()),o=t.formatValue(e.getDate());return t.formatValue(e.getMonth()+1)+"/"+o+"/"+e.getFullYear()+" "+n+":"+r+":"+i},t.isString=function(e){return"string"==typeof e},t.compareIgnoreCase=function(e,n){if(t.isString(e)&&t.isString(n))return 0===e.localeCompare(n,void 0,{sensitivity:"accent"});if(t.isEmpty(n)||n.constructor!==Array)return e!==n;for(var r=!1,i=0;i<n.length;i++){if(t.compareIgnoreCase(e,n[i])){r=!0;break}}return r},t.isFunction=function(e){return"function"==typeof e},t.isEmpty=function(e){return null==e||""===e||0===e||!1===e};var r=/^\s*$/;t.isWhitespace=function(e){return r.test(e)},t.isMethodNative=function(e){return!!t.isFunction(e)&&/\{\s*\[native code\]\s*\}/.test(""+e)},t.getViewPort=function(){var e,n=0,r=0;return void 0!==window.innerWidth?(n=window.innerWidth,r=window.innerHeight):t.isEmpty(null===(e=document.documentElement)||void 0===e?void 0:e.clientWidth)?(n=document.getElementsByTagName("body")[0].clientWidth,r=document.getElementsByTagName("body")[0].clientHeight):(n=document.documentElement.clientWidth,r=document.documentElement.clientHeight),{width:n,height:r}},t.getWinHeight=function(){return window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight},t.getWinWidth=function(){return window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth},t.getElementAs=function(e){return document.getElementById(e)},t.setClass=function(e,n){var r=t.isString(e)?t.getElementAs(e):e;null!==r&&(r.className=n)},t.setCss=function(e,n){var r=t.isString(e)?t.getElementAs(e):e;null!==r&&Object.keys(n).forEach(function(e){r.style.setProperty(e,n[e])})},t.hideElement=function(e){t.setCss(e,{display:"none"})},t.showElement=function(e){t.setCss(e,{display:"block"})},t.fireEvent=function(e,n){try{var r=null;return t.isFunction(document.createEvent)?(r=document.createEvent("MouseEvent")).initMouseEvent(n,!0,!0,window,0,0,0,0,0,!1,!1,!1,!1,0,null):r=new MouseEvent(n,{button:0,bubbles:!0,view:window,cancelable:!0}),!e.dispatchEvent(r)}catch(e){return!1}},t.stopEvent=function(e){var n=t.isEmpty(e)?window.event:e;t.isEmpty(n)||(n.returnValue=!1,n.cancelBubble=!0,t.isFunction(n.stopPropagation)&&n.stopPropagation(),t.isFunction(n.preventDefault)&&n.preventDefault())},t.displayText=function(e,n){var r=t.isString(e)?t.getElementAs(e):e;null!==r&&(r.innerHTML=null!=n?n:"")},t.preloadImageBySource=function(e){(new Image).src=e},t.preloadImage=function(e){return t.preloadImageBySource(e.src)};var i=null;t.htmlEncode=function(e){return null===i&&(i=document.createElement("span")),i.innerText=e,i.innerHTML},t.htmlDecode=function(e){return null===i&&(i=document.createElement("span")),i.innerHTML=e,i.innerText},t.randomInRange=function(e,t){return Math.floor(Math.random()*(t-e+1)+e)},t.getTopFrame=function(){try{try{var e=top.location.hostname;if(t.isString(e))return top}catch(e){}for(var n=self,r=0;n!=n.parent&&r++<32;){try{var i=n.parent.location.hostname;if(t.isString(i)){n=n.parent;continue}}catch(e){}return n}return n}catch(e){return self}}},function(e,t,n){"use strict";t.__esModule=!0,t.STORAGE_IE_TIME_KEY="ie11_time",t.STORAGE_IE_TIME_STRING=";"+t.STORAGE_IE_TIME_KEY+"=",t.STORAGE_EVENT_CMD="ll.event",t.STORAGE_RESPONSE_CMD="ll.response",t.STORAGE_READY_CMD="ready",t.ERROR_STORAGE_UNAVAILABLE="ERR_STORAGE_UNAVAILABLE",t.ERROR_ENVIRONMENT="ERR_UNSUPPORTED_ENV",t.ERROR_PROMISE_TIMEOUT="ERR_PROMISE_TIMEOUT",t.ERROR_REQUEST_TIMEOUT="ERR_REQUEST_TIMEOUT",t.ERROR_TIMEOUT="ERR_TIMEOUT",t.ERROR_NO_ARGS="ERR_MISSING_ARGS",t.ERROR_CONTEXT_LOCKED="ERR_ALREADY_LOCKED",t.ERROR_NO_STORAGE_MANAGER="ERR_STORAGE_MANAGER_MISSING",t.ERROR_OPERATION_FAILED="ERR_FAILED",t.ERROR_COMPONENT_MISSING="REQUIRED_COMPONENT_MISSING",t.ERROR_NETWORK_TIMEOUT="ERROR_NETWORK_TIMEOUT",t.INSTANCE_CONFIG_ERROR="ERROR_INSTANCE_NOT_CONFIGURED"},function(e,t,n){"use strict";t.__esModule=!0;var r=n(0);t.eventScopeMatches=function(e,n){var i,o,a,s,u,c;if(r.isEmpty(n)&&(n=t.extractLocalScope()),r.isEmpty(e)&&r.isEmpty(n))return!0;if(r.isEmpty(e)||r.isEmpty(n))return!1;var l=null===(i=n.siteCode)||void 0===i?void 0:i.toLowerCase(),d=null===(o=e.siteCode)||void 0===o?void 0:o.toLowerCase();if(void 0!==l&&void 0!==d&&d!==l)return!1;var v=null===(a=n.server)||void 0===a?void 0:a.toLowerCase().replace("https://",""),p=null===(s=e.server)||void 0===s?void 0:s.toLowerCase().replace("https://","");if(void 0!==v&&void 0!==p&&v!==p)return!1;var h=null===(u=n.SID)||void 0===u?void 0:u.toLowerCase(),m=null===(c=e.SID)||void 0===c?void 0:c.toLowerCase();return void 0===h||void 0===m||h===m},t.extractLocalScope=function(){var e,t,n,i=window.MCServiceAPI,o=window.Cobrowse,a={};try{if(void 0!==o&&void 0!==o.Deployment&&void 0!==o.API&&(a.siteCode=o.Deployment.siteCode,a.accessCode=o.API.Session.accessCode,a.SID=o.API.Session.SID,a.server=o.Deployment.scriptServerPath),void 0!==i&&void 0!==i.Sessions){if(r.isEmpty(a.SID))for(var s=Object.keys(i.Sessions),u=0;u<s.length;u++)if(void 0!==(null===(e=i.Sessions[s[u]].channels)||void 0===e?void 0:e.cobrowse)){a.SID=s[u];break}if(r.isEmpty(a.server)){var c=i.configuration.mainServer;r.isString(c)&&(a.server=c.split("://")[1])}if(!r.isEmpty(a.SID)){var l=i.Sessions[a.SID];r.isEmpty(a.siteCode)&&(a.siteCode=l.siteCode),r.isEmpty(a.server)&&(a.server=null===(n=null===(t=l.channels)||void 0===t?void 0:t.cobrowse)||void 0===n?void 0:n.channelServer)}}if(void 0!==window.LL_Deployment){var d=window.LL_Deployment;r.isEmpty(a.siteCode)&&(a.siteCode=d.siteCode),r.isEmpty(a.server)&&(a.server=d.scriptServerPath)}r.isString(a.server)&&(a.server=a.server.replace("https://",""))}catch(e){}return a},t.getStorageInstance=function(){var e=window.MCServiceAPI,t=window.Cobrowse;if(void 0!==t&&void 0!==t.StorageManager)return void 0!==e&&void 0===e.StorageManager&&(e.StorageManager=t.StorageManager),t.StorageManager;if(void 0!==e&&void 0!==e.StorageManager)return void 0!==t&&void 0===t.StorageManager&&(t.StorageManager=e.StorageManager,window.LL_Storage_Manager=t.StorageManager,window.LL_Storage_Manager.asyncSupported=t.StorageManager.supported),e.StorageManager;var n=window.LL_Storage_Manager;return void 0!==n?n:null}},,,,,function(e,t,n){"use strict";t.__esModule=!0;var r=n(1),i=n(0),o=n(2);t.validateGenericEvent=function(e,t,n,r,o){if(null!==n)try{var a=JSON.parse(n);i.isEmpty(null==a?void 0:a.id)||i.isEmpty(null==a?void 0:a.timestamp)||i.isEmpty(null==a?void 0:a.eventName)?null==o||o.push(r):i.getCurrentTime()-a.timestamp>6e4?null==o||o.push(r):e.indexOf(a.id)>-1?null==o||o.push(r):t(a)}catch(e){null==o||o.push(r)}},t.invalidateGenericEvents=function(e,t){var n,a;if(!0===t.invalidate){var s=t.eventName,u=[],c=null===(n=t.eventData)||void 0===n?void 0:n.scope;for(var l in e)if(!i.isEmpty(l)&&e.hasOwnProperty(l)&&0===l.indexOf(r.STORAGE_EVENT_CMD))try{var d=JSON.parse(e[l]);if(d.eventName===s){var v=null===(a=d.eventData)||void 0===a?void 0:a.scope;i.isEmpty(v)||i.isEmpty(c)?u.push(l):o.eventScopeMatches(v,c)?u.push(l):console.warn("Skipping event from a non-matching-scope",d,"while invalidating scope",c)}}catch(e){u.push(l)}for(var p=0;p<u.length;p++)e.removeItem(u[p])}};var a=function(e){return i.isString(e)?e.split(r.STORAGE_IE_TIME_STRING):[""]},s=function(e){if(!i.isString(e))return e;for(;e.indexOf("LL_LITERAL_")>-1;){var t=e.indexOf("LL_LITERAL_"),n=e.substring(t+11,t+14);e=e.replace(new RegExp("LL_LITERAL_"+n,"g"),String.fromCharCode(parseInt(n,10)))}return e},u=function(e){if("object"==typeof e)return u(JSON.stringify(e));if(i.isString(e)){for(var t=0;t<",();|{}".length;t++)e.indexOf(",();|{}"[t])>-1&&(e=e.replace(new RegExp("\\"+",();|{}"[t],"g"),"LL_LITERAL_"+i.formatValue(",();|{}".charCodeAt(t),3)));return e}return e},c=function(){function e(){}return e.processSiteID=function(e){return i.isString(e)?e.replace(/\:/g,"").toUpperCase():null},e.prepareCommandArgs=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var n="";return e.forEach(function(e){n.length>0&&(n+=","),n+=u(e)}),n},e.restoreArgs=function(e){if(i.isEmpty(e)||0===e.length)return e;for(var t=0;t<e.length;t++)e[t]=s(e[t]);return e},e.cutOutTimeString=a,e.restoreArg=s,e.cutOutTimeStrings=function(e){for(var t in e)if(e.hasOwnProperty(t)){var n=e[t];e[t]=i.isString(n)?a(n)[0]:n}return e},e.getKeyValue=function(e){var t=null,n=window.MCServiceAPI,r=window.Cobrowse;switch(e){case"dataServerURL":if(void 0!==r&&void 0!==r.Deployment)t=r.Deployment.dataServerPath+"/storage/";else if(void 0!==n&&n.configuration)t=n.configuration.dataServerPath+"/storage/";else{var o=window.LL_Deployment;void 0!==o&&(t=o.dataServerPath+"/storage/")}break;case"version":if(void 0!==r&&void 0!==r.Deployment)t=r.Deployment.version;else if(void 0!==n&&void 0!==n.configuration)t=n.configuration.version;else{var a=new Date,s=a.getMonth(),u=a.getDate();t=""+a.getFullYear()+i.formatValue(s)+i.formatValue(u)}}return t},e}();t.StorageUtils=c},function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))(function(i,o){function a(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(a,s)}u((r=r.apply(e,t||[])).next())})},i=this&&this.__generator||function(e,t){var n,r,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],r=0}finally{n=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}};t.__esModule=!0;var o=n(0),a=n(1);t.keepTrying=function(e,n,a,s){return void 0===s&&(s=0),r(void 0,void 0,void 0,function(){var r,u,c;return i(this,function(i){switch(i.label){case 0:r=o.getCurrentTime(),i.label=1;case 1:return i.trys.push([1,3,,8]),[4,e()];case 2:return[2,i.sent()];case 3:return u=i.sent(),o.getCurrentTime()<r+a?n(u)?0===s?[3,5]:[4,t.sleep(s)]:[3,7]:[3,7];case 4:i.sent(),i.label=5;case 5:return c=Math.max(0,o.getCurrentTime()-r+a),[4,t.keepTrying(e,n,c,s)];case 6:return[2,i.sent()];case 7:throw u;case 8:return[2]}})})},t.noLongerThan=function(e,t){return new Promise(function(n,r){var i=!1,o=setTimeout(function(){i=!0,r(new Error(a.ERROR_PROMISE_TIMEOUT))},e);t.then(function(e){clearTimeout(o),i||n(e)})})};var s=function(e){return r(void 0,void 0,void 0,function(){return i(this,function(t){return[2,new Promise(function(t){return setTimeout(t,e)})]})})};t.sleep=function(e){return r(void 0,void 0,void 0,function(){return i(this,function(t){switch(t.label){case 0:return[4,s(e)];case 1:return t.sent(),[2]}})})},t.sleepWithValue=function(e,t){return new Promise(function(n){setTimeout(n.bind(null,t),e)})},t.callAsync=function(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];return new Promise(function(n){e.apply(window,t),n()})}},,function(e,t,n){"use strict";t.__esModule=!0;var r=n(0),i=function(){return function(){this.ID=Math.random().toString(36).substr(2)+(new Date).getTime().toString(36)}}();t.getOrCreateContext=function(e){var t=(void 0===e?window:e).Cobrowse;if(!r.isEmpty(null==t?void 0:t.Context))return t.Context;var n=new i;return void 0!==t&&(t.Context=n),n},t.Context=t.getOrCreateContext()},function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))(function(i,o){function a(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(a,s)}u((r=r.apply(e,t||[])).next())})},i=this&&this.__generator||function(e,t){var n,r,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],r=0}finally{n=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}};t.__esModule=!0;var o=n(1),a=n(0),s=n(2),u=new Map([["Cobrowse.disconnected",["Cobrowse.connected","Cobrowse.disconnecting","Cobrowse.escalationAccepted","Cobrowse.escalationDeclined","Cobrowse.state","Cobrowse.startRequested","MCService.Cobrowse.startRequested","Cobrowse.stopRequested","MCService.Cobrowse.stopRequested"]],["Cobrowse.state",["Cobrowse.state"]],["Cobrowse.escalationAccepted",["Cobrowse.escalationDeclined"]],["Cobrowse.escalationDeclined",["Cobrowse.escalationAccepted"]],["Cobrowse.stopRequested",["Cobrowse.startRequested","MCService.Cobrowse.startRequested"]],["Cobrowse.startRequested",["Cobrowse.stopRequested","MCService.Cobrowse.stopRequested"]]]),c=function(){function e(e){this.id=Math.random().toString(36).slice(2),this.timestamp=a.getCurrentTime(),this.eventName=e}return e.fire=function(t,n,o){return r(this,void 0,void 0,function(){return i(this,function(r){switch(r.label){case 0:return[4,new e(t).dispatch(n,o)];case 1:return r.sent(),[2]}})})},e.invalidate=function(e){var t=s.getStorageInstance();return null===t?Promise.reject(new Error(o.ERROR_NO_STORAGE_MANAGER)):t.propagateEvent({timestamp:a.getCurrentTime(),id:Math.random().toString(36).slice(2),invalidate:!0,eventName:e,eventData:{scope:s.extractLocalScope()}})},e.parse=function(t){if(a.isEmpty(t)||t.command!==o.STORAGE_EVENT_CMD||a.isEmpty(t.eventObject))return null;var n=new e(t.eventObject.eventName);return n.id=t.eventObject.id,n.timestamp=t.eventObject.timestamp,n.eventData=t.eventObject.eventData,n},e.prototype.dispatch=function(t,n){var c=this;return new Promise(function(l,d){return r(c,void 0,void 0,function(){var r,c,v,p;return i(this,function(i){switch(i.label){case 0:return!0===n&&u.has(this.eventName)?(r=[],null===(p=u.get(this.eventName))||void 0===p||p.forEach(function(t){r.push(e.invalidate(t))}),[4,Promise.all(r)]):[3,2];case 1:i.sent(),i.label=2;case 2:a.isEmpty(t)&&(t={}),a.isEmpty(t.scope)&&(t.scope=s.extractLocalScope()),this.eventData=t,this.eventData.id=this.id,this.eventData.timestamp=this.timestamp,this.eventData.eventName=this.eventName;try{c=new CustomEvent(this.eventName,{detail:this.eventData})}catch(e){(c=document.createEvent("CustomEvent")).initCustomEvent(this.eventName,!1,!1,this.eventData)}return window.dispatchEvent(c),!0!==n?[3,4]:null===(v=s.getStorageInstance())?(d(new Error(o.ERROR_NO_STORAGE_MANAGER)),[2]):[4,v.propagateEvent({id:this.id,invalidate:!1,timestamp:this.timestamp,eventName:this.eventName,eventData:this.eventData})];case 3:i.sent(),i.label=4;case 4:return l(),[2]}})})})},e}();t.WidgetEvent=c},function(e,t,n){"use strict";var r=this&&this.__awaiter||function(e,t,n,r){return new(n||(n=Promise))(function(i,o){function a(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(a,s)}u((r=r.apply(e,t||[])).next())})},i=this&&this.__generator||function(e,t){var n,r,i,o,a={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(i=2&o[0]?r.return:o[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,o[1])).done)return i;switch(r=0,i&&(o=[2&o[0],i.value]),o[0]){case 0:case 1:i=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!(i=(i=a.trys).length>0&&i[i.length-1])&&(6===o[0]||2===o[0])){a=0;continue}if(3===o[0]&&(!i||o[1]>i[0]&&o[1]<i[3])){a.label=o[1];break}if(6===o[0]&&a.label<i[1]){a.label=i[1],i=o;break}if(i&&a.label<i[2]){a.label=i[2],a.ops.push(o);break}i[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],r=0}finally{n=i=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}};t.__esModule=!0;var o=n(0),a=n(8),s=n(7),u=n(2),c=n(11),l=n(1),d=n(10),v=function(){return"performance"in window&&o.isFunction(performance.now)?performance.now():o.getCurrentTime()},p=function(){return v()+Math.random().toString().substr(1,5)},h="LL_DataServer",m=function(){function e(){this.supported=!1,this.contextID=null,this.dataServerID=h,this.providerName="",this.asyncReady=!1,this.localStorageSupported=!1,this.sessionStorageSupported=!1,this.resolveHandlers=[],this.eventWindows=[],this.dataServerURL=s.StorageUtils.getKeyValue("dataServerURL"),this.asyncLoadTime=0,this.asyncReadyTimer=0,this.asyncTimeout=5e3,this.timers={},this.handledEvents=[],this.listenersAdded=!1,this.handlers={},this.handleCommand=this.handleCommand.bind(this),this.onStorageChange=this.onStorageChange.bind(this),this.messageListener=this.messageListener.bind(this),this.handleEvent=this.handleEvent.bind(this),this.onAsyncReady=this.onAsyncReady.bind(this),this.contextID=d.Context.ID,this.init()}return e.prototype.ready=function(){var e=this;return new Promise(function(t){e.supported&&e.asyncReady?t():e.resolveHandlers.push(t)})},e.prototype.setItem=function(e,t,n){return r(this,void 0,void 0,function(){var r,a,s;return i(this,function(i){return o.isEmpty(e)||o.isEmpty(t)?[2]:(r=e+"_"+t,this.localStorageSupported?localStorage.setItem(r,n):((a=new Date).setDate(a.getDate()+1),s=encodeURIComponent(n)+"; expires = "+a.toUTCString(),document.cookie=r+" = "+s),[2])})})},e.prototype.setItemAsync=function(e,t,n){return r(this,void 0,void 0,function(){var r,o;return i(this,function(i){return r="setItem"+e+t+p(),o="setItem("+s.StorageUtils.prepareCommandArgs(e,t,n,r)+")",[2,this.asyncSendCommand(o,r)]})})},e.prototype.setItemsAsync=function(e,t){return r(this,void 0,void 0,function(){var n,r;return i(this,function(i){return n="setItems"+e+p(),r="setItems("+s.StorageUtils.prepareCommandArgs(e,t,n)+")",[2,this.asyncSendCommand(r,n)]})})},e.prototype.getItem=function(e,t){return r(this,void 0,void 0,function(){var n;return i(this,function(r){return o.isEmpty(e)||o.isEmpty(t)?[2,null]:(n=e+"_"+t,this.localStorageSupported?[2,localStorage.getItem(n)]:(document.cookie.split(";").forEach(function(e){var t=e.substr(0,e.indexOf("=")),r=e.substr(e.indexOf("=")+1);if((t=t.replace(/^\s+|\s+$/g,""))===n)return decodeURIComponent(r)}),[2,null]))})})},e.prototype.getItemAsync=function(e,t){return r(this,void 0,void 0,function(){var n,r;return i(this,function(i){return n="getItem"+e+t+p(),r="getItem("+s.StorageUtils.prepareCommandArgs(e,t,n)+")",[2,this.asyncSendCommand(r,n)]})})},e.prototype.getItemsAsync=function(e,t){var n=this;return new Promise(function(r,i){var a="getItems"+e+p(),u="getItems("+s.StorageUtils.prepareCommandArgs(e,t,a)+")";n.timers[a]=setTimeout(function(){try{n.handlers[a]=null,delete n.handlers[a],delete n.timers[a]}catch(e){}i(new Error(l.ERROR_TIMEOUT))},n.asyncTimeout),n.handlers[a]=function(e){try{clearTimeout(n.timers[a]),delete n.timers[a]}catch(e){}try{var t=o.isString(e)?JSON.parse(e):e;r(t)}catch(e){i(e)}},n.asyncSendCommand(u)})},e.prototype.removeItem=function(e,t){return r(this,void 0,void 0,function(){var n,r,a,s,u,c;return i(this,function(i){if(o.isEmpty(e)||o.isEmpty(t))return[2];if(n=e+"_"+t,this.localStorageSupported)localStorage.removeItem(n);else for(r=document.cookie.split(";"),a=0,s=r;a<s.length;a++)if(u=s[a],c=u.substr(0,u.indexOf("=")),u.substr(u.indexOf("=")+1),(c=c.replace(/^\s+|\s+$/g,""))===n){document.cookie=n+" = ;expires=Thu, 01 Jan 1970 00:00:01 GMT";break}return[2]})})},e.prototype.removeItemAsync=function(e,t){return r(this,void 0,void 0,function(){var n,r;return i(this,function(i){return n="removeItem"+e+t+p(),r="removeItem("+s.StorageUtils.prepareCommandArgs(e,t,n)+")",[2,this.asyncSendCommand(r,n)]})})},e.prototype.clear=function(e){return r(this,void 0,void 0,function(){var t,n;return i(this,function(r){if(o.isEmpty(e))return[2];if(this.localStorageSupported)for(t=localStorage.length-1;t>-1;t--)n=localStorage.key(t),o.isEmpty(n)||0!==n.indexOf(e)||localStorage.removeItem(n);else document.cookie.split(";").forEach(function(t){var n=t.substr(0,t.indexOf("="));t.substr(t.indexOf("=")+1);0===(n=n.replace(/^\s+|\s+$/g,"")).indexOf(e+"_")&&(document.cookie=n+" = ;expires=Thu, 01 Jan 1970 00:00:01 GMT")});return[2]})})},e.prototype.clearAsync=function(e){return r(this,void 0,void 0,function(){var t,n;return i(this,function(r){return t="clear"+e+p(),n="clear("+s.StorageUtils.prepareCommandArgs(e,t)+")",[2,this.asyncSendCommand(n,t)]})})},e.prototype.lockAllContexts=function(e,t,n){var r=this;return new Promise(function(i,a){if(o.isEmpty(e)||o.isEmpty(t))a({reason:l.ERROR_NO_ARGS});else{var u="lock"+e+t+p(),c="lock("+s.StorageUtils.prepareCommandArgs(e,t,n.toString(),u)+")";r.timers[u]=setTimeout(function(){try{r.handlers[u]=null,delete r.handlers[u],delete r.timers[u]}catch(e){}a({reason:l.ERROR_TIMEOUT})},Math.max(r.asyncTimeout,n)),r.handlers[u]=function(e){try{clearTimeout(r.timers[u]),delete r.timers[u]}catch(e){}try{var t=o.isString(e)?JSON.parse(e):e;t&&!0===t.success?i(t.validUntil):a({reason:l.ERROR_CONTEXT_LOCKED,validUntil:t.validUntil,errorCode:t.errorCode})}catch(e){a({reason:l.ERROR_OPERATION_FAILED,exception:e})}},r.asyncSendCommand(c)}})},e.prototype.unlockAllContexts=function(e,t){var n=this;return new Promise(function(r,i){if(o.isEmpty(e)||o.isEmpty(t))i({reason:l.ERROR_NO_ARGS});else{var a="removeLock"+e+t+p(),u="removeLock("+s.StorageUtils.prepareCommandArgs(e,t,a)+")";n.timers[a]=setTimeout(function(){try{n.handlers[a]=null,delete n.handlers[a],delete n.timers[a]}catch(e){}i({reason:l.ERROR_TIMEOUT})},n.asyncTimeout),n.handlers[a]=function(e){try{clearTimeout(n.timers[a]),delete n.timers[a]}catch(e){}try{var t=o.isString(e)?JSON.parse(e):e;r(t)}catch(e){i({reason:l.ERROR_OPERATION_FAILED,exception:e})}},n.asyncSendCommand(u)}})},e.prototype.dataServerReady=function(){return null!==document.getElementById(this.dataServerID)&&this.asyncReady},e.prototype.asyncSendCommand=function(e,t){var n=this;return new Promise(function(a,s){return r(n,void 0,void 0,function(){var n,r,u,c,d=this;return i(this,function(i){switch(i.label){case 0:return this.assertFrameLoaded(),o.isString(t)&&(n=setTimeout(function(){try{d.handlers[t]=null,delete d.handlers[t],delete d.timers[t]}catch(e){}s(new Error(l.ERROR_TIMEOUT))},this.asyncTimeout),this.timers[t]=n,this.handlers[t]=function(e){try{clearTimeout(d.timers[t]),delete d.timers[t]}catch(e){}try{o.isFunction(e.postMessage)&&(e=void 0)}catch(t){e=void 0}a(e)}),[4,this.ready()];case 1:if(i.sent(),o.isString(e)||e.command!==l.STORAGE_EVENT_CMD)window.frames[this.dataServerID].postMessage(e,"*");else for(r=e.eventObject.id,this.handledEvents.push(r),o.isString(t)&&(e.callbackID=t),u=0,c=this.eventWindows;u<c.length;u++)c[u].postMessage(e,"*");return o.isEmpty(t)&&a(void 0),[2]}})})})},e.prototype.isStorageSupported=function(){try{return"localStorage"in window&&(localStorage.setItem("LL_testItem","1"),localStorage.removeItem("LL_testItem"),!0)}catch(e){return!1}},e.prototype.isSessionStorageSupported=function(){try{return"sessionStorage"in window&&(sessionStorage.setItem("LL_testItem","1"),sessionStorage.removeItem("LL_testItem"),!0)}catch(e){return!1}},e.prototype.propagateEvent=function(e){var t=this.localStorageSupported?localStorage:this.sessionStorageSupported?sessionStorage:null;if(null!==t)if(!0!==e.invalidate){this.handledEvents.push(e.id);var n=l.STORAGE_EVENT_CMD+"."+e.id+"."+e.timestamp;t.setItem(n,JSON.stringify(e))}else s.invalidateGenericEvents(t,e);var r={command:l.STORAGE_EVENT_CMD,eventObject:e},i="event"+e.eventName+e.id;return this.asyncSendCommand(r,i)},e.prototype.onStorageChange=function(e){return r(this,void 0,void 0,function(){var t,n,r,a=this;return i(this,function(i){return n=(t=e).key,r=t.newValue,0!==(null==n?void 0:n.toLowerCase().indexOf(l.STORAGE_EVENT_CMD+"."))||o.isEmpty(r)||s.validateGenericEvent(this.handledEvents,function(e){return a.handleEvent({command:l.STORAGE_EVENT_CMD,eventObject:e},null)},t.newValue),[2]})})},e.prototype.waitForStorageEvent=function(e){return r(this,void 0,void 0,function(){var t,n,r,o,a,u=this;return i(this,function(i){for(t=[],n=0;n<e.length;n++)null!==(r=e.key(n))&&0===r.indexOf(l.STORAGE_EVENT_CMD+".")&&(o=e.getItem(r),s.validateGenericEvent(this.handledEvents,function(e){return u.handleEvent({command:l.STORAGE_EVENT_CMD,eventObject:e},null)},o,r,t));for(a=0;a<t.length;a++)e.removeItem(t[a]);return[2]})})},e.prototype.init=function(){var e=this;if(this.asyncReady=!1,this.localStorageSupported=this.isStorageSupported(),this.sessionStorageSupported=this.isSessionStorageSupported(),o.isString(this.dataServerURL)||(this.dataServerURL=s.StorageUtils.getKeyValue("dataServerURL")),this.supported=null!==this.dataServerURL&&void 0!==this.dataServerURL,!this.listenersAdded){this.listenersAdded=!0,this.handlers[l.STORAGE_READY_CMD]=this.onAsyncReady,window.addEventListener("message",this.messageListener,!1);var t=this.localStorageSupported?15e3:5e3;try{null!==window.opener&&void 0!==window.opener&&window.opener!==window&&this.eventWindows.push(window.opener)}catch(e){}var n=this.localStorageSupported?localStorage:this.sessionStorageSupported?sessionStorage:null;null!==n&&(window.addEventListener("storage",this.onStorageChange,!1),setTimeout(function(){return e.waitForStorageEvent(n)},500),setInterval(function(){return e.waitForStorageEvent(n)},t)),this.embedFrame()}},e.prototype.detectStorageType=function(){var e=navigator.userAgent;return"_"+(/trident\/\d.0/i.test(e)||/msie\s\d.0/i.test(e)||/Edge/i.test(e)?"ie":"html5")},e.prototype.embedFrame=function(){var e=this;if(null===document.getElementById(this.dataServerID)){o.isString(this.dataServerURL)||this.init();var t=document.createElement("iframe");if(t.setAttribute("id",this.dataServerID),t.setAttribute("name",this.dataServerID),t.setAttribute("src",this.dataServerURL+"ll_storage"+this.detectStorageType()+".html?context="+this.contextID+"&version="+s.StorageUtils.getKeyValue("version")),t.style.width="1px",t.style.height="1px",t.style.border="0px",t.setAttribute("title","Cobrowse communication frame"),t.setAttribute("scrolling","no"),t.setAttribute("allowTransparency","true"),t.setAttribute("aria-hidden","true"),o.setCss(t,{display:"block",border:"0 none",width:"1px",height:"1px",position:"absolute",top:"100%","margin-top":"-1px",left:"100%","margin-left":"-1px"}),this.asyncLoadTime=v(),this.asyncReady=!1,0===this.asyncReadyTimer&&(this.asyncReadyTimer=setInterval(function(){e.checkAsyncReady()&&0!==e.asyncReadyTimer&&(clearInterval(e.asyncReadyTimer),e.asyncReadyTimer=0)},1e3)),!o.isEmpty(document.body))try{document.body.appendChild(t)}catch(e){return void console.error(e)}}},e.prototype.messageListener=function(e){var t=e.source,n=e.data,r=e.origin;if(o.isString(this.dataServerURL)&&(!o.isString(r)||0===this.dataServerURL.toLowerCase().indexOf(r.toLowerCase())||window.opener===window||t===window.opener))if(o.isEmpty(n)||"object"!=typeof n){if(!o.isString(n))return;a.callAsync(this.handleCommand,n,t)}else{var i=n.command;i===l.STORAGE_RESPONSE_CMD?a.callAsync(this.handleCommand,n,t):i===l.STORAGE_EVENT_CMD&&a.callAsync(this.handleEvent,n,t)}},e.prototype.handleEvent=function(e,t){var n,r,i;if("object"==typeof e){var a=this.handledEvents;if(o.isEmpty(null===(n=e.eventObject)||void 0===n?void 0:n.id)||-1!==a.indexOf(e.eventObject.id))return;var s=c.WidgetEvent.parse(e);if(null===s||o.isEmpty(null===(r=s.eventData)||void 0===r?void 0:r.scope))return;if(!u.eventScopeMatches(s.eventData.scope))return;if(!o.isEmpty(t)){for(var l=!1,d=0;d<this.eventWindows.length;d++)if(this.eventWindows[d]===t){l=!0;break}l||this.eventWindows.push(t)}a.push(s.id),o.isEmpty(null===(i=s.eventData)||void 0===i?void 0:i.scope)||(s.eventData.scope.external=!0),s.dispatch(s.eventData,!1)}},e.prototype.executeCommand=function(e,t,n){if(o.isString(e)&&this.handlers[e]){t.push(n);try{var r=this.handlers[e];if(e!==l.STORAGE_READY_CMD&&-1===e.toLowerCase().indexOf("listener"))try{this.handlers[e]=null,delete this.handlers[e]}catch(e){}r.apply(this,t)}catch(e){}}},e.prototype.handleCommand=function(e,t){if(o.isEmpty(e)||"object"!=typeof e){if(o.isString(e))for(var n=0,r=e.split(";");n<r.length;n++){var i=r[n],a=(u=void 0,c=[],i.indexOf("("));-1!==a?(u=i.substring(0,a),c[0]=s.StorageUtils.restoreArg(i.substring(a+1,i.length-1))):u=i,o.isEmpty(u)||this.executeCommand(u,c,t)}}else{var u=e.id,c=e.args instanceof Array?e.args:[];this.executeCommand(u,c,t)}},e.prototype.onAsyncReady=function(e,t){if(this.asyncReady=!0,o.isString(e)&&(this.providerName=e),!o.isEmpty(t)){for(var n=!0,r=0,i=this.eventWindows;r<i.length;r++){if(i[r]===t){n=!1;break}}n&&this.eventWindows.push(t)}this.resolveHandlers.forEach(function(e){try{e()}catch(e){}}),this.resolveHandlers=[]},e.prototype.checkAsyncReady=function(){var e;if(this.asyncReady)return!0;if(this.embedFrame(),v()-this.asyncLoadTime>4e3){var t=o.getElementAs(this.dataServerID);null===(e=null==t?void 0:t.parentNode)||void 0===e||e.removeChild(t),t=null,this.embedFrame()}return this.asyncReady},e.prototype.assertFrameLoaded=function(){null===document.getElementById(this.dataServerID)&&this.asyncReady&&(this.asyncReady=!1,this.init())},e}();t.StorageManager=function(){var e=u.getStorageInstance();if(null!==e)return e;var t=window.MCServiceAPI,n=window.Cobrowse,r=window.LL_Deployment,i=new m;return void 0!==n&&void 0===n.StorageManager?(window.Cobrowse.StorageManager=i,window.LL_Storage_Manager=i,window.LL_Storage_Manager.asyncSupported=i.supported):void 0!==r&&(window.LL_Storage_Manager=i,window.LL_Storage_Manager.asyncSupported=i.supported),void 0!==t&&void 0===t.StorageManager&&(window.MCServiceAPI.StorageManager=i),i}(),t.StorageManager.emitDOMEvent=c.WidgetEvent.fire,t.StorageManager.prepareCommandArgs=s.StorageUtils.prepareCommandArgs}]);


    var Utils = function () {
        "use sctrict";

        return {
            $: function (id) {
                return document.getElementById(id);
            },
            listen: function (evnt, elem, func) {
                if (typeof elem === "string") {
                    var els = elem.split(',');
                    els.forEach(function (eld) {
                        var el = document.getElementById(eld.trim());
                        if (el)
                            Utils.listen(evnt, el, func);
                    });
                    return;
                }
                else {
                    try { //QA 170907-000124
                        if (elem.addEventListener)  // W3C DOMdis
                            elem.addEventListener(evnt, func, false);
                        else if (elem.attachEvent) { // IE DOM
                            elem.attachEvent("on" + evnt, func);
                        }
                        else { // Not much to do
                            elem[evnt] = func;
                        }
                    }
                    catch (ex) { }
                }
            },
            hasClass: function (el, className) {
                if (!el) {
                    return;
                }
                if (el.classList)
                    return el.classList.contains(className)
                else
                    return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
            },
            addClass: function (el, className) {
                if (!el) {
                    return;
                }
                if (el.constructor === Array) {
                    el.forEach(function (element) {
                        Utils.addClass(element, className);
                    });
                }
                else {
                    if (typeof (el) === "string") {
                        el = Utils.$(el);
                        if (!el)
                            return;
                    }
                    var classArray = className.constructor === Array ? className : className.split(" ");
                    if (el.classList && !("ActiveXObject" in window)) {
                        el.classList.add.apply(el.classList, classArray)
                    }

                    else
                        classArray.forEach(function (className) {
                            if (className && !Utils.hasClass(el, className))
                                el.className += " " + className;
                        });
                }
            },

            /**
            * Removes the specified class from the element
            * <params>
            *      el: DOM element, the element to remove the class from
            *      className: string, the class to remove from the given element
            * </params>
            */
            removeClass: function (el, className) {
                if (!el) {
                    return;
                }
                if (el.constructor === Array) {
                    el.forEach(function (element) {
                        Utils.removeClass(element, className);
                    });
                }
                else {
                    if (typeof (el) === "string") {
                        el = Utils.$(el);
                        if (!el)
                            return;
                    }
                    var classArray = className.constructor === Array ? className : className.split(" ");

                    if (el.classList && !("ActiveXObject" in window))
                        el.classList.remove.apply(el.classList, classArray)
                    else {
                        classArray.forEach(function (className) {
                            if (className && hasClass(el, className)) {
                                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                                el.className = el.className.replace(reg, ' ');
                            }
                        });
                    }
                }
            },

            /**
            * Applies CSS properties to the given element
            * <params>
            *      elem: DOM element, the element to apply the styles to
            *      properties: object, properties in key : value form
            * </params>
            */
            css: function (elem, properties) {
                if (elem) {
                    Object.keys(properties).forEach(function (key) {
                        var cssKey = key;
                        while (cssKey.indexOf('-') !== -1) {
                            var z = cssKey.indexOf('-');
                            cssKey = cssKey.substr(0, z) + cssKey[z + 1].toUpperCase() + cssKey.substr(z + 2);
                        }
                        elem.style[cssKey] = properties[key];
                    });
                }
            },

            getTimeString: function () {
                var today = new Date(),
                    hours = today.getHours();
                if (hours < 10)
                    hours = "0" + hours;
                var mins = today.getMinutes();
                if (mins < 10)
                    mins = "0" + mins;
                var secs = today.getSeconds();
                if (secs < 10)
                    secs = "0" + secs;
                var ms = today.getMilliseconds().toString();
                while (ms.length < 3)
                    ms = "0" + ms;

                return "" + hours + ":" + mins + ":" + secs + "." + ms;
            },

            DetectBrowser: function () {
                var ua = navigator.userAgent.toLowerCase();
                var Browser = {};
                Browser.OS = "";
                Browser.OSVersion = "";
                Browser.BrowserName = "";
                Browser.BrowserVersion = "";
                Browser.NetVersion = "";
                Browser.WebSocket = false;
                Browser.PostMessage = false;
                Browser.LocalStorage = false;

                //OS detection
                if (/windows/i.test(ua)) {
                    Browser.OS = "Windows";
                } else if (/mac os x/i.test(ua)) {
                    Browser.OS = "Mac OS X";
                } else if (/mac/i.test(ua)) {
                    Browser.OS = "Mac OS";
                } else if (/linux/i.test(ua)) {
                    Browser.OS = "Linux";
                }
                //System version
                if (Browser.OS == "Windows") {
                    if (/windows nt.+\sarm\;/i.test(ua)) {
                        Browser.OSVersion = "RT";
                    }
                    else if (/windows nt[\/\s](\d+\.\d+)/i.test(ua)) {
                        if (RegExp.$1 == "6.0") {
                            Browser.OSVersion = "Vista";
                        }
                        else if (RegExp.$1 == "6.1") {
                            Browser.OSVersion = "7";
                        }
                        else if (RegExp.$1 == "6.2") {
                            Browser.OSVersion = "8";
                        }
                        else if (RegExp.$1 == "6.3") {
                            Browser.OSVersion = "8.1";
                        }
                        else if (RegExp.$1 == "6.4" || RegExp.$1 == "10.0") {
                            Browser.OSVersion = "10";
                        }
                    }
                }
                else if (Browser.OS == "Mac OS X") {
                    if (/mac os x[\/\s](\d+_\d+_\d+)/i.test(ua) || /mac os x[\/\s](\d+_\d+)/i.test(ua))
                        Browser.OSVersion = ("" + RegExp.$1).replace(/_/g, ".");
                    else if (/mac os x[\/\s](\d+\.\d+\.\d+)/i.test(ua) || /mac os x[\/\s](\d+\.\d+)/i.test(ua))
                        Browser.OSVersion = RegExp.$1;
                    else if (/cpu os[\/\s](\d+_\d+)/i.test(ua)) {
                        Browser.OS = "IOS";
                        Browser.OSVersion = ("" + RegExp.$1).replace(/_/g, ".");
                    }
                    else if (/cpu iphone os[\/\s](\d+_\d+)/i.test(ua)) {
                        Browser.OS = "IOS";
                        Browser.OSVersion = ("" + RegExp.$1).replace(/_/g, ".");
                    }
                    var arr = Browser.OSVersion.split('.');
                    if (arr.length > 1)
                        Browser.OSVersion = arr[0] + "." + arr[1];
                }
                //Browser detection
                if (/firefox[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Firefox";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/msie[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "MSIE";
                    var actualIEVersion = 11.0;
                    Browser.BrowserVersion = actualIEVersion.toFixed(1);
                } else if (/trident\/7.0/i.test(ua)) {
                    Browser.BrowserName = "MSIE";
                    Browser.BrowserVersion = "11.0";
                } else if (/edge\/(\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "MS Edge";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/opera/i.test(ua) && /version[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Opera";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/chrome/i.test(ua) && /opr[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Opera";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/chrome[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Chrome";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/crios[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Chrome";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/safari[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Safari";
                    Browser.BrowserVersion = "" + RegExp.$1;
                    if (/version[\/\s](\d+\.\d+)/i.test(ua)) {
                        Browser.BrowserVersion = "" + RegExp.$1;
                    }
                } else {
                    if (Browser.OS == "Mac OS" || Browser.OS == "Mac OS X" || Browser.OS == "IOS") {
                        //assume safari
                        if (/version[\/\s](\d+\.\d+)/i.test(ua)) {
                            Browser.BrowserName = "Safari";
                            Browser.BrowserVersion = "" + RegExp.$1;
                        }
                    }
                }
                //.NET detection
                if (Browser.OS == "Windows" && Browser.OSVersion != "RT") {
                    var match = ua.match(/\.net(\d+\.\d+)|\.net\sclr\s(\d+\.\d+)/g);
                    if (match) {
                        for (var i = 0; i < match.length; i++) {
                            match[i] = match[i].replace(/\.net\sclr\s/, "").replace(/\.net/, "");
                        }
                        match.sort();
                        Browser.NetVersion = match[match.length - 1];
                    }
                }
                //WebSocket, PostMessage, LocalStorage
                Browser.WebSocket = ("WebSocket" in window);
                Browser.PostMessage = ("postMessage" in window);
                Browser.LocalStorage = ("localStorage" in window);

                return Browser;
            },

            mapLangToLCID: function (lang) {
                var mapping = MCServiceAPI.configuration.languageMapping;
                if (lang && lang.toString().length < 256) {
                    lang = lang.toString().toLowerCase().trim();
                    for (var key in mapping) {
                        if (!mapping.hasOwnProperty(key))
                            continue;
                        else if (key === lang) 
                            return key;
                        for (var i = 0; i< mapping[key].length; i++) {
                            var id = mapping[key][i].toString();
                            if (id === lang)
                                return key;
                        }
                    }
                    if (lang.indexOf("-") !== -1) {
                        var truncatedLang = lang.substr(0, lang.lastIndexOf("-"));
                        return Utils.mapLangToLCID(truncatedLang); //RFC 4647 section 3.4
                    }
                }
                return MCServiceAPI.configuration.defaultLanguage;
            }
        }
    }();

    MCServiceAPI.init(true);

