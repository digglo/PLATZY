
//<script type="text/javascript">

"Promise"in window||function(){"use strict";function t(t){return"function"==typeof t||"object"==typeof t&&null!==t}function n(t){return"function"==typeof t}function e(t){return"object"==typeof t&&null!==t}function r(t){U=t}function o(t){G=t}function i(){return function(){process.nextTick(f)}}function u(){return function(){N(f)}}function s(){var t=0,n=new Q(f),e=document.createTextNode("");return n.observe(e,{characterData:!0}),function(){e.data=t=++t%2}}function c(){var t=new MessageChannel;return t.port1.onmessage=f,function(){t.port2.postMessage(0)}}function a(){return function(){setTimeout(f,1)}}function f(){for(var t=0;B>t;t+=2){var n=X[t],e=X[t+1];n(e),X[t]=void 0,X[t+1]=void 0}B=0}function l(){try{var t=require,n=t("vertx");return N=n.runOnLoop||n.runOnContext,u()}catch(e){return a()}}function p(){}function _(){return new TypeError("You cannot resolve a promise with itself")}function h(){return new TypeError("A promises callback cannot return that same promise.")}function v(t){try{return t.then}catch(n){return nt.error=n,nt}}function d(t,n,e,r){try{t.call(n,e,r)}catch(o){return o}}function y(t,n,e){G(function(t){var r=!1,o=d(e,n,function(e){r||(r=!0,n!==e?w(t,e):A(t,e))},function(n){r||(r=!0,E(t,n))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,E(t,o))},t)}function m(t,n){n._state===$?A(t,n._result):n._state===tt?E(t,n._result):j(n,void 0,function(n){w(t,n)},function(n){E(t,n)})}function b(t,e){if(e.constructor===t.constructor)m(t,e);else{var r=v(e);r===nt?E(t,nt.error):void 0===r?A(t,e):n(r)?y(t,e,r):A(t,e)}}function w(n,e){n===e?E(n,_()):t(e)?b(n,e):A(n,e)}function g(t){t._onerror&&t._onerror(t._result),S(t)}function A(t,n){t._state===Z&&(t._result=n,t._state=$,0!==t._subscribers.length&&G(S,t))}function E(t,n){t._state===Z&&(t._state=tt,t._result=n,G(g,t))}function j(t,n,e,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=n,o[i+$]=e,o[i+tt]=r,0===i&&t._state&&G(S,t)}function S(t){var n=t._subscribers,e=t._state;if(0!==n.length){for(var r,o,i=t._result,u=0;u<n.length;u+=3)r=n[u],o=n[u+e],r?x(e,r,o,i):o(i);t._subscribers.length=0}}function P(){this.error=null}function T(t,n){try{return t(n)}catch(e){return et.error=e,et}}function x(t,e,r,o){var i,u,s,c,a=n(r);if(a){if(i=T(r,o),i===et?(c=!0,u=i.error,i=null):s=!0,e===i)return void E(e,h())}else i=o,s=!0;e._state!==Z||(a&&s?w(e,i):c?E(e,u):t===$?A(e,i):t===tt&&E(e,i))}function C(t,n){try{n(function(n){w(t,n)},function(n){E(t,n)})}catch(e){E(t,e)}}function M(t,n){var e=this;e._instanceConstructor=t,e.promise=new t(p),e._validateInput(n)?(e._input=n,e.length=n.length,e._remaining=n.length,e._init(),0===e.length?A(e.promise,e._result):(e.length=e.length||0,e._enumerate(),0===e._remaining&&A(e.promise,e._result))):E(e.promise,e._validationError())}function O(t){return new rt(this,t).promise}function k(t){function n(t){w(o,t)}function e(t){E(o,t)}var r=this,o=new r(p);if(!z(t))return E(o,new TypeError("You must pass an array to race.")),o;for(var i=t.length,u=0;o._state===Z&&i>u;u++)j(r.resolve(t[u]),void 0,n,e);return o}function Y(t){var n=this;if(t&&"object"==typeof t&&t.constructor===n)return t;var e=new n(p);return w(e,t),e}function q(t){var n=this,e=new n(p);return E(e,t),e}function F(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function I(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function D(t){this._id=ct++,this._state=void 0,this._result=void 0,this._subscribers=[],p!==t&&(n(t)||F(),this instanceof D||I(),C(this,t))}function K(){var t;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(n){throw new Error("polyfill failed because global object is unavailable in this environment")}var e=t.Promise;e&&"[object Promise]"===Object.prototype.toString.call(e.resolve())&&!e.cast||(t.Promise=at)}var L;L=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var N,U,W,z=L,B=0,G=({}.toString,function(t,n){X[B]=t,X[B+1]=n,B+=2,2===B&&(U?U(f):W())}),H="undefined"!=typeof window?window:void 0,J=H||{},Q=J.MutationObserver||J.WebKitMutationObserver,R="undefined"!=typeof process&&"[object process]"==={}.toString.call(process),V="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,X=new Array(1e3);W=R?i():Q?s():V?c():void 0===H&&"function"==typeof require?l():a();var Z=void 0,$=1,tt=2,nt=new P,et=new P;M.prototype._validateInput=function(t){return z(t)},M.prototype._validationError=function(){return new Error("Array Methods must be provided an Array")},M.prototype._init=function(){this._result=new Array(this.length)};var rt=M;M.prototype._enumerate=function(){for(var t=this,n=t.length,e=t.promise,r=t._input,o=0;e._state===Z&&n>o;o++)t._eachEntry(r[o],o)},M.prototype._eachEntry=function(t,n){var r=this,o=r._instanceConstructor;e(t)?t.constructor===o&&t._state!==Z?(t._onerror=null,r._settledAt(t._state,n,t._result)):r._willSettleAt(o.resolve(t),n):(r._remaining--,r._result[n]=t)},M.prototype._settledAt=function(t,n,e){var r=this,o=r.promise;o._state===Z&&(r._remaining--,t===tt?E(o,e):r._result[n]=e),0===r._remaining&&A(o,r._result)},M.prototype._willSettleAt=function(t,n){var e=this;j(t,void 0,function(t){e._settledAt($,n,t)},function(t){e._settledAt(tt,n,t)})};var ot=O,it=k,ut=Y,st=q,ct=0,at=D;D.all=ot,D.race=it,D.resolve=ut,D.reject=st,D._setScheduler=r,D._setAsap=o,D._asap=G,D.prototype={constructor:D,then:function(t,n){var e=this,r=e._state;if(r===$&&!t||r===tt&&!n)return this;var o=new this.constructor(p),i=e._result;if(r){var u=arguments[r-1];G(function(){x(r,o,u,i)})}else j(e,o,t,n);return o},"catch":function(t){return this.then(null,t)}};var ft=K,lt={Promise:at,polyfill:ft};"function"==typeof define&&define.amd?define(function(){return lt}):"undefined"!=typeof module&&module.exports?module.exports=lt:"undefined"!=typeof this&&(this.ES6Promise=lt),ft()}.call(this);

    MCServiceAPI = window.MCServiceAPI || {};
    MCServiceAPI.channelStates = {
        CONNECTING: "CONNECTING",
        ACTIVE: "ACTIVE",
        TIMEOUT: "TIMEOUT",
        NO_SESSION: "NO_SESSION",
        DISCONNECTED: "DISCONNECTED",
        UNKNOWN: "UNKNOWN"
    };
    MCServiceAPI.DisconnectReason = {
        visitorAction: 'host_action',
        agentAction: 'agent_action',
        visitorNetworkTimeout: 'host_network',
        agentNetworkTimeout: 'join_network'
    };
    MCServiceAPI.configuration = {
        version: "20220325",
        codebase: "RELY",
        defaultLanguage: "1033",
        languageMapping: {"1026":[2,"bg","bg-bg","bgr","bul"],"1028":[30724,3076,31748,4,4100,5124,"chs","cht","zh","zh-chs","zh-cht","zhh","zh-hans","zh-hant","zh-hk","zhi","zhm","zh-mo","zho","zh-sg","zh-tw"],"1029":[5,"ces","cs","cs-cz","csy"],"1030":[6,"da","da-dk","dan"],"1031":[2055,3079,4103,5127,7,"de","dea","de-at","dec","de-ch","de-de","del","de-li","de-lu","des","deu"],"1032":[8,"el","el-gr","ell"],"1033":[10249,11273,12297,13321,14345,15369,16393,17417,18441,3081,4105,5129,6153,7177,8201,9,9225,"en","en-029","ena","en-au","enb","en-bz","enc","en-ca","ene","eng","enh","en-hk","eni","en-id","en-ie","en-in","enj","en-jm","enl","enm","en-my","enn","en-nz","enp","en-ph","ens","en-sg","ent","en-tt","enu","en-us","enw","enz","en-za","en-zw","zzz"],"1035":[11,"fi","fi-fi","fin"],"1036":[10252,11276,12,12300,13324,14348,15372,2060,4108,5132,6156,7180,8204,9228,"fr","fr-029","fra","frb","fr-be","fr-cd","fr-ch","fr-ci","fr-cm","frd","fre","frf","fr-fr","frh","fr-ht","fri","frl","fr-lu","frm","fr-ma","fr-mc","fr-ml","frn","fro","frr","fr-re","frs","fr-sn","zzz"],"1038":[14,"hu","hu-hu","hun"],"1040":[16,2064,"it","ita","it-ch","it-it","its"],"1041":[17,"ja","ja-jp","jpn"],"1042":[18,"ko","ko-kr","kor"],"1043":[19,2067,"nl","nlb","nl-be","nld","nl-nl"],"1044":[20,2068,31764,"nb","nb-no","nn","nn-no","nno","no","nob","non","nor"],"1045":[21,"pl","plk","pl-pl","pol"],"1046":[22,"por","pt","ptb","pt-br"],"1048":[2072,24,"ro","rod","rom","ro-md","ron","ro-ro"],"1049":[2073,25,"ru","rum","ru-md","ru-ru","rus"],"1050":[26,4122,"hr","hrb","hr-ba","hr-hr","hrv"],"1051":[27,"sk","sk-sk","sky","slk"],"1053":[2077,29,"sv","sve","svf","sv-fi","sv-se","swe"],"1054":[30,"th","tha","th-th"],"1055":[31,"tr","trk","tr-tr","tur"],"1058":[34,"uk","ukr","uk-ua"],"1060":[36,"sl","sl-si","slv"],"1061":[37,"est","et","et-ee","eti"],"1062":[38,"lav","lv","lvi","lv-lv"],"1063":[39,"lit","lt","lth","lt-lt"],"2052":[30724,3076,31748,4,4100,5124,"chs","cht","zh","zh-chs","zh-cht","zh-cn","zhh","zh-hans","zh-hant","zh-hk","zhi","zhm","zh-mo","zho","zh-sg"],"2057":[10249,11273,12297,13321,14345,15369,16393,17417,18441,3081,4105,5129,6153,7177,8201,9,9225,"en","en-029","ena","en-au","enb","en-bz","enc","en-ca","ene","eng","en-gb","enh","en-hk","eni","en-id","en-ie","en-in","enj","en-jm","enl","enm","en-my","enn","en-nz","enp","en-ph","ens","en-sg","ent","en-tt","enu","enw","enz","en-za","en-zw","zzz"],"2070":[22,"por","pt","ptb","ptg","pt-pt"],"2074":[10266,11290,12314,28698,31770,6170,7194,9242,"sr","srb","sr-cyrl-ba","sr-cyrl-me","sr-cyrl-rs","srl","sr-latn","sr-latn-ba","sr-latn-cs","sr-latn-me","sr-latn-rs","srm","srn","sro","srp","srq","srs"],"3082":[10,10250,11274,12298,13322,14346,15370,16394,17418,18442,19466,20490,2058,21514,22538,23562,4106,5130,6154,7178,8202,9226,"es","es-419","esa","es-ar","esb","es-bo","esc","es-cl","es-co","es-cr","es-cu","esd","es-do","ese","es-ec","es-es","esf","esg","es-gt","esh","es-hn","esi","esj","esk","esl","esm","es-mx","esn","es-ni","eso","esp","es-pa","es-pe","es-pr","es-py","esr","ess","es-sv","est","esu","es-us","es-uy","esv","es-ve","esy","esz","spa"],"3084":[10252,11276,12,12300,13324,14348,15372,2060,4108,5132,6156,7180,8204,9228,"fr","fr-029","fra","frb","fr-be","frc","fr-ca","fr-cd","fr-ch","fr-ci","fr-cm","frd","fre","frf","frh","fr-ht","fri","frl","fr-lu","frm","fr-ma","fr-mc","fr-ml","frn","fro","frr","fr-re","frs","fr-sn","zzz"]},
        cloudContainer: "https://public.cobrowse.oraclecloud.com",
        dataServerPath: "https://public.cobrowse.oraclecloud.com/edge",
        mainServer: "https://www.livelook.com",
        auth: {
            start: "https://videowlphx01.livelook.com/mcservice/api/v2.0/session"
        },
        video: {
            ringer: 'https://public.cobrowse.oraclecloud.com/rely/mcservice/resources/audio/blackberry.mp3',
            dialer: 'https://public.cobrowse.oraclecloud.com/rely/mcservice/resources/audio/dial.mp3',
            wscAppUri: "/ws/webrtc/cloud",
            authType: "cloud"
        },
        cobrowse: {
            container: 'https://{siteid}.cobrowse.oraclecloud.com',
            forceWidgetPresence: true
        }
    };


    MCServiceAPI.Agent = MCServiceAPI.Agent || {};


    MCServiceAPI.Events = MCServiceAPI.Events || {};

    (function () {
            "use sctrict";
            var _isHost = false;
            function eventTemplate(name) {
                return {
                    wait: function (callback) {
                        var listeners = this.___internals.listeners;
                        if (listeners.indexOf(callback) === -1) {
                            listeners.push(callback);
                            try {
                                callback.once = true;
                            }
                            catch (e) { }
                        }
                    },
                    listen: function (callback) {
                        var listeners = this.___internals.listeners;
                        if (listeners.indexOf(callback) === -1)
                            listeners.push(callback);
                    },
                    removeListener: function (callback) {
                        var listeners = this.___internals.listeners;
                        for (var i = listeners.length - 1; i >= 0; i--) {
                            if (listeners[i] === callback) {
                                listeners.splice(i, 1);
                            }
                        }
                    },
                    ___internals: {
                        eventName: name,
                        listeners: []
                    }
                }
            }

            var _delay = function (interval) {
                return new Promise(function (resolve) {
                    setTimeout(resolve, interval);
                });
            };

            var _retry = function (fn, fnErrValidator, maxTime, timeout) {
                return fn().catch(function (err) {

                    if (fnErrValidator(err, maxTime)) {
                        return _delay(timeout).then(function () {
                            return _retry(fn, fnErrValidator, maxTime, timeout);
                        })
                    }

                    throw err;
                })
            };

            var _fireEvent = function (evt, params) {
                params.type = evt && evt.___internals ? evt.___internals.eventName : undefined;
                if (evt && evt.___internals && evt.___internals.listeners) {
                    evt.___internals.listeners.forEach(function (listener) {
                        (function (listener, params) {
                            setTimeout(function () {
                                if (listener) {
                                    if (listener.once)
                                        evt.removeListener(listener);
                                    listener.call(this, params);
                                }
                            }, 0);
                        })(listener, params);
                    })
                }
            }

            var _renderJSAndStyles = function (channels, sessionID) {
                var resources = [],
                    session = MCServiceAPI.Sessions[sessionID],
                    siteCode = session ? session.siteCode : null;

                if (true && sessionID === undefined) {
                    var asyncLog = MCServiceAPI.debug.logAsync("Creating list of required resources:");
                }
                else {
                    var asyncLog = MCServiceAPI.debug.logAsync("Creating list of channel resources for " + sessionID + ":");
                }

                Object.keys(channels).forEach(function (channelName) {
                    var channel = MCServiceAPI.Channels[channelName];
                    if (!channel) {
                        asyncLog.reject("Unrecognized channel name: " + channelName);
                        throw "Unrecognized channel name: " + channelName;
                    }
                    if (session && !session.channels[channelName])
                        return;
                    if (channel.supported) {
                        if (channel.resources)
                            resources = resources.concat(channel.resources);
                    }
                });

                asyncLog.resolve(resources.join(", "));
                asyncLog = MCServiceAPI.debug.logAsync("Loading resources...");

                _loadAllResources(resources).then(function () {
                    var connectedPromises = [],
                        disconnectedPromises = [];

                    Object.keys(channels).forEach(function (channelName) {
                        var channel = MCServiceAPI.Channels[channelName];
                        if (!channel) {
                            asyncLog.reject("Unrecognized channel name: " + channelName);
                            throw "Unrecognized channel name: " + channelName;
                        }
                        if (session && !session.channels[channelName]) {
                            //TODO: log?
                            return;
                        }
                        if (channel.supported) {
                            _injectView(channelName, channels[channelName], sessionID);

                            if (session !== undefined) {
                                (function (channel, channelName, sessionID) {
                                    var channelConnectPromise = new Promise(function (resolve, reject) {
                                        var done = false,
                                            connected_listener = function (evt) {
                                                if (!done) {
                                                    if (evt.sessionID === sessionID) {
                                                        //this is what we are waiting for
                                                        done = true;
                                                        resolve();
                                                    } else {
                                                        //connected for another session fired - ignore and listen more
                                                        channel.Events.Connected.wait(connected_listener);
                                                    }
                                                }
                                            },
                                            disconnected_listener = function (evt) {
                                                if (!done) {
                                                    if (evt.sessionID === sessionID) {
                                                        //DISCONNECTED for this session fired before CONNECTED - reject the promise
                                                        if (evt.type === "Error") {
                                                            MCServiceAPI.debug.error("Channel " + channelName + " reported error: " + evt.code);
                                                        }
                                                        done = true;
                                                        //reject({ channel: channelName, code: evt.code ? evt.code : "ERR_DISCONNECTED", nestedEvent: evt });
                                                    } else {
                                                        //connected for another session fired - ignore and listen more
                                                        channel.Events[evt.type].wait(disconnected_listener);
                                                    }
                                                }
                                            };
                                        channel.Events.Connected.wait(connected_listener);
                                        channel.Events.Disconnected.wait(disconnected_listener);
                                        channel.Events.Error.wait(disconnected_listener);
                                    });

                                    var channelDisconnectPromise = new Promise(function (resolve, reject) {
                                        var disconnected_listener = function (evt) {
                                            if (evt.sessionID === sessionID) {
                                                if (evt.reason || evt.code) {
                                                    MCServiceAPI.Sessions[sessionID].disconnectReason = evt.reason || evt.code;
                                                }
                                                resolve();
                                            }
                                            else {
                                                channel.Events[evt.type].wait(disconnected_listener);
                                            }
                                        };
                                        channel.Events.Disconnected.wait(disconnected_listener);
                                        channel.Events.Error.wait(disconnected_listener);
                                    });

                                    connectedPromises.push(channelConnectPromise);
                                    disconnectedPromises.push(channelDisconnectPromise);

                                })(channel, channelName, sessionID);
                            }
                        }
                    });

                    asyncLog.resolve();

                    if (sessionID !== undefined) {
                        (function (connectedPromises, disconnectedPromises, sessionID) {
                            Promise.all(connectedPromises).then(function () {
                                MCServiceAPI.debug.info("Fired MCServiceAPI.Connected for " + sessionID);
                                _fireEvent(MCServiceAPI.Events.Connected, {
                                    sessionID: sessionID,
                                    agent: true 
                            });
                            }).catch(function (err) {
                                var session = MCServiceAPI.Sessions[sessionID],
                                    isDisconnected = session ? session.terminating === true : true;
                                if (!isDisconnected) {
                                    session.terminating = true;
                                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnected for " + sessionID);
                                    _fireEvent(MCServiceAPI.Events.Disconnected, {
                                        sessionID: sessionID,
                                        siteCode: siteCode,
                                        reason: _processDisconnectReason(session.disconnectReason),
                                        agent: true 
                                });
                                }
                            })
                            Promise.all(disconnectedPromises).then(function () {
                                var session = MCServiceAPI.Sessions[sessionID],
                                    isDisconnected = session ? session.terminating === true : true;
                                if (!isDisconnected) {
                                    session.terminating = true;
                                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnected for " + sessionID);
                                    _fireEvent(MCServiceAPI.Events.Disconnected, {
                                        sessionID: sessionID,
                                        siteCode: siteCode,
                                        reason: session.disconnectReason,
                                        agent: true 
                                });
                                }
                            });
                        })(connectedPromises, disconnectedPromises, sessionID);
                    }
            });
        }

        var _injectView = function (channelName, params, sessionID) {
            var view = MCServiceAPI.Channels[channelName].view;
            _renderView(view, channelName, params, sessionID);
        }

        var _processDisconnectReason = function(reason) {
            if (!reason) 
                return reason;

            if (reason == MCServiceAPI.DisconnectReason.agentAction || 
                reason == MCServiceAPI.DisconnectReason.visitorAction)
                return reason;
            
            if (reason == 'TimeoutNoOK') 
                return  MCServiceAPI.DisconnectReason.visitorNetworkTimeout;

        }
        var _loadAllResources = function (resources) {
            return resources.reduce(function (prev, current) {
                return prev.then(function () {
                    return _appendResource(current);
                });

            }, Promise.resolve());
        }

        var _preloadResources = function (resources) {
            if (!document || !document.head)
                return;

            resources.forEach(function (resource) {
                if (!_resourceAlreadyLoaded(resource, false)) {
                    var preloadLink = document.createElement("link");
                    preloadLink.href = resource;
                    preloadLink.rel = "preload";
                    preloadLink.as = resource.indexOf(".js") !== -1 ? "script" : "style";
                    document.head.appendChild(preloadLink);
                };
            });
        }

        var _resourceAlreadyLoaded = function (url, excludePreloadTags) {
            var wildcards = ['[href="' + url + '"]', '[src="' + url + '"]'],
                alreadyLoaded = false;

            wildcards.forEach(function (elmnt) {
                if (!alreadyLoaded) {
                    var tags = document.querySelectorAll(elmnt);
                    if (tags.length > 0) {
                        if (excludePreloadTags) {
                            for (var i = 0; i < tags.length; i++) {
                                var relAttribute = tags[i].rel;
                                if (typeof relAttribute === "string" && relAttribute.toLowerCase() === "preload")
                                    continue;
                                else {
                                    alreadyLoaded = true;
                                    break;
                                }
                            }
                        }
                        else 
                            alreadyLoaded = true;
                    }
                }
            });

            return alreadyLoaded;
        }

        var _appendResource = function (url) {

            // Do not append the same resource twice
            if (_resourceAlreadyLoaded(url, true))
                return;

            return new Promise(function (resolve, reject) {
                var body = document.getElementsByTagName("body")[0],
                    head = document.getElementsByTagName("head")[0],
                    type = url.indexOf(".js") !== -1 ? "script" : "link",
                    resource = document.createElement(type);

                resource.type = type === "script" ? "text/javascript" : "text/css";

                if (resource.readyState) { //IE
                    resource.onreadystatechange = function () {
                        if (resource.readyState === "loaded" || resource.readyState === "complete") {
                            resource.onreadystatechange = null;
                            resolve();
                        }
                    };
                } else { //Others
                    resource.onload = function () {
                        resolve();
                    };
                }

                if (type === "script") {
                    resource.src = url;
                    head.appendChild(resource);
                } else {
                    resource.href = url;
                    resource.rel = "stylesheet";
                    head.appendChild(resource);
                }
            });
        }

        var _removeAlreadyAppendedScripts = function (url) {
            if (document.querySelectorAll('[src="' + url + '"]').length > 0) {
                var script = document.querySelectorAll('[src="' + url + '"]')[0];
                script.parentNode.removeChild(script);
            }
        }

        var _renderView = function (view, channelName, params, sessionID) {
            var channelViewAsync = MCServiceAPI.debug.logAsync("Loading view for channel " + channelName);
            var container = params.container,
                cntElement = typeof container === "string" ? document.querySelector(container) : container;

            if (cntElement) {
                view = _setLanguageTextStrings(view);
                cntElement.innerHTML = unescape(view);
            }

            var channel = MCServiceAPI.Channels[channelName];
            if (channel && channel.Events["Load"]) {
                console.log(Utils.getTimeString() + ": firing onload for: " + channelName + " as " + (params.agent ? "agent" : "visitor"));
                _fireEvent(channel.Events.Load, {
                    context: channel,
                    sessionID: sessionID,
                    params: params,
                    session: MCServiceAPI.Sessions[sessionID],
                    agent: params.agent
                });
            }
            channelViewAsync.resolve();
        }

        var _setLanguageTextStrings = function(view) {
            var textsMap = MCServiceAPI.Channels["webrtc_video"].UI.textMappings;
            Object.keys(textsMap).forEach(function(key) {
                view = view.replace(new RegExp('{{' + key + '}}', 'gi'), textsMap[key]);
            });
            return view;
        }

        var _toggleFullScreenButton = function(show) {
            if(Utils.$("toggleFullScreenButtonContainer")) {
                Utils.css(Utils.$("toggleFullScreenButtonContainer"), {
                    display: show ? "block" : "none"
                });
            }
        }

        var _toggleNoVideoClasses = function() {
            var videoTagForLocalStream = Utils.$("videoTagForLocalStream");
            var videoTagForSound = Utils.$("videoTagForSound");
            var ll_webrtc_video = Utils.$("ll_webrtc_video");
            var toggleVideo = Utils.$("toggleVideo");
            if (videoTagForLocalStream) {
                Utils.addClass(videoTagForLocalStream, "noVideo");
            }
            if (videoTagForSound) {
                Utils.addClass(videoTagForSound, "noVideo");
            }
            if (ll_webrtc_video) {
                Utils.addClass(ll_webrtc_video, "noVideo");
            }
            if (toggleVideo && _noVideoCameraAvailable()) {
                Utils.css(toggleVideo, {
                    "display": "none"
                });
            } 
        }

        var _toggleNoVideoMessage = function(params, hide, twoWayVideo, selfMute) {
          
            var videoElement = Utils.$("videoSectionWrapper");

            if(hide) {
                if(Utils.$("ll_webrtc_noVideoContainer") && !selfMute) {
                    var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                    Utils.css(noVideoElement, {
                        display: "none"
                    });
                }
                if(Utils.$("ll_webrtc_noVideoContainer_small") && selfMute) {
                    var noVideoElementSmall = Utils.$("ll_webrtc_noVideoContainer_small");
                    Utils.css(noVideoElementSmall, {
                        display: "none"
                    });
                }
                if(Utils.$("ll_webrtc_noVideoContainer") && selfMute && !twoWayVideo) {
                    var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                    Utils.css(noVideoElement, {
                        display: "none"
                    });
                }
                if((twoWayVideo || params.agent) && !selfMute) {
                    _toggleFullScreenButton(true);
                    _toggleNoVideoClasses();
                } else if(!selfMute && !params.agent) {
                    _toggleFullScreenButton(true);
                }
            } else if(Utils.$("ll_webrtc_noVideoContainer") && !selfMute) {
                var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                Utils.css(noVideoElement, {
                    display: "block"
                });
                _toggleNoVideoClasses();
                _toggleFullScreenButton(false);
            } else if(Utils.$("ll_webrtc_noVideoContainer_small") && selfMute) {
                var noVideoElementSmall = Utils.$("ll_webrtc_noVideoContainer_small");
                Utils.css(noVideoElementSmall, {
                    display: "block"
                });
            } else if(Utils.$("ll_webrtc_noVideoContainer") && selfMute && !twoWayVideo) {
                var noVideoElement = Utils.$("ll_webrtc_noVideoContainer");
                Utils.css(noVideoElement, {
                    display: "block"
                });
                _toggleNoVideoClasses();
            } else if(Utils.$("ll_webrtc_noVideoContainer_small") && selfMute && !twoWayVideo) {
                var noVideoElementSmall = Utils.$("ll_webrtc_noVideoContainer_small");
                Utils.css(noVideoElementSmall, {
                    display: "block"
                });
            }
            else if(twoWayVideo && selfMute) {
                var template = document.createElement("div");

                template.id = "ll_webrtc_noVideoContainer_small";

                Utils.css(template, {
                    width: "100px",
                    top: "35px"
                });

                template.innerHTML = "No Video";

                videoElement.append(template);
            } else {
                  
                var template = document.createElement("div");

                template.id = "ll_webrtc_noVideoContainer";

                Utils.css(template, {
                    width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                    top: ((params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) / 2 - 11) + "px"
                });

                template.innerHTML = "No Video";

                videoElement.append(template);

                _toggleFullScreenButton(false);
                _toggleNoVideoClasses();
            }
        }

        var _sendNoVideoMessage = function (caller, message) {
            var that = this,
            peer = MCServiceAPI.Channels.webrtc_video.communicationHandler.peer;

            peer.send(caller, message);
        }

        var _noVideoCameraAvailable = function() {
            return MCServiceAPI.Channels.webrtc_video.videoInputDevices.length === 0;
        }

	    var _elementsWithAddedEventListeners = [];
        var _request = function (method, url, params, headers) {
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open(method, url, true);
                xhr.onload = function () {
                    if (this.status >= 200 && this.status < 300) {
                        resolve(xhr.response);
                    } else {
                        reject({
                            status: this.status,
                            statusText: xhr.statusText
                        });
                    }
                };
                xhr.onerror = function () {
                    reject({
                        status: this.status,
                        statusText: xhr.statusText
                    });
                };

                var hasContentType = false;
                if (headers) {
                    Object.keys(headers).forEach(function (key) {
                        if (key.toLowerCase() === "content-type")
                            hasContentType = true;
                        xhr.setRequestHeader(key, headers[key]);
                    });
                }

                if (method === "POST" && !hasContentType)
                    xhr.setRequestHeader("Content-type", "application/json");

                if (params && typeof params === 'object') {
                    params = Object.keys(params).map(function (key) {
                        return encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);
                    }).join('&');
                }

                try {
                    xhr.send(params);
                }
                catch (err) {
                    reject({
                        status: 500,
                        error: err,
                        statusText: err.message
                    });
                }
            });
        }

        var _terminateSession = function (sessionID, isVisitor) {
            var session = MCServiceAPI.Sessions[sessionID];
            if (!session || session.terminated === true)
                return;

            localStorage.removeItem("accessToken");
            localStorage.removeItem("apiKey");
            localStorage.removeItem("sessionIdentifier");

            MCServiceAPI.Sessions[sessionID].terminated = true;

            _request("DELETE", MCServiceAPI.configuration.auth.start + (isVisitor ? "/visitor/" : "/agent/") + sessionID, null,
                {
                    "x-api-key": MCServiceAPI.Sessions[sessionID].siteCode,
                    "x-access-token": MCServiceAPI.Sessions[sessionID].accessToken
                })
                .catch(function (err) { });

            setTimeout(function (id) {
                delete MCServiceAPI.Sessions[id];
            }, 2000, sessionID);
        };

        var _removeChannels = function (sessionID, channelList, isVisitor) {
            var session = MCServiceAPI.Sessions[sessionID];
            if (!session || session.terminated === true)
                return;

            var channelsToRemove = JSON.stringify(channelList.reduce(
                function (object, key) {
                    object[key] = false;
                    return object
                }, {}));

            _request("POST", MCServiceAPI.configuration.auth.start + (isVisitor ? "/visitor/" : "/agent/") + sessionID,
                channelsToRemove,
                {
                    "x-access-token": MCServiceAPI.Sessions[sessionID].accessToken,
                    "x-http-method-override": "PATCH"
                })
                .then(function () {

                })
                .catch(function (err) {
                    MCServiceAPI.debug.error("Error contacting auth server");
                });
        }

        var _amAlive = function () {
            if (!_isHost) 
                return;

            return;
            /* rewrite for multiple sessions on host side */
            if (MCServiceAPI.StorageManager !== undefined && Object.keys(MCServiceAPI.Sessions).length > 0) {
                _pingTimer = setTimeout(_amAlive, 30000);

                MCServiceAPI.StorageManager.getItemAsync("mcservice.host", "sessionID").then(function (value) {
                    var validValue = false;
                    if (value) {
                        try {
                            var json = JSON.parse(value);
                            if (json && json.sessionID)
                                validValue = true;
                        }
                        catch (e) { }

                        if (validValue && MCServiceAPI.Sessions[json.sessionID] !== undefined) {
                            json.lastActiveTime = new Date().getTime();
                            MCServiceAPI.StorageManager.setItemAsync("mcservice.host", "sessionID", JSON.stringify(json));
                        }
                        else {
                            if (_pingTimer !== 0)
                                clearTimeout(_pingTimer);
                            _pingTimer = 0;
                        }
                    }
                });
            }
            else {
                if (_pingTimer !== 0)
                    clearTimeout(_pingTimer);
                _pingTimer = 0;
            }

        };

        var _pingTimer = 0;
        var _additionalConfig = null;

        var _setAdditionalConfig = function(config) {
            _additionalConfig = config;
        }

        var _getAdditionalConfig = function() {
            return _additionalConfig;
        }

        var _getFirstActiveSession = function (channelName) {
            var sessionID = undefined;
            Object.keys(MCServiceAPI.Sessions).forEach(function (session) {
                if (sessionID === undefined) {
                    var channels = MCServiceAPI.Sessions[session].channels;
                    if (channels && channels[channelName]) {
                        /* looks to be an active session for this channel */
                        sessionID = session;
                    }
                }
            });

            return sessionID;
        }

        var events = MCServiceAPI.Events;
        events.Ready = new eventTemplate("Ready");
        events.Connecting = new eventTemplate("Connecting");
        events.Connected = new eventTemplate("Connected");
        events.Disconnecting = new eventTemplate("Disconnecting");
        events.Disconnected = new eventTemplate("Disconnected");
        events.Error = new eventTemplate("Error");

        MCServiceAPI.Channels = MCServiceAPI.Channels || {};
        MCServiceAPI.supportedChannels = [];

        MCServiceAPI.Sessions = {};
        MCServiceAPI.Channels.cobrowse = {
            abstract: false,
            ready: false,
            supported: false,
            view: "",
            requiredDevices: {},
            environmentErrorReason: [],
            resources: [],
            Events: {},
            listenersReady: false,
            hostStateQueues: {},
            getFrameBySession: function (sessionID) {
                sessionID = (typeof sessionID === "string") ? sessionID.toLowerCase() : undefined;
                if (sessionID)
                    return document.getElementById("LL.cobrowse.frame." + encodeURIComponent(sessionID));

                return undefined;

            },
            stop: function (descriptor) {
                var that = this,
                    sessionID = (typeof descriptor.sessionID === "string") ? descriptor.sessionID.toLowerCase() : undefined;
                if (!sessionID)
                    //NOTHING to do
                    return;

                if ("CoBrowseLauncher" in window) {
                    CoBrowseLauncher.stopCoBrowse(sessionID);
                }

                var agentFrame = that.getFrameBySession(sessionID);
                if (agentFrame && ("messageManager" in window)) {
                    var message = "Disconnect from MCService: ";
                    if (descriptor.reason)
                        message += descriptor.reason;
                    else if (descriptor.status)
                        message += descriptor.status;
                    else
                        message += "(no explanation)";

                    var reason = descriptor.reason || descriptor.status;
                    if (!reason)
                        reason = message;

                    var command = { command: "MCService.disconnect", reason: reason, message: message };
                    if (!descriptor.soft)
                        command.sessionID = sessionID; 

                    messageManager.send(agentFrame.contentWindow, command, { scope: "*" });
                }

                setTimeout(function (id) {
                    if (MCServiceAPI.Sessions[id] && MCServiceAPI.Sessions[id].channels.cobrowse)
                        delete MCServiceAPI.Sessions[id].channels["cobrowse"];
                }, 2999, sessionID);
            },

            getState: function (sessionID) {
                var that = this,
                    stateList = MCServiceAPI.channelStates;

                return new Promise(function (resolve, reject) {
                    if (sessionID === undefined) {
                        sessionID = _getFirstActiveSession("cobrowse");
                        if (sessionID === undefined) {
                            resolve(stateList.NO_SESSION);
                            return;
                        }
                    }

                    sessionID = sessionID.toLowerCase();

                    if (_isHost) {
                        if ("Cobrowse" in window) {
                            // host, easiest scenario
                            Cobrowse.ready().then(function () {
                                var isKnown = Cobrowse.API.Session.SID === sessionID;
                                if (!isKnown) {
                                    resolve(stateList.NO_SESSION);
                                    return;
                                }
                                var state = Cobrowse.API.Session.getState();

                                if (state === Cobrowse.States.ACTIVE || state === Cobrowse.States.ACTIVE_WAIT || state === Cobrowse.States.STARTING) {
                                    resolve(stateList.CONNECTING);
                                }
                                else if (state === Cobrowse.States.ACTIVE_ACTIVE || state === Cobrowse.States.ACTIVE_ESCALATING || state === Cobrowse.States.ACTIVE_ESCALATED || state === Cobrowse.States.DISCONNECTING) {
                                    resolve(stateList.ACTIVE);
                                }
                                else if (state === Cobrowse.States.READY) {
                                    resolve(stateList.DISCONNECTED);
                                }
                                else if (state === Cobrowse.States.ERROR) {
                                    resolve(stateList.DISCONNECTED);
                                }
                                else {
                                    resolve(stateList.NO_SESSION);
                                }

                                return;
                            });
                        }
                        else if ("CoBrowseLauncher" in window) {
                            return CoBrowseLauncher.getState({ SID: sessionID })
                                .then(function (stateDescriptor) {
                                    resolve(stateDescriptor.state);
                                    return;
                                })
                                .catch(function (stateDescriptor) {
                                    resolve(stateDescriptor.state);
                                    return;
                                });
                        }
                        else {
                            resolve(stateList.NO_SESSION);
                            return;
                        }
                    }
                    else {
                        /* not supported for agent side */
                    }

                    resolve(stateList.NO_SESSION);
                });
            },

            checkEnvironment: function () {
                var elem = document.createElement('canvas'),
                    validationPassed = "postMessage" in window
                        && "addEventListener" in window
                        && "JSON" in window
                        && "history" in window
                        && "pushState" in window.history
                        && "keys" in Object
                        && "forEach" in Array.prototype
                        && "indexOf" in Array.prototype
                        && "performance" in window
                        && "now" in window.performance
                        && (typeof elem !== undefined) && !!(elem.getContext && elem.getContext('2d'));

                if (!validationPassed) {
                    this.environmentErrorReason.push("HTML5_REQUIRED");
                    return false;
                }

                return true;
            },

            embedAgentView: function (container, url, siteid, sid, jwt) {
                var that = this,
                    iframe = that.getFrameBySession(sid),
                    frameLoadTimer = 0;

                var cntElement = typeof container === "string" ? document.querySelector(container) : container;
                if (!cntElement) {
                    MCServiceAPI.debug.error("Error embedding agent view: cobrowse container not found");
                    throw "Cobrowse init erorr E0001";
                }

                if (!iframe) {
                    var sessionID = typeof sid === "string" ? sid.toLowerCase() : undefined;

                    iframe = document.createElement("iframe");
                    iframe.setAttribute("id", "LL.cobrowse.frame." + encodeURIComponent(sessionID));
                    iframe.width = "100%";
                    iframe.height = "100%";
                    iframe.scrolling = "no";
                    iframe.frameborder = "0";
                    iframe.marginheight = "0";
                    iframe.marginwidth = "0";
                    iframe.style.border = "0";
                    iframe.setAttribute("allowfullscreen", true);
                    // for reverse cobrowse
                    iframe.setAttribute('allow', "display-capture 'src' " + MCServiceAPI.configuration.mainServer);
                    iframe.addEventListener("load", function () {
                        clearTimeout(frameLoadTimer);
                        frameLoadTimer = 0;
                        iframe.setAttribute("loaded", true);
                    }, false);

                    cntElement.appendChild(iframe);
                }

                frameLoadTimer = setTimeout(function (_container, _url, _siteid, _sid, _jwt) {
                    if (iframe.loaded)
                        return;

                    MCServiceAPI.debug.warn("Agent view loading timeout, retrying");
                    MCServiceAPI.Channels.cobrowse.embedAgentView(_container, _url, _siteid, _sid, _jwt);
                }, 7000, container, url, siteid, sid, jwt);

                var additionalConfig = _getAdditionalConfig(),
                    selectedLanguage = MCServiceAPI.configuration.defaultLanguage;

                if (additionalConfig && additionalConfig.lang) 
                    selectedLanguage = Utils.mapLangToLCID(additionalConfig.lang);

                iframe.setAttribute("loaded", false);
                iframe.src = "";
                iframe.src = url + (url.indexOf("?") === -1 ? "?" : "&") + "token=" + encodeURIComponent(jwt) + "&siteid=" + encodeURIComponent(siteid) + "&sid=" + encodeURIComponent(sid) + "&lang=" + encodeURIComponent(selectedLanguage);
            },

            init: function (isVisitor) {
                var that = this;
                return new Promise(function (resolve, reject) {
                    that.supported = that.checkEnvironment();
                    if (isVisitor) {
                        var integrationReady = ("StorageManager" in MCServiceAPI);
                        if (!integrationReady)
                            that.environmentErrorReason.push("MISSING_REQUIRED_COBROWSE_COMPONENTS");

                        that.supported = that.supported && integrationReady;

                        window.CoBrowseLauncher = window.CoBrowseLauncher || {};
                        if (typeof CoBrowseLauncher.startCoBrowse !== "function") {
                            CoBrowseLauncher.startCoBrowse = function (SID, agentEnv) {
                                /*parameter agentEnv is ignored*/
                                MCServiceAPI.StorageManager.emitDOMEvent("MCService.Cobrowse.startRequested", { SID: SID }, true);
                                return false;
                            }
                        }

                        if (typeof CoBrowseLauncher.stopCoBrowse !== "function") {
                            CoBrowseLauncher.stopCoBrowse = function (SID) {
                                MCServiceAPI.StorageManager.emitDOMEvent("MCService.Cobrowse.stopRequested", { SID: SID }, true);
                            }
                        }

                        if (typeof CoBrowseLauncher.getEnvironment !== "function") {
                            CoBrowseLauncher.getEnvironment = function () {
                                return "icb:" + that.supported;
                            }
                        }

                        if (typeof CoBrowseLauncher.isEnvironmentSupported !== "function") {
                            CoBrowseLauncher.isEnvironmentSupported = function () {
                                return that.supported;
                            }
                        }

                        if (typeof CoBrowseLauncher.getState !== "function") {
                            CoBrowseLauncher.getState = function (entity) {
                                if (!entity)
                                    return Promise.resolve(MCServiceAPI.channelStates.NO_SESSION);

                                var SID = entity.SID,
                                    siteID = entity.apiKey,
                                    sid = typeof (SID) === "string" ? SID.toLowerCase() : undefined,
                                    siteid = typeof (siteID) === "string" ? siteID.toLowerCase() : undefined;

                                return new Promise(function (resolve, reject) {

                                    if (!sid && !siteid) {
                                        resolve(MCServiceAPI.channelStates.NO_SESSION);
                                        return;
                                    }

                                    MCServiceAPI.StorageManager.ready()
                                        .then(function () {
                                            if (["SESSION_STORAGE", "COOKIE"].indexOf(MCServiceAPI.StorageManager.providerName) !== -1) {
                                                /* 3rd party storage disabled, but we still might be able to communicate via window.opener */
                                                try {
                                                    if (!window.opener || window.opener == window) {
                                                        /* no luck */
                                                        resolve({ state: MCServiceAPI.channelStates.UNKNOWN });
                                                        return;
                                                    }
                                                }
                                                catch (e) { }
                                            }

                                            var lookupKey = sid || siteid;

                                            var queue = that.hostStateQueues[lookupKey];
                                            if (queue === undefined) {
                                                queue = [];
                                                that.hostStateQueues[lookupKey] = queue;
                                            }

                                            var callDescriptor = {
                                                success: resolve,
                                                failure: reject,
                                                SID: sid,
                                                siteCode: siteid
                                            };

                                            queue.push(callDescriptor);

                                            var getStateTimeout = setTimeout(function (descriptor) {

                                                // no window called back with update
                                                var callback = descriptor.failure,
                                                    key = descriptor.SID || descriptor.siteCode,
                                                    sessionQueue = that.hostStateQueues[key],
                                                    idx = sessionQueue.indexOf(descriptor);

                                                if (idx !== -1) {
                                                    //remove descriptor from the queue
                                                    sessionQueue.splice(idx);
                                                }

                                                // call the failure callback 
                                                callback({ state: MCServiceAPI.channelStates.TIMEOUT });

                                            }, 5000, callDescriptor);

                                            callDescriptor.timer = getStateTimeout;

                                            MCServiceAPI.StorageManager.emitDOMEvent("Cobrowse.stateRequested", { siteCode: siteid, SID: sid }, true);

                                        });

                                });
                            }
                        }

                        if (that.supported) {
                            window.addEventListener("Cobrowse.state", function (evt) {
                                var SID = evt && evt.detail ? evt.detail.SID : null,
                                    siteCode = evt && evt.detail ? evt.detail.siteCode : null,
                                    sid = typeof (SID) === "string" ? SID.toLowerCase() : undefined,
                                    siteid = typeof (siteCode) === "string" ? siteCode.toLowerCase() : undefined,
                                    requestor = that.hostStateQueues[sid] ? that.hostStateQueues[sid].shift() : undefined;

                                if (!requestor)
                                    requestor = that.hostStateQueues[siteid] ? that.hostStateQueues[siteid].shift() : undefined;

                                if (requestor) {
                                    clearTimeout(requestor.timer);
                                    requestor.timer = 0;
                                    var state = evt && evt.detail ? evt.detail.mcServiceState : undefined,
                                        serializedState = MCServiceAPI.channelStates[state] || MCServiceAPI.channelStates.UNKNOWN,
                                        response = { state: serializedState, SID: evt.detail ? evt.detail.SID : undefined };

                                    requestor.success(response);
                                }
                                else {
                                    console.log("orphaned Cobrowse.state: ", evt.detail);
                                }
                            }, false);

                            window.addEventListener("Cobrowse.connected", function (evt) {
                                var scope = evt && evt.detail ? evt.detail.scope : null,
                                    SID = scope ? scope.SID : null;
                                if (SID && MCServiceAPI.Sessions[SID]) {
                                    MCServiceAPI.debug.info("Firing Connected for cobrowse #" + SID);
                                    _fireEvent(that.Events.Connected, {
                                        agent: false,
                                        context: that,
                                        sessionID: SID,
                                        accessCode: scope.accessCode
                                    });
                                }
                            }, false);

                            window.addEventListener("Cobrowse.disconnecting", function (evt) {
                                var scope = evt && evt.detail ? evt.detail.scope : null,
                                    SID = scope ? scope.SID : null;
                                if (SID && MCServiceAPI.Sessions[SID]) {
                                    MCServiceAPI.debug.info("Firing Disconnecting for cobrowse #" + SID);
                                    _fireEvent(that.Events.Disconnecting, {
                                        agent: false,
                                        context: that,
                                        sessionID: SID,
                                        accessCode: scope.accessCode
                                    });
                                }
                            }, false);
                            window.addEventListener("Cobrowse.disconnected", function (evt) {
                                if (evt && evt.detail) {
                                    var scope = evt.detail.scope,
                                        SID = (scope && scope.SID) || evt.detail.SID;
                                    if (SID && MCServiceAPI.Sessions[SID]) {
                                        MCServiceAPI.debug.info("Firing Disconnected for cobrowse #" + SID);
                                        _fireEvent(that.Events.Disconnected, {
                                            agent: false,
                                            context: that,
                                            code: evt.detail.reason,
                                            reason: evt.detail.reason,
                                            sessionID: SID,
                                            accessCode: scope.accessCode
                                        });
                                    }
                                }
                            }, false);
                        }
                    }
                    else {
                        that.resources.push(MCServiceAPI.configuration.mainServer + "/product/scripts/utils.js");
                        that.resources.push(MCServiceAPI.configuration.mainServer + "/product/scripts/messageManager.js");
                    }

                    that.Events["Preload"] = new eventTemplate("Preload");
                    that.Events["Load"] = new eventTemplate("Load");
                    that.Events["Connected"] = new eventTemplate("Connected");
                    that.Events["Connecting"] = new eventTemplate("Connecting");
                    that.Events["Disconnecting"] = new eventTemplate("Disconnecting");
                    that.Events["Disconnected"] = new eventTemplate("Disconnected");
                    that.Events["Error"] = that.Events["Failed"] = new eventTemplate("Failed");

                    MCServiceAPI.ready().then(function () {
                        that.Events.Error.listen(function (evt) {
                            var descriptor = {
                                channel: 'cobrowse',
                                error: evt
                            }
                            _fireEvent(MCServiceAPI.Events.Error, descriptor)
                        });
                        that.Events.Preload.listen(function (evt) {
                            if (evt.agent) {
                                //just preload the resources
                                _preloadResources(that.resources);
                            }
                        });
                        that.Events.Load.listen(function (evt) {
                            //start loading cobrowse here
                            var channelMetadata = evt.session.channels.cobrowse,
                                channelServer = channelMetadata.channelServer,
                                token = channelMetadata.token,
                                siteID = evt.session.siteCode,
                                sid = (typeof evt.sessionID === "string") ? evt.sessionID.toLowerCase() : undefined;

                            if (!isVisitor) {
                                if (channelMetadata) {
                                    if (!channelServer) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error E0002";
                                    }

                                    if (!token) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error E0003";
                                    }
                                    if (!("messageManager" in window)) {
                                        MCServiceAPI.debug.error("Dependencies not loaded for cobrowse (E0006)");
                                        throw "Cobrowse init error (E0006)";
                                    }

                                    that.embedAgentView(evt.params.container, "https://" + channelServer + "/welcome/jwt/join.aspx", evt.session.siteCode, sid, token);

                                    var frame = that.getFrameBySession(sid);
                                    if (!frame) {
                                        throw new Error("Error embedding co-browse condole");
                                    }

                                    var additionalConfig = _getAdditionalConfig();
                                    if (additionalConfig && additionalConfig.css) {
                                        messageManager.send(frame.contentWindow, {command: 'MCService', customCss: additionalConfig.css}, { scope: "*" });
                                    } else {
                                        messageManager.send(frame.contentWindow, "MCService", { scope: "*" });
                                    }

                                    if (!that.listenersReady) {
                                        messageManager.listen("MCService.loaded", function (evt) {
                                        });

                                        messageManager.listen("MCService.connecting", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Connecting for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Connecting, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.connected", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Connected for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Connected, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.disconnecting", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Disconnecting for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Disconnecting, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.disconnected", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Disconnected for cobrowse #" + evt.SID);
                                            _fireEvent(that.Events.Disconnected, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode,
                                                code: evt.code,
                                                reason: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.error", function (evt) {
                                            if (!evt.SID) /* not an integrated session */
                                                return;
                                            MCServiceAPI.debug.info("Firing Error for cobrowse " + evt.SID);
                                            _fireEvent(that.Events.Error, {
                                                agent: true,
                                                context: that,
                                                sessionID: evt.SID,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });
                                        that.listenersReady = true;
                                    }
                                }
                                else {
                                    if (that.supported && that.ready) {
                                        MCServiceAPI.debug.error("Cobrowse is not supported by authserver");
                                        throw "Cobrowse init error E0004";
                                    }
                                }
                            }
                            else {
                                if (!("CoBrowseLauncher" in window)) {
                                    MCServiceAPI.debug.error("Missing cobrowse integration launcher");
                                    throw "Cobrowse init error E0005";
                                }
                                else if (!that.supported) {
                                    MCServiceAPI.debug.error("Cobrowse channel is not supported");
                                    _fireEvent(that.Events.Error, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_SUPPORTED"
                                    });
                                    _fireEvent(that.Events.Disconnected, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_SUPPORTED",
                                        reason: "ERR_NOT_SUPPORTED"
                                    });
                                }
                                else if (!that.ready) {
                                    MCServiceAPI.debug.error("Cobrowse channel is not ready");
                                    _fireEvent(that.Events.Error, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_READY"
                                    });
                                    _fireEvent(that.Events.Disconnected, {
                                        agent: false,
                                        context: that,
                                        sessionID: evt.sessionID,
                                        code: "ERR_NOT_READY",
                                        reason: "ERR_NOT_READY"
                                    });
                                }
                                else {

                                    new Promise(function (resolve, reject) {
                                        if (MCServiceAPI.configuration.cobrowse.forceWidgetPresence !== true) {
                                            resolve();
                                        } else if ("Cobrowse" in window && "Deployment" in window.Cobrowse) {
                                            resolve();
                                        }
                                        else {
                                            //load cobrowse launcher for DCS
                                            if (!siteID) {
                                                throw "Cobrowse: invalid session configuration";
                                            }
                                            var siteCode = siteID.toLowerCase().replace(/:/g, ""),
                                                launcher = MCServiceAPI.configuration.cobrowse.container.replace("{siteid}", siteCode) + "/launcher.js";

                                            _loadAllResources([launcher]).then(function () {
                                                Cobrowse.ready().then(function () {
                                                    Cobrowse.API.DefaultUI.liveExpertPanelEnabled = false;
                                                    Cobrowse.API.DefaultUI.sessionEndedPopupEnabled = false;
                                                    resolve();
                                                });
                                            });
                                        }
                                    }).then(function () {
                                        var sid = typeof evt.sessionID === "string" ? evt.sessionID : "";
                                        CoBrowseLauncher.getState({ apiKey: siteID })
                                            .then(function (stateDescriptor) {
                                                /* check if there is a session already */
                                                if ([MCServiceAPI.channelStates.CONNECTING, MCServiceAPI.channelStates.ACTIVE].indexOf(stateDescriptor.state) !== -1) {
                                                    //check if it's the same session
                                                    var foreignSID = typeof stateDescriptor.SID === "string" ? stateDescriptor.SID.toLowerCase() : undefined;
                                                    if (foreignSID === sid.toLowerCase()) {
                                                        MCServiceAPI.debug.warn("Cobrowse session " + sid + " is already active");
                                                        return;
                                                    }

                                                    var message = "Another co-browse session is currently active for apiKey: " + siteID;
                                                    console.error(message);
                                                    MCServiceAPI.debug.error(message);
                                                    _fireEvent(that.Events.Error, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_BUSY"
                                                    });
                                                    _fireEvent(that.Events.Disconnected, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_NO_RESPONSE",
                                                        reason: "ERR_COBROWSE_NO_RESPONSE"
                                                    });
                                                    return;
                                                }
                                                else if (stateDescriptor.state === MCServiceAPI.channelStates.UNKNOWN) {
                                                    /* storage cannot provide reliable results - co-browse start will probably fail, but attempt anyways */
                                                    var message = "Cannot communicate with the co-browse widget";
                                                    MCServiceAPI.debug.warn(message);
                                                    console.warn(message);
                                                }

                                                CoBrowseLauncher.startCoBrowse(sid.toLowerCase());
                                            })
                                            .catch(function (errState) {
                                                if (errState && errState.state === MCServiceAPI.channelStates.TIMEOUT) {
                                                    var message = "No co-browse widget detected for apiKey: " + siteID;
                                                    MCServiceAPI.debug.error(message);
                                                    console.error(message);
                                                    _fireEvent(that.Events.Error, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_NO_RESPONSE"
                                                    });
                                                    _fireEvent(that.Events.Disconnected, {
                                                        agent: false,
                                                        context: that,
                                                        sessionID: sid,
                                                        code: "ERR_COBROWSE_NO_RESPONSE",
                                                        reason: "ERR_COBROWSE_NO_RESPONSE"
                                                    });
                                                }
                                                else
                                                    throw errState;
                                            });


                                    });

                                }
                            }
                        });
                    });

                    MCServiceAPI.Events.Disconnecting.listen(function (evt) {
                        var sessionID = evt.sessionID,
                            session = MCServiceAPI.Sessions[sessionID];
                        if (!session || !session.channels || !session.channels.cobrowse || !that.supported)
                            //nothing to do
                            return;

                        evt.context = that;
                        _fireEvent(that.Events.Disconnecting, evt);

                        if (evt.stopSession) {
                            MCServiceAPI.Channels.cobrowse.stop(evt);
                        }
                        else if (!_isHost) {
                            evt.soft = true;
                            MCServiceAPI.Channels.cobrowse.stop(evt);
                        }
                    });

                    MCServiceAPI.Events.Disconnected.listen(function (evt) {
                        var sessionID = evt.sessionID,
                            session = sessionID ? MCServiceAPI.Sessions[sessionID] : null;
                        if (!session || !session.channels || !session.channels.cobrowse || !that.supported)
                            //nothing to do
                            return;

                        evt.context = that;
                        if (evt.code && !evt.reason) {
                            evt.reason = evt.code;
                        }
                        if (!evt.code && evt.reason) {
                            evt.code = evt.reason;
                        }
                        _fireEvent(that.Events.Disconnected, evt);
                        MCServiceAPI.Channels.cobrowse.stop(evt);
                    });

                    that.ready = true;
                    resolve();
                });
            }
        }

        MCServiceAPI.Channels.standalone_cobrowse = {
            abstract: false,
            ready: false,
            supported: false,
            view: "",
            requiredDevices: {},
            environmentErrorReason: [],
            resources: [
                MCServiceAPI.configuration.mainServer + "/product/scripts/utils.js",
                MCServiceAPI.configuration.mainServer + "/product/scripts/messageManager.js"],
            Events: {},
            listenersReady: false,
            checkEnvironment: MCServiceAPI.Channels.cobrowse.checkEnvironment,

            embedAgentView: function (container, url, siteCode, token) {
                var iframe = document.getElementById("LL.cobrowse.frame.standalone"),
                    frameLoadTimer = 0;

                if (!container) {
                    MCServiceAPI.debug.error("Error embedding agent view: standalone cobrowse container not found");
                    throw "Cobrowse init erorr ES001";
                }
                var cntElement = typeof container === "string" ? document.querySelector(container) : container;
                if (!cntElement) {
                    MCServiceAPI.debug.error("Error embedding agent view: cobrowse container not found");
                    throw "Cobrowse init erorr ES011";
                }

                container = cntElement;

                if (token !== undefined) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + "token=" + encodeURIComponent(token);
                }

                if (siteCode !== undefined) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + "siteID=" + encodeURIComponent(siteCode);
                }

                var additionalConfig = _getAdditionalConfig(),
                    selectedLanguage = MCServiceAPI.configuration.defaultLanguage;

                if (additionalConfig && additionalConfig.lang)
                    selectedLanguage = Utils.mapLangToLCID(additionalConfig.lang);

                if (!iframe) {
                    var div = document.createElement("DIV");
                    div.style.width = "100%";
                    div.style.height = "100%";
                    container.appendChild(div);

                    iframe = document.createElement("iframe");
                    iframe.setAttribute("id", "LL.cobrowse.frame.standalone");
                    iframe.width = "100%";
                    iframe.height = "100%";
                    iframe.scrolling = "no";
                    iframe.frameborder = "0";
                    iframe.marginheight = "0";
                    iframe.marginwidth = "0";
                    iframe.style.border = "0";
                    iframe.setAttribute("allowfullscreen", true);
                    // for reverse cobrowse
                    iframe.setAttribute('allow', "display-capture 'src' " + MCServiceAPI.configuration.mainServer);
                    iframe.addEventListener("load", function () {
                        clearTimeout(frameLoadTimer);
                        frameLoadTimer = 0;
                        iframe.setAttribute("loaded", true);
                    }, false);

                    div.appendChild(iframe);
                }

                frameLoadTimer = setTimeout(function (_container, _url) {
                    if (iframe.loaded)
                        return;

                    MCServiceAPI.debug.warn("Standalone Agent view loading timeout, retrying");
                    MCServiceAPI.Channels.standalone_cobrowse.embedAgentView(_container, _url);
                }, 7000, container, url);

                iframe.setAttribute("loaded", false);
                iframe.src = "";
                iframe.src = url + (url.indexOf("?") === -1 ? "?" : "&") + "lang=" + encodeURIComponent(selectedLanguage);

            },

            init: function (isVisitor) {
                var that = this;
                return new Promise(function (resolve, reject) {
                    that.supported = that.checkEnvironment();

                    that.Events["Load"] = new eventTemplate("Load");
                    that.Events["Connected"] = new eventTemplate("Connected");
                    that.Events["Connecting"] = new eventTemplate("Connecting");
                    that.Events["Disconnecting"] = new eventTemplate("Disconnecting");
                    that.Events["Disconnected"] = new eventTemplate("Disconnected");
                    that.Events["Error"] = that.Events["Failed"] = new eventTemplate("Failed");

                    MCServiceAPI.ready().then(function () {
                        if (isVisitor) {
                            //standalone events for cobrowse host
                            window.addEventListener("Cobrowse.connected", function (evt) {
                                var scope = evt.detail ? evt.detail.scope : null;
                                if (scope) {
                                    if (scope.SID)
                                        return; /*not a standalone session*/
                                    var descriptor = {
                                        accessCode: scope.accessCode,
                                        context: that,
                                        agent: false
                                    }
                                    if (!descriptor.accessCode)
                                        return;

                                    MCServiceAPI.debug.info("Firing Connected for standalone cobrowse #" + descriptor.accessCode);
                                    _fireEvent(that.Events.Connected, descriptor);

                                }
                            }, false);
                            window.addEventListener("Cobrowse.disconnecting", function (evt) {
                                var scope = evt.detail ? evt.detail.scope : null;
                                if (scope) {
                                    if (scope.SID)
                                        return; /*not a standalone session*/

                                    var descriptor = {
                                        accessCode: scope.accessCode,
                                        context: that,
                                        agent: false
                                    }
                                    if (!descriptor.accessCode)
                                        return;

                                    MCServiceAPI.debug.info("Firing Disconnecting for standalone cobrowse #" + descriptor.accessCode);
                                    _fireEvent(that.Events.Disconnecting, descriptor);
                                }
                            }, false);

                            window.addEventListener("Cobrowse.disconnected", function (evt) {
                                var scope = evt.detail ? evt.detail.scope : null;
                                if (scope) {
                                    if (scope.SID)
                                        return; /*not a standalone session*/
                                    /*
                                    else if (!evt.detail.agentCount)
                                        return; /* no agents */
                                    if (!scope.accessCode)
                                        return;

                                    MCServiceAPI.debug.info("Firing Disconnected for standalone cobrowse #" + scope.accessCode + ", code: " + evt.detail.reason);
                                    _fireEvent(that.Events.Disconnected, {
                                        agent: false,
                                        context: that,
                                        accessCode: scope.accessCode,
                                        code: evt.detail.reason,
                                        reason: evt.detail.reason
                                    });
                                }
                            }, false);
                        }
                        else {
                            that.Events.Load.listen(function (evt) {
                                //start loading cobrowse here

                                if (evt.params) {
                                    var channelServer = evt.params.channelServer,
                                        token = evt.params.token,
                                        siteCode = evt.params.siteCode;

                                    if (!channelServer) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error ES002";
                                    }

                                    if (!token) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error ES003";
                                    }

                                    if (!siteCode) {
                                        MCServiceAPI.debug.error("Required metadata missing for cobrowse");
                                        throw "Cobrowse init error ES004";
                                    }

                                    if (!("messageManager" in window)) {
                                        MCServiceAPI.debug.error("Dependencies not loaded for cobrowse (ES006)");
                                        throw "Cobrowse init error (ES006)";
                                    }

                                    that.embedAgentView(evt.params.container, "https://" + channelServer + "/welcome/jwt/join.aspx", siteCode, token);

                                    var frame = document.getElementById("LL.cobrowse.frame.standalone");
                                    messageManager.send(frame.contentWindow, "MCService", { scope: "*" });

                                    if (!that.listenersReady) {
                                        messageManager.listen("MCService.loaded", function (evt) {});

                                        messageManager.listen("MCService.connecting", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Firing Connecting for standalone cobrowse #" + evt.accessCode);
                                            _fireEvent(that.Events.Connecting, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.connected", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Firing Connected for standalone cobrowse #" + evt.accessCode);
                                            _fireEvent(that.Events.Connected, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode
                                            })
                                        });

                                        messageManager.listen("MCService.disconnecting", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Disconnecting for standalone cobrowse #" + evt.accessCode + ", code: " + evt.code);
                                            _fireEvent(that.Events.Disconnecting, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.disconnected", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Disconnected for standalone cobrowse #" + evt.accessCode + ", code: " + evt.code);
                                            _fireEvent(that.Events.Disconnected, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode,
                                                code: evt.code,
                                                reason: evt.code
                                            })
                                        });

                                        messageManager.listen("MCService.error", function (evt) {
                                            if (!evt.accessCode || evt.SID)
                                                return;

                                            MCServiceAPI.debug.info("Firing Error for standalone cobrowse " + evt.accessCode + ", code: " + evt.code);
                                            _fireEvent(that.Events.Error, {
                                                agent: true,
                                                context: that,
                                                accessCode: evt.accessCode,
                                                code: evt.code
                                            })
                                        });
                                        that.listenersReady = true;
                                    }
                                }
                                else {
                                    if (that.supported && that.ready) {
                                        MCServiceAPI.debug.error("standalone_cobrowse is not supported by authserver");
                                        throw "Cobrowse init error ES004";
                                    }
                                }
                            });
                        }
                        that.Events.Error.listen(function (evt) {
                            var descriptor = {
                                channel: 'standalone_cobrowse',
                                error: evt
                            }
                            _fireEvent(MCServiceAPI.Events.Error, descriptor)
                        });

                    });

                    that.ready = true;
                    resolve();
                });
            }
        }

        MCServiceAPI.Channels["webrtc_video"] = {
            abstract: false,
            ready: false,
            supported: false,
            view: "\u003clink href=\u0027https://fonts.googleapis.com/css?family=Open+Sans:300\u0027 rel=\u0027stylesheet\u0027 type=\u0027text/css\u0027\u003e\u003clink href=\u0027https://maxcdn.bootstrapcdn.com/font-awesome/4.6.1/css/font-awesome.min.css\u0027 rel=\u0027stylesheet\u0027 type=\u0027text/css\u0027\u003e\u003cdiv id=\"videoSectionWrapper\" oncontextmenu=\"return false\" aria-label=\"{{videoChatWidget}}\" tabindex=\"0\"\u003e\u003cvideo id=\"ll_webrtc_video\"\u003e\u003c/video\u003e\u003cdiv id=\"initializingVideo\" aria-live=\"assertive\"\u003e\u003ci class=\"fa fa-spinner fa-pulse fa-3x fa-fw initSpinner\"\u003e\u003c/i\u003e\u003c/div\u003e\u003cdiv id=\"toggleFullScreenButtonContainer\" class=\"mcHidden\"\u003e\u003ca href=\"javascript:;\" role=\"button\" class=\"controlButton last\" tabindex=\"0\" aria-label=\"{{toggleFullScreen}}\" id=\"toggleFullScreen\" title=\"{{toggleFullScreen}}\"\u003e\u003ci class=\"fa fa-arrows-alt\"\u003e\u003c/i\u003e\u003cspan\u003e{{fullScreen}}\u003c/span\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv id=\"buttonsWrapper\" class=\"mcHidden\" aria-assertive=\"live\" aria-label=\"{{videoChatStart}}\"\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"javascript:;\" tabindex=\"0\" role=\"button\" aria-label=\"{{endCall}}\" class=\"controlButton mcHidden\" id=\"endCall\" title=\"{{endCall}}\"\u003e\u003ci class=\"fa fa-phone\"\u003e\u003c/i\u003e\u003cspan\u003e{{endCall}}\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"javascript:;\" tabindex=\"0\" role=\"button\" aria-label=\"{{muteCall}}\" class=\"controlButton mcHidden last\" id=\"muteCall\" title=\"{{muteCall}}\"\u003e\u003ci class=\"fa fa-microphone\"\u003e\u003c/i\u003e\u003cspan\u003e{{muteCall}}\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003cli class=\"last\"\u003e\u003ca href=\"javascript:;\" role=\"button\" aria-label=\"{{toggleVideo}}\" tabindex=\"0\" class=\"controlButton mcHidden last\" id=\"toggleVideo\" title=\"{{disableVideo}}\"\u003e\u003ci class=\"fa fa-video-camera\"\u003e\u003c/i\u003e\u003cspan\u003e{{video}}\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cdiv class=\"clear\"\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
            initial_view: "\u003clink href=\u0027https://fonts.googleapis.com/css?family=Open+Sans:300\u0027 rel=\u0027stylesheet\u0027 type=\u0027text/css\u0027\u003e\u003cstyle\u003e#videoStartWrapper {font-family: \u0027Open Sans\u0027;position: relative;margin: 0 auto;}#startingVideo {background-color: #fff;font-size: 18px;color: #666;vertical-align: middle;text-align: center;}\u003c/style\u003e\u003cdiv id=\"videoStartWrapper\" oncontextmenu=\"return false\" aria-label=\"{{videoChatWidget}}\" tabindex=\"0\"\u003e\u003cdiv id=\"startingVideo\" aria-live=\"assertive\"\u003e{{connecting}}\u003c/div\u003e\u003c/div\u003e",
            requiredDevices: {
                videoInput: false,
                audioInput: true,
                audioOutput: true
            },
            stop: function (descriptor) {
                try {
                    MCServiceAPI.Channels.webrtc_video.communicationHandler.stopCall();
                }
                catch (e) { }
                setTimeout(function (id) {
                    if (MCServiceAPI.Sessions[id] && MCServiceAPI.Sessions[id].channels.webrtc_video)
                        delete MCServiceAPI.Sessions[id].channels.webrtc_video;
                }, 999, descriptor.sessionID);
            },
            getState: function (sessionID) {
                return new Promise(function (resolve) {
                    var that = this,
                        stateList = MCServiceAPI.channelStates,
                        peer = that.communicationHandler.peer;

                    if (sessionID === undefined) {
                        sessionID = _getFirstActiveSession("webrtc_video");
                        if (sessionID === undefined) {
                            resolve(stateList.NO_SESSION);
                            return;
                        }
                    }

                    if (!peer || !peer.session || sessionID !== that.communicationHandler.sessionID) {
                        resolve(stateList.NO_SESSION);
                        return;
                    }
                    else if (peer.session.sessionState === 'CONNECTED') {
                        var remoteVideoElement = document.querySelector('#videoTagForSound');
                        if (!remoteVideoElement) {
                            remoteVideoElement = document.querySelector('#ll_webrtc_video');
                        }
                        if (!remoteVideoElement || !remoteVideoElement.srcObject || remoteVideoElement.srcObject.active !== true) {
                            resolve(stateList.CONNECTING);
                            return;
                        }
                        else {
                            resolve(stateList.ACTIVE);
                            return;
                        }
                    }
                    else if (peer.session.sessionState === 'CLOSED') {
                        resolve(stateList.DISCONNECTED);
                        return;
                    }

                    resolve(stateList.NO_SESSION);
                });
            },
            UI: {
                endBtn: null,
                endBtnClicked: false,
                toggleSound: null,
                toggleVideoBtn: null,
                buttonsContainer: null,
                video: null,
                initializingContainer: null,
                videoContainer: null,
                toggleFullScreen: null,
                toggleFullScreenButtonWrapper: null,
                textMappings: {
                    'videoChatWidget': 'Video Chat Widget',
                    'videoChatStart': 'Video Chat Started, Video Chat Control Buttons Appeared',
                    'endCall': 'End Call',
                    'muteCall': 'Mute Call',
                    'toggleVideo': 'Toggle Video',
                    'disableVideo': 'Disable Video',
                    'video': 'Video',
                    'toggleFullScreen': 'Toggle Full Screen',
                    'fullScreen': 'Full Screen',
                    'connecting': 'Connecting...',
                    'initializing': 'Initializing...',
                    'unmuteCall': 'Unmute Call',
                    'enableVideo': 'Enable Video',
                    'callEnded': 'Call Ended'
                },

                //DragDrop feature
                xSmallDelta: 0,
                ySmallDelta: 0,

                allowDrop: function(e) {
                    e.preventDefault();
                },
                dropVideo: function(e) {
                    var channel = MCServiceAPI.Channels.webrtc_video;
                    e.preventDefault();
                 
                    var element = document.querySelector('#videoTagForLocalStream');
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }

                    var llWebRTCBlock = document.getElementById("ll_webrtc_video");
                    
                    var top = e.clientY - llWebRTCBlock.getBoundingClientRect().top;
                    var left = e.clientX - llWebRTCBlock.getBoundingClientRect().left;
                    
                    element.style.right = "0px";
                    // element.style.top = (top-channel.UI.ySmallDelta) + "px";
                    element.style.top = (top-channel.UI.ySmallDelta)+(channel.UI.videoContainer.offsetHeight-llWebRTCBlock.offsetHeight)/2 + "px";

                    // element.style.left = (left-channel.UI.xSmallDelta) + "px"; 
                    element.style.left = (left-channel.UI.xSmallDelta)+(channel.UI.videoContainer.offsetWidth-llWebRTCBlock.offsetWidth)/2 + "px";                
                },

                dragStart: function(e) {
                    var channel = MCServiceAPI.Channels.webrtc_video;

                    var element = document.querySelector('#videoTagForLocalStream');
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }

                    channel.UI.xSmallDelta = e.clientX - element.getBoundingClientRect().left;
                    channel.UI.ySmallDelta = e.clientY - element.getBoundingClientRect().top; 
                },

               
                dbclick: function() {
                    var element = document.querySelector('#videoTagForLocalStream');
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }
                    if(element && element.clientWidth < 25) {
                        element.style.width='100px';
                        element.style.height='75px';     
                        element.classList.remove("pulse");                  
                    }else if(element) {
                        element.style.width='20px';
                        element.style.height='20px';
                        element.classList.add("pulse");
                        element.style.top = "7px";
                        element.style.left = "auto";
                        element.style.right = "7px";
                    }
                },
                hideShowSelfView: function(status, videoDirectionClient) {

                    if (videoDirectionClient) {
                        return;
                    }

                    var element = document.querySelector('#videoTagForLocalStream');
                    var textNoVideo = document.querySelector('#ll_webrtc_noVideoContainer_small')
                    if(!element) {
                        element = document.querySelector('#videoTagForSound');
                    }
                    if(element) {
                        if(status === 'hide') {
                            element.style.display="none";
                            if(textNoVideo)
                                textNoVideo.style.display="none";
                        }else {
                            element.style.display="block";
                        }
                    }
                },

                enableDragDrop: function(element) {
                    var dragableElement = document.querySelector('#'+element);

                    if(dragableElement) {
                        dragableElement.setAttribute('draggable', true);
                        var llWEBRTCVideo = document.getElementById("ll_webrtc_video");
                        
                        llWEBRTCVideo.addEventListener('dragover', this.allowDrop, false);
                        llWEBRTCVideo.addEventListener('drop', this.dropVideo, false);
                        dragableElement.addEventListener('dragstart', this.dragStart, false);
                        dragableElement.addEventListener("dblclick", this.dbclick);                    
                    }
                },

                init: function (params, session) {
                    var that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        isVisitor = !params.agent,
                        peer = channel.communicationHandler.peer,
                        uiInitUpdater = MCServiceAPI.debug.logAsync("Initializing webrtc UI for " + (isVisitor ? "Visitor" : "Agent"));

                    params = params.params || {};
                    var videoOnBothSides = params && params.callConfiguration ? params.callConfiguration.video === "both" : false;
                    var videoDirectionClient = params ? params.videoDirection === "visitor" : false;
                    var audioOnly = params && params.videoDirection ? params.videoDirection === "none" : false;
                    // Enabling full screen for all
                    params.isFullScreenEnabled = true;

                    that.currentParams = params;
                    that.endBtn = Utils.$('endCall');
                    that.toggleSound = Utils.$('muteCall');
                    that.toggleVideoBtn = Utils.$('toggleVideo');
                    that.buttonsContainer = Utils.$('buttonsWrapper');
                    that.video = document.querySelector('#ll_webrtc_video');
                    that.videoForFullScreen = document.querySelector('#ll_webrtc_video');
                    that.initializingContainer = Utils.$("initializingVideo");
                    that.videoContainer = Utils.$("videoSectionWrapper");
                    that.toggleFullScreen = Utils.$("toggleFullScreen");
                    that.toggleFullScreenButtonWrapper = Utils.$("toggleFullScreenButtonContainer");

                    if (that.initializingContainer) {
                        that.initializingContainer.innerHTML = that.textMappings.initializing;
                    }
                    Utils.addClass([that.toggleSound, that.toggleVideoBtn, that.endBtn], "disabled");

                    if (!isVisitor && videoOnBothSides) {
                        // If Video On Both Sides is enabled - change the video tag in use
                        if(!Utils.$("videoTagForSound")) {
                            var remoteSoundTag = document.createElement("video");

                            remoteSoundTag.className = "hidden";
                            remoteSoundTag.id = "videoTagForSound";
                            that.videoContainer.appendChild(remoteSoundTag);
                            that.video = remoteSoundTag;
                            // Accessibility
                            that.video.setAttribute('tabindex', 0);
                            that.video.setAttribute('title', 'Visitor\'s video screen.');
                            that.video.setAttribute('aria-label', 'Visitor\'s video screen.');
                            // Done to be able to control the small window expand/collapse with keyboard
                            that.video.addEventListener('keyup', function (e) {
                                if (e.which === 13) {
                                    that.dbclick();
                                }
                            });
                        } else {
                            that.video = Utils.$("videoTagForSound");
                        }
                            //Safari support
                            if(that.video){
                                that.video.setAttribute('webkit-playsinline', 'webkit-playsinline');
                                that.video.setAttribute('playsinline', 'playsinline');
                                that.video.allowsInlineMediaPlayback = true;
                                that.video.autoplay = true;
                            }
                    }

                    if((!isVisitor && !videoOnBothSides && !videoDirectionClient) || (isVisitor && !videoOnBothSides && videoDirectionClient)) {
                        Utils.addClass(that.video, "mirroringFix");
                    }

                    // If Full Screen is enabled in config - show the button and attach the click event listeners
                    if (params.isFullScreenEnabled) {
                        if(_elementsWithAddedEventListeners.indexOf("toggleFullScreen") < 0) {
                            _elementsWithAddedEventListeners.push("toggleFullScreen");
                            Utils.listen("click", that.toggleFullScreen, function () {
                                if (peer)
                                    peer.enterFullScreen(that.videoForFullScreen);
                            });
                        }
                    }

                    // Setting the Video tag sizes
                    Utils.css(that.video, {
                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                    });

                    //add Safari support for iOS
                    if(that.video) {
                        that.video.setAttribute('webkit-playsinline', 'webkit-playsinline');
                        that.video.setAttribute('playsinline', 'playsinline');
                        that.video.allowsInlineMediaPlayback = true;
                        that.video.autoplay = true;
                    }


                    // Setting the "Initializing" block size
                    Utils.css(that.initializingContainer, {
                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                        display: "table-cell"
                    });

                    // Setting the "videoSectionWrapper" block size
                    Utils.css(that.videoContainer, {
                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                    });


                    if(_elementsWithAddedEventListeners.indexOf("muteCall") < 0) {
                        _elementsWithAddedEventListeners.push("muteCall");
                        Utils.listen("click", that.toggleSound, function () {
                            var ll_caller = channel.communicationHandler.ll_caller;
                            if (peer && ll_caller) {
                                peer.toggleSound(ll_caller);
                                var status = peer.soundStatus(ll_caller);
                                if (status) {
                                    Utils.removeClass(that.toggleSound, "disabled");
                                    that.toggleSound.setAttribute("title", that.textMappings.muteCall);
                                } else {
                                    Utils.addClass(that.toggleSound, "disabled");
                                    that.toggleSound.setAttribute("title", that.textMappings.unmuteCall);
                                }

                                // Callback for state change
                                if (channel) {
                                    console.log(Utils.getTimeString() + ": firing AudioStateChange for video for " + (isVisitor ? "Visitor" : "Agent") + ", state: " + (status ? "unmute" : "mute"));
                                    _fireEvent(channel.Events.AudioStateChange, {
                                        state: status ? "unmute" : "mute",
                                        context: channel,
                                        agent: !isVisitor
                                    });
                                }
                                // Fixes an issue with JAWS in FireFox
                                that.toggleSound.blur();
                                that.toggleSound.focus();
                            }
                        });
                    }

                    if(_elementsWithAddedEventListeners.indexOf("toggleVideo") < 0) {
                        _elementsWithAddedEventListeners.push("toggleVideo");
                        Utils.listen("click", that.toggleVideoBtn, function () {
                            var ll_caller = channel.communicationHandler.ll_caller;
                            if (peer && ll_caller) {
                                peer.toggleVideo(ll_caller);
                                var status = peer.videoStatus(ll_caller);
                                if (status) {
                                    Utils.removeClass(that.toggleVideoBtn, "disabled");
                                    that.toggleVideoBtn.setAttribute("title", that.textMappings.disableVideo);
                                    _toggleNoVideoMessage(params, true, videoOnBothSides, true);
                                    _sendNoVideoMessage(ll_caller, '{"videoStateChange" : "enabled"}');
                                    if (videoOnBothSides) {
                                        channel.UI.hideShowSelfView('show', videoDirectionClient);
                                    }
                                } else {
                                    Utils.addClass(that.toggleVideoBtn, "disabled");
                                    that.toggleVideoBtn.setAttribute("title", that.textMappings.enableVideo);
                                    _toggleNoVideoMessage(params, false, videoOnBothSides, true);
                                    _sendNoVideoMessage(ll_caller, '{"videoStateChange" : "disabled"}');
                                    if (videoOnBothSides) {
                                        channel.UI.hideShowSelfView('hide', videoDirectionClient);
                                    }
                                }

                                // Callback for state change
                                if (channel) {
                                    console.log(Utils.getTimeString() + ": firing VideoStateChange for " + (isVisitor ? "Visitor" : "Agent") + ", state: " + (status ? "resume" : "pause"));
                                    _fireEvent(channel.Events.VideoStateChange, {
                                        state: status ? "resume" : "pause",
                                        videoTag: that.video,
                                        context: channel,
                                        agent: !isVisitor
                                    });
                                }
                                // Fixes an issue with JAWS in FireFox
                                that.toggleVideoBtn.blur();
                                that.toggleVideoBtn.focus();
                            }
                        });
                    }

                    if(_elementsWithAddedEventListeners.indexOf("endCall") < 0) {
                        _elementsWithAddedEventListeners.push("endCall");
                        Utils.listen("click", that.endBtn, function () {
                            channel.communicationHandler.stopCall();
                            channel.UI.endBtnClicked = true;
                            _elementsWithAddedEventListeners = [];
                        });
                    }

                    channel.Events.Disconnecting.listen(function (evt) {
                        channel.UI.toggleVideo();
                        if (evt.agent) {
                            Utils.addClass([that.endBtn, that.toggleSound, that.toggleVideoBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "mcHidden");
                        }
                        else {
                            Utils.addClass([that.toggleSound, that.endBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "disabled mcHidden");
                        }
                        if (Utils.$("chatMessageBox")) {
                            Utils.$("chatMessageBox").setAttribute("disabled", "disabled");
                        }
                    });

                    channel.Events.Disconnected.listen(function (evt) {
                        channel.UI.toggleVideo();
                        if (that.initializingContainer) {
                            that.initializingContainer.innerHTML = that.textMappings.callEnded;
                        }
                        if (evt.agent) {
                            Utils.addClass([that.endBtn, that.toggleSound, that.toggleVideoBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "mcHidden");
                            // Removing the messages if any
                            if (Utils.$("chatMessageBox"))
                                Utils.$("chatMessageBox").setAttribute("disabled", "disabled");
                        }
                        else {
                            Utils.addClass([that.toggleSound, that.endBtn, that.toggleVideoBtn, that.buttonsContainer, that.toggleFullScreenButtonWrapper], "mcHidden");
                        }
                    });

                    channel.Events.Connecting.listen(function (evt) {
                        // Changed for Client to Agent Video
                        if (evt.agent && !videoDirectionClient) {
                            Utils.removeClass([that.toggleSound, that.toggleVideoBtn, that.buttonsContainer], "mcHidden disabled");
                        }
                        if (evt.agent && videoDirectionClient) {
                            Utils.removeClass([that.toggleSound, that.buttonsContainer], "mcHidden disabled");
                        }
                        if (!evt.agent && videoDirectionClient) {
                            Utils.removeClass([that.toggleSound, that.toggleVideoBtn, that.buttonsContainer], "mcHidden disabled");
                        }
                    });

                    channel.Events.Connected.listen(function (evt) {
                        channel.UI.toggleVideo(true);

                        // Audio Only case
                        if (audioOnly) {
                            Utils.css(that.buttonsContainer, {
                                'margin-top': 0,
                                'bottom': 0
                            });
                            Utils.css(that.toggleVideoBtn, {
                                'display': 'none'
                            });
                            Utils.css(that.toggleFullScreenButtonWrapper, {
                                'display': 'none'
                            });
                        }

                        // Visitor to Agent case
                        if (evt.agent && videoDirectionClient) {
                            Utils.css(that.toggleVideoBtn, {
                                'display': 'none'
                            });
                        }
                        // Visitor to Agent case

                        var ll_caller = channel.communicationHandler.ll_caller;
                        // Changed for Client to Agent Video
                        if((params.isFullScreenEnabled && videoOnBothSides) || (params.isFullScreenEnabled && !evt.agent && !videoDirectionClient) || (params.isFullScreenEnabled && evt.agent && videoDirectionClient)) {
                            Utils.removeClass(that.toggleFullScreenButtonWrapper, "mcHidden");
                        }

                        if(_noVideoCameraAvailable() && (videoOnBothSides || evt.agent)) {
                            _toggleNoVideoMessage(params, false, videoOnBothSides, true);
                            _toggleNoVideoClasses();
                        }

                        if (evt.agent) {
                            Utils.removeClass(that.endBtn, "mcHidden disabled");
                        }
                        else {
                            // Enabling the control buttons
                            Utils.removeClass([that.toggleSound, that.endBtn, that.buttonsContainer], "mcHidden disabled");
                        
                            // Show the video pause/display buttons only if video on both sides is enabled
                            if (videoOnBothSides) {
                                Utils.removeClass(that.toggleVideoBtn, "mcHidden disabled");
                            }
                        }
                    });

                    uiInitUpdater.resolve();
                },

                renderLocalVideoTag: function (stream) {
                    var localVideoTag = document.createElement("video"),
                        localVideoElement = null,
                        that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        remoteVideoElement = null;

                    localVideoTag.id = "videoTagForLocalStream";
                    that.videoContainer.appendChild(localVideoTag);

                    // Accessibility
                    localVideoTag.setAttribute('tabindex', 0);
                    localVideoTag.setAttribute('title', 'Your video screen.');
                    localVideoTag.setAttribute('aria-label', 'Your video screen.');
                    // Done to be able to control the small window expand/collapse with keyboard
                    localVideoTag.addEventListener('keyup', function (e) {
                        if (e.which === 13) {
                            that.dbclick();
                        }
                    });

                    localVideoElement = localVideoTag;

                    try {
                        localVideoElement.srcObject = stream;
                        localVideoElement.load();
                        localVideoElement.play();
                        localVideoElement.controls = false;
                        localVideoElement.muted = true;
                    } catch (ex) { }

                    Utils.css(localVideoElement, {
                        width: 100 + "px",
                        height: 75 + "px",
                        display: "block",
                        position: "absolute",
                        top: 7 + "px",
                        right: 7 + "px",
                        cursor: "pointer"
                    });

                    //DragDrop feature 
                    try{
                        channel.UI.enableDragDrop("videoTagForLocalStream");
                    } catch(ex){}

                    console.log(Utils.getTimeString() + ": local tag rendered  aaaaa");
                },

                renderRemoteVideoTag: function (stream, params, session) {
                    var that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        remoteVideoElement = null,
                        videoDirectionClient = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "visitor" : false,
                        videoOnBothSides = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "both" : false;

                    if (videoOnBothSides) {
                        remoteVideoElement = document.querySelector("#ll_webrtc_video"),
                            localVideoElement = Utils.$("videoTagForSound");

                        // Setting the Video tag sizes
                        Utils.css(remoteVideoElement, {
                            width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                            height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                            display: "block"
                        });

                        //add Safari support for iOS
                        if(remoteVideoElement) {
                            remoteVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                            remoteVideoElement.setAttribute('playsinline', 'playsinline');
                            remoteVideoElement.allowsInlineMediaPlayback = true;
                            remoteVideoElement.autoplay = true;
                        }

                        //add Safari support for iOS
                        if(localVideoElement) {
                            localVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                            localVideoElement.setAttribute('playsinline', 'playsinline');
                            localVideoElement.allowsInlineMediaPlayback = true;
                            localVideoElement.autoplay = true;
                        }

                        Utils.css(localVideoElement, {
                            width: 100 + "px",
                            height: 75 + "px",
                            display: "block",
                            position: "absolute",
                            top: 7 + "px",
                            right: 7 + "px",
                            cursor: "pointer"
                        });

                    }
                    else {
                        if (!videoDirectionClient) { // Agent to Client Video
                            if(!Utils.$("videoTagForSound")) {
                                var remoteSoundTag = document.createElement("video");

                                remoteSoundTag.className = "hidden";
                                remoteSoundTag.id = "videoTagForSound";
                                that.videoContainer.appendChild(remoteSoundTag);

                                remoteVideoElement = remoteSoundTag;
                            } else {
                                remoteVideoElement = Utils.$("videoTagForSound");
                            }
                        } else { // Client to Agent Video
                            remoteVideoElement = Utils.$("ll_webrtc_video");
                        } 
                            //Safari support
                            if(remoteVideoElement) {
                                remoteVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                                remoteVideoElement.setAttribute('playsinline', 'playsinline');
                                remoteVideoElement.allowsInlineMediaPlayback = true;
                                remoteVideoElement.autoplay = true;
                            }
                    }

                    //DragDrop feature 
                    try{
                        channel.UI.enableDragDrop("videoTagForSound");
                    } catch(ex){}

                    try {
                   
                     //remoteVideoElement.volume = 0;
                     remoteVideoElement.pause();

                     setTimeout(function () {      
 
                        remoteVideoElement.srcObject = stream;
                        remoteVideoElement.load();
                        remoteVideoElement.play();
                        remoteVideoElement.controls = false;
                      }, 450);

                    } catch (ex) { }

                    console.log(Utils.getTimeString() + ": remote tag rendered");
                },

                toggleVideo: function (show) {
                    var that = this,
                        channel = MCServiceAPI.Channels.webrtc_video,
                        videoContainer = that.video,
                        initializingContainer = that.initializingContainer,
                        hasVideo = channel ? channel.hasVideo : true,
                        videoDirectionClient = that.currentParams ? that.currentParams.videoDirection === "visitor" : false,
                        videoOnBothSides = that.currentParams && that.currentParams.callConfiguration ? that.currentParams.callConfiguration.video === "both" : false;

                    if (show) {
                        if (hasVideo) {
                            Utils.css(videoContainer, {
                                display: "block"
                            });
                        }
                        Utils.css(initializingContainer, {
                            display: "none"
                        });
                    } else {
                        if (hasVideo) {
                            Utils.css(videoContainer, {
                                display: "none"
                            });
                            if (videoOnBothSides)
                                Utils.css(document.querySelector("#ll_webrtc_video"), {
                                    display: "none"
                                });
                        }
                        Utils.css(initializingContainer, {
                            display: "table-cell"
                        });

                        if (initializingContainer) {
                            initializingContainer.innerHTML = that.textMappings.callEnded;
                        }

                        if (Utils.$("videoTagForSound")) {
                            Utils.css(Utils.$("videoTagForSound"), {
                                display: "none"
                            });
                        }
                        if (Utils.$("videoTagForLocalStream")) {
                            Utils.css(Utils.$("videoTagForLocalStream"), {
                                display: "none"
                            });
                        }
                    }
                },
                appendCancelButton: function (text, globalStream) {
                    var initializingContainer = Utils.$("initializingVideo"),
                        initializingVideoContainerHTML = initializingContainer.innerHTML,
                        cancelButtonHTML = '<br /><a href="javascript:;" tabindex="0" role="button" aria-label="Cancel" title="Cancel" id="cancelVideoChatSession"><i class="fa fa-close"></i></a>',
                        updatedContent = initializingVideoContainerHTML + cancelButtonHTML;

                    if (initializingContainer) {
                        initializingContainer.innerHTML = updatedContent;
                    }

                if(_elementsWithAddedEventListeners.indexOf("cancelVideoChatSession") < 0) {
                    _elementsWithAddedEventListeners.push("cancelVideoChatSession");
                    Utils.listen("click", Utils.$("cancelVideoChatSession"), function () {
                        var channel = MCServiceAPI.Channels.webrtc_video;
                        // Removing the elemenet
                        Utils.$("videoSectionWrapper").parentNode.innerHTML = "";
                        globalStream.getVideoTracks()[0].stop();
                        globalStream.getAudioTracks()[0].stop();
                        if (channel) {
                            channel.UI.toggleVideo();
                        }
                    });
                }
            }
            },
            communicationHandler: {
                peer: null,
                ll_caller: null,
                agent: false,
                sessionID: null,
                currentState: 0,
                setConfig: function (evtData) {
                    var channel = MCServiceAPI.Channels.webrtc_video;
                    evtData.params.ringer = {
                        url: MCServiceAPI.configuration.video.ringer
                    };
                    evtData.params.dialer = {
                        url: MCServiceAPI.configuration.video.dialer
                    };

                    var channelMetadata = evtData.session.channels.webrtc_video,
                        channelServer = channelMetadata ? channelMetadata.channelServer: null;

                    evtData.params.serverConfiguration = {
                        serverUrl: channelServer,
                        isSecureConnection: true,
                        serverPort: null,
                        wscAppUri: MCServiceAPI.configuration.video.wscAppUri,
                        authType: MCServiceAPI.configuration.video.authType
                    }
                    evtData.params.callConfiguration = {
                        audio: "both",
                        video: evtData.params.agent ? "send" : "receive",
                        videoWidth: evtData.params.videoWidth,
                        videoHeight: evtData.params.videoHeight,
                        uiVideoWidth: evtData.params.uiVideoWidth,
                        uiVideoHeight: evtData.params.uiVideoHeight,
                        frameRateFPS: "",
                        sendBitrate: evtData.params.sendBitrate,
                        recvBitrate: evtData.params.recvBitrate
                    }

                    this.sessionID = evtData.sessionID;
                    this.agent = evtData.params.agent;
                    var videoDirection = evtData.session.channels.webrtc_video.videoDirection;
                    if (videoDirection === "both") {
                        evtData.params.callConfiguration.video = "both";
                        channel.hasVideo = true;
                    }
                    else if (videoDirection === "agent" || videoDirection === "visitor") {
                        channel.hasVideo = true;
                    }
                    else {
                        channel.hasVideo = false;
                    }

                    if (videoDirection === "visitor" && !evtData.params.agent) {
                        evtData.params.callConfiguration.video = "send";
                    } else if (videoDirection === "visitor" && evtData.params.agent) {
                        evtData.params.callConfiguration.video = "receive";
                    }

                    LLPeer.setConfiguration(evtData.params);
                },

                startVideoCall: function (stream, peerID) {
                    this.peer.partyGone = false;
                    this.currentState = 0;
                    var peer = this.peer;
                    peer.dialer.play();
                    peer.call(peerID, "VIDEO", stream);
                },
                acceptCall: function (peer, caller) {
                    var channel = MCServiceAPI.Channels.webrtc_video,
                        agent = this.agent ? true : false;
                    peer.accept(caller,
                        function (evt) {   // Accept callback
                            if (channel) {
                                console.log(Utils.getTimeString() + ": firing SessionStateChange for video for " + (agent ? "Agent" : "Visitor") + ", state: accept");
                                _fireEvent(channel.Events.SessionStateChange, {
                                    state: "accept",
                                    context: channel,
                                    agent: agent
                                });
                                _fireEvent(channel.Events.Connecting, {
                                    agent: agent,
                                    sessionID: channel.communicationHandler.sessionID,
                                    context: channel
                                });
                            }
                        },
                        function (evt) {   // Decline callback
                            if (channel) {
                                console.log(Utils.getTimeString() + ": firing SessionStateChange for video for " + (agent ? "Agent" : "Visitor") + ", state: decline");
                                _fireEvent(channel.Events.SessionStateChange, {
                                    state: "decline",
                                    context: channel,
                                    agent: agent
                                });
                            }
                            _fireEvent(channel.Events.Error, {
                                agent: agent,
                                context: channel,
                                code: "ERR_PERMISSION_DENIED",
                                error: evt,
                                sessionID: channel.communicationHandler.sessionID
                            });
                        }
                    );
                    peer.ringer.stop();
                },

                stopCall: function () {
                    var channel = MCServiceAPI.Channels.webrtc_video,
                        peer = this.peer,
                        currentState = this.currentState;

                    if (!peer)
                        return;

                    if (currentState !== -1) {
                        this.currentState = 0;

                        if (channel) {
                            console.log(Utils.getTimeString() + ": firing DISCONNECTING for video for " + (this.agent ? "Agent" : "Visitor"));
                            _fireEvent(channel.Events.Disconnecting, {
                                agent: this.agent,
                                context: channel,
                                sessionID: channel.communicationHandler.sessionID
                            });

                            if (currentState === 0) {
                                //video not connected, just wrap it up then
                                _fireEvent(channel.Events.Disconnected, {
                                    agent: this.agent,
                                    context: channel,
                                    sessionID: channel.communicationHandler.sessionID
                                });

                                this.currentState = -1;
                            }
                        }

                        peer.end(this.ll_caller);
                        peer.getSession().close();
                        if (!this.agent)
                            peer.ringer.stop();

                    }

                },
                getTracks: function (stream) {
                    var trackList = "";
                    try {
                        if (stream && stream.getTracks) {
                            var tracks = stream.getTracks();
                            if (tracks.length > 0) {
                                tracks.forEach(function (track) {
                                    var trackKind = track.kind ? track.kind : "";
                                    if (trackKind)
                                        trackList += (trackList.length > 0 ? ", " : "") + trackKind;
                                })
                            }
                        }
                    }
                    catch (e) {
                        trackList = "";
                    }
                    return trackList;
                },

                handleReconnect: function (sessionID, peerID) {
                    return new Promise(function (resolve, reject) {
                        var that = this;
                        that.isActive = true;
                        if (MCServiceAPI.Sessions[sessionID]) {
                            /*session still active*/
                            var videoObject = MCServiceAPI.Channels.webrtc_video.UI.video;
                            var peer = MCServiceAPI.Channels.webrtc_video.communicationHandler.peer;
                            peer.call(peerID, "VIDEO", videoObject.captureStream());
                            setTimeout(function (that) {
                                //give up in 5.5 seconds
                                if (that.isActive) {
                                    that.isActive = false;
                                    reject();
                                }

                            }, 5500, that);
                            peer.on('call:started', function (caller, state) {
                                setTimeout(function (that) {
                                    if (that.isActive) {
                                        that.isActive = false;
                                        reject();
                                    }
                                }, 3500, that);
                            });
                            peer.on("call:ringing", function () {
                                if (that.isActive) {
                                    console.log("CALL RECONNECTED");
                                    that.isActive = false;
                                    resolve();
                                }
                            });
                        }
                        else {
                            that.isActive = false;
                            resolve();
                        }
                    });
                },

                init: function (params, session) {

                    this.peer = new LLPeer({
                        peerId: params.peerID
                    });

                    var channel = MCServiceAPI.Channels.webrtc_video,
                        that = this,
                        agent = that.agent ? true : false,
                        peer = that.peer,
                        callStarted = false,
                        hintShown = false,
                        connectingUpdater = null,
                        connectionUpdater = null,
                        currentStream = null,
                        videoDirectionClient = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "visitor" : false,
                        videoOnBothSides = session && session.channels && session.channels.webrtc_video ? session.channels.webrtc_video.videoDirection === "both" : false;

                    peer.on('open', function () {
                        console.log(Utils.getTimeString() + ": peer:open");
                        if (channel) {
                            console.log(Utils.getTimeString() + ": firing Render for video for " + (agent ? "Agent" : "Visitor"));
                            _fireEvent(channel.Events.Render, {
                                agent: agent,
                                context: channel,
                                params: params
                            });
                        }

                        if (agent) {
                            // Triggering the event that the device permission request can be shown
                            setTimeout(function () {
                                if (!callStarted) {
                                    if (channel) {
                                        _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                            show: true,
                                            context: channel
                                        });
                                    }
                                    hintShown = true;
                                }
                            }, 999);

                            var reconnectTimer = null;

                            // Getting the user Media
                            peer.on('stream', function (stream) {
                                connectionUpdater = MCServiceAPI.debug.logAsync("Routing accepted video call");
                                currentStream = stream;
                                if (channel) {
                                    try {
                                        channel.UI.video.srcObject = stream;
                                        channel.UI.video.play();
                                        channel.UI.video.controls = false;
                                        channel.UI.video.muted = !videoDirectionClient ? true : false;
                                    } catch (ex) {
                                        MCServiceAPI.debug.error("Error rendering local video: ", ex);
                                    }
                                }

                                if (_getFirstActiveSession("webrtc_video")) {
                                //if (Object.keys(MCServiceAPI.Sessions).length !== 0) {
                                    that.startVideoCall(stream, params.visitorPeerID);  // SET THE PEER ID OF THE OPPOSITE SIDE

                                    setTimeout(function () {
                                        if (!callStarted) {
                                            channel.UI.appendCancelButton("Cancel", stream);
                                        }
                                    }, 6999);

                                    // Triggering the event that the device permission request can be hidden
                                    callStarted = true;
                                    if (hintShown) {
                                        if (channel) {
                                            _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                show: false,
                                                context: channel
                                            });
                                        }
                                    }

                                    peer.on('call:started', function (caller, state) {
                                        console.log(Utils.getTimeString() + ": call:started");
                                        that.ll_caller = caller;
                                    });

                                    peer.on('call:ringing', function (caller) {
                                        console.log(Utils.getTimeString() + ": call:ringing");
                                        that.ll_caller = caller;
                                    });

                                    peer.on('call:responded', function (caller) {
                                        that.currentState = 1;
                                        if (channel) {
                                            /*
                                            console.log(Utils.getTimeString() + ": firing Connecting for video for Agent");
                                            _fireEvent(channel.Events.Connecting, { agent: agent });
                                            */
                                        }
                                    });

                                    peer.on('call:established', function (caller) {
                                        that.currentState = 1;
                                        connectingUpdater = MCServiceAPI.debug.logAsync("Waiting for remote stream...");
                                        if (channel) {
                                            _fireEvent(channel.Events.Connecting, {
                                                agent: agent,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID
                                            });
                                        }
                                    });

                                    peer.on('call:close', function (caller) {
                                        if (that.peer.partyGone) {
                                            //we are already processing it
                                            return;
                                        }

                                        that.currentState = 0;
                                        console.error("Host disappeared", caller);
                                        that.peer.partyGone = true;
                                        _retry(function () {
                                                var sessionID = _getFirstActiveSession("webrtc_video");
                                                if (sessionID) {
                                                    var session = MCServiceAPI.Sessions[sessionID];
                                                    return that.handleReconnect(session, session.channels.webrtc_video.visitorPeerID)
                                                }
                                                else {
                                                    console.error("Session was disconnected");
                                                    throw new Error("No active sessions found");
                                                }
                                            },
                                            function () {
                                                //retry until it times out - no conditions
                                                return true;
                                            }, 60 * 1000 * 3, 7000)
                                        .then(function () {
                                            console.log("OK");
                                        })
                                        .catch(function(err) {
                                            console.log("ERROR: ", err);
                                        });                                    
                                    });

                                    peer.on('call:ended', function (caller) {
                                        if (that.peer) {
                                            that.peer.partyGone = false;
                                        }
                                        _elementsWithAddedEventListeners = [];
                                        that.currentState = 0;

                                        if (channel) {
                                            _fireEvent(channel.Events.Disconnected, {
                                                agent: false,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID
                                            });
                                            //that.peer = null;
                                        }
                                        if (connectionUpdater) {
                                            connectionUpdater.reject("received call:ended");
                                        }

                                        // Hiding the "No Video" message if it's visible
                                        _toggleNoVideoMessage(params, true, undefined, true);
                                    
                                        //release media access on endcall
		                                try {
                                            setTimeout(function() {
				                                if(currentStream) {
					                                currentStream.getTracks().filter(function(track){
											            track.stop();
										            });
				                                }
								            }, 3333);
		                                }catch(ex) {}
                                    });

                                    peer.on('call:failed', function (caller, state) {
                                        that.currentState = 0;
                                        peer.dialer.stop();
                                        if (connectionUpdater) {
                                            connectionUpdater.reject("received call:failed");
                                        }
                                        if (connectingUpdater) {
                                            connectingUpdater.reject("received call:ended");
                                        }
                                    });

                                    // MESSAGING FOR NO VIDEO MESSAGE TRANSMISSION
                                    peer.on('messaging:open', function (caller) {
                                        if(_noVideoCameraAvailable()) {
                                            _sendNoVideoMessage(caller, '{"videoStateChange" : "disabled"}');
                                        }
                                        peer.on('message', function (caller, message) {
                                            var message = JSON.parse(message);
                                            if(message.videoStateChange && message.videoStateChange == "disabled") {
                                                _toggleNoVideoMessage(params, false, videoOnBothSides, false);
                                            } else if(message.videoStateChange && message.videoStateChange == "enabled") {
                                                _toggleNoVideoMessage(params, true, videoOnBothSides, false);
                                            }
                                        });
                                    });
                                } else {
                                    stream.getVideoTracks()[0].stop();
                                    stream.getAudioTracks()[0].stop();
                                }
                            });

                            // Sound from client to Agent (also if video is enabled for both sides)
                            peer.on('remote:stream:added', function (caller, stream) {
                                MCServiceAPI.debug.logAsync("Remote stream added").resolve(that.getTracks(stream));
                                if (channel) {
                                    channel.UI.renderRemoteVideoTag(stream, params, session);
                                    _fireEvent(channel.Events.Connected, {
                                        agent: agent,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }
                                if (connectingUpdater) {
                                    connectingUpdater.resolve();
                                }
                                if (connectionUpdater) {
                                    connectionUpdater.resolve();
                                }
                            });
                        }
                        else {
                            //Visitor
                            //Handler for incoming call
                            var visitorConnectionUpdater = MCServiceAPI.debug.logAsync("Requesting webrtc connection..");
                            peer.on('incoming:call', function (caller) {
                                that.currentState = 1;

                                if (_getFirstActiveSession("webrtc_video")) { //QA 170907-000124
                                //if (Object.keys(MCServiceAPI.Sessions).length !== 0) { //QA 170907-000124
                                    connectingUpdater = MCServiceAPI.debug.logAsync("Waiting for the remote stream...");

                                    setTimeout(function () {
                                        if (!callStarted) {
                                            if (channel) {
                                                _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                    show: true,
                                                    context: channel
                                                });
                                            }
                                            hintShown = true;
                                        }
                                    }, 999);

                                    that.ll_caller = caller;
                                    peer.ringer.play();

                                    // Accepting the call    
                                    that.acceptCall(peer, caller);
                                }
                            });

                            peer.on('call:state:change', function (caller, state) {
                                if (state && state.state === "FAILED" && that.currentState === 1) {
                                    that.currentState = 0;
                                    peer.dialer.stop();
                                    MCServiceAPI.debug.error("Videocall failed");
                                    _fireEvent(channel.Events.Disconnected, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                    _fireEvent(channel.Events.Error, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }

                            });
                            peer.on('call:failed', function (caller) {
                                if (that.currentState === 1) {
                                    that.currentState = 0;
                                    peer.dialer.stop();
                                    MCServiceAPI.debug.error("Videocall failed");
                                    _fireEvent(channel.Events.Disconnected, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                    _fireEvent(channel.Events.Error, {
                                        agent: false,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }
                            });

                            if (!videoDirectionClient) { // Agent to Client Video
                                peer.on('remote:stream:added', function (caller, stream) {
                                    that.currentState = 1;
                                    MCServiceAPI.debug.log("Remote stream added", that.getTracks(stream));
                                    // Hiding the "Allow" hint if it was shown
                                    if (hintShown) {
                                        if (channel) {
                                            _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                show: false,
                                                context: channel
                                            });
                                        }
                                    }
                                    callStarted = true;
                                    if (channel) {

                                        //debugger;
                                        try {
                                            channel.UI.video.srcObject = stream;
                                            channel.UI.video.load();
                                            channel.UI.video.play();
                                            channel.UI.video.controls = false;
                                            _fireEvent(channel.Events.Connected, {
                                                agent: agent,
                                                sessionID: channel.communicationHandler.sessionID,
                                                context: channel
                                            });

                                            if (visitorConnectionUpdater) {
                                                visitorConnectionUpdater.resolve("CONNECTED");
                                            }
                                            if (connectingUpdater) {
                                                connectingUpdater.resolve();
                                            }
                                        }
                                        catch (e) {
                                            //connection failed
                                            console.log(Utils.getTimeString() + ": connection error: ", e);
                                            _fireEvent(channel.Events.Error, {
                                                agent: agent,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID,
                                                error: e,
                                                code: "ERR_CONNECTION_FAILED"
                                            });
                                            _fireEvent(channel.Events.Disconnected, {
                                                agent: agent,
                                                context: channel,
                                                sessionID: channel.communicationHandler.sessionID
                                            });

                                            if (visitorConnectionUpdater) {
                                                visitorConnectionUpdater.reject("Call connected but stream render failed");
                                            }
                                            if (connectingUpdater) {
                                                connectingUpdater.reject();
                                            }
                                        }
                                    }
                                });
                            } else if (videoDirectionClient && !agent) { // Client to Agent Video
                                peer.on('remote:stream:added', function(caller, stream) {
                                    var remoteVideoElement = null;
                                    if(!Utils.$("videoTagForSound")) {
                                        var remoteSoundTag = document.createElement("video");
                                        var videoContainer = Utils.$("videoSectionWrapper");

                                        remoteSoundTag.className = "hidden";
                                        remoteSoundTag.id = "videoTagForSound";
                                        videoContainer.appendChild(remoteSoundTag);

                                        remoteVideoElement = remoteSoundTag;
                                        // Accessibility
                                        remoteVideoElement.setAttribute('tabindex', 0);
                                        remoteVideoElement.setAttribute('title', 'Visitor\'s video screen.');
                                        remoteVideoElement.setAttribute('aria-label', 'Visitor\'s video screen.');
                                        // Done to be able to control the small window expand/collapse with keyboard
                                        remoteVideoElement.addEventListener('keyup', function (e) {
                                            if (e.which === 13) {
                                                that.dbclick();
                                            }
                                        })
                                    } else {
                                        remoteVideoElement = Utils.$("videoTagForSound");
                                    }

                                    //remoteVideoElement.volume = 0;
                                    remoteVideoElement.pause();
                                    setTimeout(function () {
                                        remoteVideoElement.srcObject = stream;
                                        remoteVideoElement.load();
                                        remoteVideoElement.play();
                                        remoteVideoElement.controls = false;
                                    }, 450);

                                    //Safari support
                                    if(remoteVideoElement){
                                        remoteVideoElement.setAttribute('webkit-playsinline', 'webkit-playsinline');
                                        remoteVideoElement.setAttribute('playsinline', 'playsinline');
                                        remoteVideoElement.allowsInlineMediaPlayback = true;
                                        remoteVideoElement.autoplay = true;
                                    }

                                });

                                peer.on('local:stream:added', function (caller, stream) {
                                    that.currentState = 1;
                                    MCServiceAPI.debug.log("Remote stream added", that.getTracks(stream));
                                    // Hiding the "Allow" hint if it was shown
                                    if (hintShown) {
                                        if (channel) {
                                            _fireEvent(channel.Events.MediaDevicePermissionRequested, {
                                                show: false,
                                                context: channel
                                            });
                                        }
                                    }
                                    callStarted = true;
                                    if (channel) {

                                        //debugger;
                                        try {
                                            channel.UI.video.srcObject = stream;
                                            channel.UI.video.load();
                                            channel.UI.video.play();
                                            channel.UI.video.muted = true;
                                            channel.UI.video.controls = false;
                                            _fireEvent(channel.Events.Connected, {
                                                agent: agent,
                                                sessionID: channel.communicationHandler.sessionID,
                                                context: channel
                                            });

                                            if (visitorConnectionUpdater) {
                                                visitorConnectionUpdater.resolve("CONNECTED");
                                            }
                                            if (connectingUpdater) {
                                                connectingUpdater.resolve();
                                            }
                                        }
                                        catch (e) {
                                                //connection failed
                                                console.log(Utils.getTimeString() + ": connection error: ", e);
                                                _fireEvent(channel.Events.Error, {
                                                    agent: agent,
                                                    context: channel,
                                                    sessionID: channel.communicationHandler.sessionID,
                                                    error: e,
                                                    code: "ERR_CONNECTION_FAILED"
                                                });
                                                _fireEvent(channel.Events.Disconnected, {
                                                    agent: agent,
                                                    context: channel,
                                                    sessionID: channel.communicationHandler.sessionID
                                                });

                                                if (visitorConnectionUpdater) {
                                                    visitorConnectionUpdater.reject("Call connected but stream render failed");
                                                }
                                                if (connectingUpdater) {
                                                    connectingUpdater.reject();
                                                }
                                        }
                                    }
                            })
                        };

                            peer.on('call:declined', function (caller, state) {
                                that.currentState = 0;
                                peer.dialer.stop();
                                if (channel) {
                                    _fireEvent(channel.Events.Disconnected, {
                                        agent: agent,
                                        context: channel,
                                        sessionID: channel.communicationHandler.sessionID
                                    });
                                }
                                if (visitorConnectionUpdater) {
                                    visitorConnectionUpdater.reject("Received call:declined");
                                }
                                if (connectingUpdater) {
                                    connectingUpdater.reject();
                                }
                            });

                            peer.on('call:ended', function (caller) {
                                that.currentState = 0;
								_elementsWithAddedEventListeners = [];
                                if (channel) {
                                    if (channel.UI.endBtnClicked) {
                                        _fireEvent(channel.Events.Disconnected, {
                                            agent: false,
                                            context: channel,
                                            sessionID: channel.communicationHandler.sessionID
                                        });
                                        channel.UI.endBtnClicked = false;
                                    } else {
                                        _fireEvent(channel.Events.Disconnected, {
                                            agent: true,
                                            context: channel,
                                            sessionID: channel.communicationHandler.sessionID
                                        });
                                    }
                                }
                                if (visitorConnectionUpdater) {
                                    visitorConnectionUpdater.reject("Received call:ended");
                                }
                                if (connectingUpdater) {
                                    connectingUpdater.reject();
                                }
                            
                                // Hiding the "No Video" message if it's visible
                                _toggleNoVideoMessage(params, true, undefined, true);

                                //release media access on endcall
					            try {
						            setTimeout(function() {
							            if(currentStream) {
								            currentStream.getTracks().filter(function(track){
									            track.stop();
								            });
							            }
						            }, 3333);
					            }catch(ex) {}
                            });

                            peer.on('error', function (err) { 
                                that.currentState = 0;
                                if(err.name == "PermissionDeniedError") {
                                    if (channel) {
                                        console.log(Utils.getTimeString() + ": firing SessionStateChange for video for " + (agent ? "Agent" : "Visitor") + ", state: decline");
                                        _fireEvent(channel.Events.SessionStateChange, {
                                            state: "decline",
                                            context: channel,
                                            agent: agent
                                        });
                                        _fireEvent(channel.Events.Error, {
                                            agent: agent,
                                            context: channel,
                                            code: "ERR_PERMISSION_DENIED",
                                            sessionID: channel.communicationHandler.sessionID
                                        });

                                    }
                                }
                            });

                            // MESSAGING FOR NO VIDEO MESSAGE TRANSMISSION
                            peer.on('messaging:open', function (caller) {
                                if(_noVideoCameraAvailable() && videoOnBothSides) {
                                    _sendNoVideoMessage(caller, '{"videoStateChange" : "disabled"}');
                                }
                                peer.on('message', function (caller, message) {
                                    var message = JSON.parse(message);
                                    if(message.videoStateChange && message.videoStateChange == "disabled") {
                                        _toggleNoVideoMessage(params, false, videoOnBothSides, false);
                                    } else if(message.videoStateChange && message.videoStateChange == "enabled") {
                                        _toggleNoVideoMessage(params, true, videoOnBothSides, false);
                                    }
                                });
                            });


                            // Video on both sides
                            if (videoOnBothSides) {
                                peer.on('local:stream:added', function (caller, stream) {
                                    console.log(Utils.getTimeString() + ": local:stream:added");
                                    channel.UI.renderLocalVideoTag(stream, params);
                                });
                            }
                        }
                    });
                }
            },
            init: function (isVisitor) {
                // VIDEO AND AUDIO 
                var that = this,
                    audioInputDevices = [],
                    audioOutputDevices = [],
                    videoInputDevices = [],
                    canEnumerate = false,
                    hasMicrophone = false,
                    hasSpeakers = false,
                    hasWebcam = false,
                    isWebsiteHasMicrophonePermissions = false,
                    isWebsiteHasWebcamPermissions = false;

                if (isVisitor) {
                    that.requiredDevices.videoInput = false;
                }

                //check if webrtc is supported and check devices availability
                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                    // Firefox 38+ seems having support of enumerateDevices
                    // Thanks @xdumaine/enumerateDevices
                    navigator.enumerateDevices = function (callback) {
                        navigator.mediaDevices.enumerateDevices().then(callback).catch(function () {
                            callback([]);
                        });
                    };
                }

                /*global MediaStreamTrack:true */
                if (typeof MediaStreamTrack !== 'undefined' && 'getSources' in MediaStreamTrack) {
                    canEnumerate = true;
                } else if (navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices) {
                    canEnumerate = true;
                }

                // http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediadevices
                function checkDeviceSupport(callback) {
                    if (!canEnumerate) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    if (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources) {
                        navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack);
                    }

                    if (!navigator.enumerateDevices && navigator.enumerateDevices) {
                        navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator);
                    }

                    if (!navigator.enumerateDevices) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    var Browser = Utils.DetectBrowser(),
                        browserName = Browser.BrowserName,
                        browserVersion = parseFloat(Browser.BrowserVersion);
                    if (isNaN(browserVersion)) {
                        browserVersion = 0;
                    }

                    if (!(browserName == "Chrome" && browserVersion >= 70) && !(browserName == "Firefox" && browserVersion >= 60)
                        && !(browserName == "Safari" && browserVersion >= 12) ) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    // Marking EDGE as unsupported
                    if (/Edge/.test(navigator.userAgent)) {
                        var error = "BROWSER_NOT_SUPPORTED";
                        if (that.environmentErrorReason.indexOf(error) === -1)
                            that.environmentErrorReason.push(error);
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    var MediaDevices = [];
                    audioInputDevices = [];
                    audioOutputDevices = [];
                    videoInputDevices = [];

                    navigator.enumerateDevices(function (devices) {
                        devices.forEach(function (_device) {
                            var device = {};
                            for (var d in _device) {
                                device[d] = _device[d];
                            }

                            // if it is MediaStreamTrack.getSources
                            if (device.kind === 'audio') {
                                device.kind = 'audioinput';
                            }

                            if (device.kind === 'video') {
                                device.kind = 'videoinput';
                            }

                            var skip;
                            MediaDevices.forEach(function (d) {
                                if (d.id === device.id && d.kind === device.kind) {
                                    skip = true;
                                }
                            });

                            if (skip) {
                                return;
                            }

                            if (!device.deviceId) {
                                device.deviceId = device.id;
                            }

                            if (!device.id) {
                                device.id = device.deviceId;
                            }

                            if (!device.label) {
                                device.label = 'Please invoke getUserMedia once.';
                                if (location.protocol !== 'https:') {
                                    if (document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                                        device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
                                    }
                                }
                            } else {
                                if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
                                    isWebsiteHasWebcamPermissions = true;
                                }

                                if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
                                    isWebsiteHasMicrophonePermissions = true;
                                }
                            }

                            if (device.kind === 'audioinput') {
                                hasMicrophone = true;

                                if (audioInputDevices.indexOf(device) === -1) {
                                    audioInputDevices.push(device);
                                }
                            }

                            if (device.kind === 'audiooutput') {
                                hasSpeakers = true;

                                if (audioOutputDevices.indexOf(device) === -1) {
                                    audioOutputDevices.push(device);
                                }
                            }

                            if (device.kind === 'videoinput') {
                                hasWebcam = true;

                                if (videoInputDevices.indexOf(device) === -1) {
                                    videoInputDevices.push(device);
                                }
                            }

                            // there is no 'videoouput' in the spec.
                            if (MediaDevices.indexOf(device) === -1) {
                                MediaDevices.push(device);
                            }
                        });

                        that.hasMicrophone = hasMicrophone;
                        that.hasSpeakers = hasSpeakers;
                        that.hasWebcam = hasWebcam;
                        that.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                        that.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;
                        that.audioInputDevices = audioInputDevices;
                        that.audioOutputDevices = audioOutputDevices;
                        that.videoInputDevices = videoInputDevices;
                        that.MediaDevices = MediaDevices;

                        var missingDeviceString = [],
                            requiredDevices = that.requiredDevices;

                        if (requiredDevices.videoInput && !hasWebcam) {
                            missingDeviceString.push("NO_CAMERA");
                        }
                        if (requiredDevices.audioInput && !hasMicrophone) {
                            missingDeviceString.push("NO_MICROPHONE");
                        }

                        if (requiredDevices.audioOutput && !hasSpeakers) {
                            //FF doesn't enumerate audiooutput as of Sep 25, 2016
                            //Safari doesn't do it either as of Aug 26, 2019
                            var bypassUA = ['android'];
                            var bypassBrowsers = ["Firefox", "Safari"];
                            var showWarning = true;
                            for (var i = 0; i < bypassUA.length; i++) {
                                var env = bypassUA[i];
                                if (navigator.userAgent.toLowerCase().indexOf(env) !== -1) {
                                    showWarning = false;
                                    break;
                                }
                            }
                            if (showWarning) {
                                for (var i = 0; i < bypassBrowsers.length; i++) {
                                    if (browserName === bypassBrowsers[i]) {
                                        showWarning = false;
                                        break;
                                    }
                                }
                            }

                            if (showWarning)
                                missingDeviceString.push("NO_SPEAKERS");
                        }

                        var isWebRTCSupported = false;
                        ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
                            if (isWebRTCSupported) {
                                return;
                            }

                            if (item in window) {
                                isWebRTCSupported = true;
                            }
                        });
                        that.isWebRTCSupported = isWebRTCSupported;
                        that.environmentErrorReason = missingDeviceString;
                        that.supported = isWebRTCSupported && missingDeviceString.length === 0;

                        // Marking EDGE as unsupported
                        if (/Edge/.test(navigator.userAgent)) {
                            that.isWebRTCSupported = false;
                        }

                        if (callback) {
                            callback();
                        }
                    });
                }

                that.Events = new Object();
                that.Events["Preload"] = new eventTemplate("Preload");
                that.Events["Unload"] = new eventTemplate("Unload");
                that.Events["Load"] = new eventTemplate("Load");
                that.Events["Render"] = new eventTemplate("Render");
                that.Events["AudioStateChange"] = new eventTemplate("AudioStateChange");
                that.Events["VideoStateChange"] = new eventTemplate("VideoStateChange");
                that.Events["SessionStateChange"] = new eventTemplate("SessionStateChange");
                that.Events["Connected"] = new eventTemplate("Connected");
                that.Events["Connecting"] = new eventTemplate("Connecting");
                that.Events["Disconnecting"] = new eventTemplate("Disconnecting");
                that.Events["Disconnected"] = new eventTemplate("Disconnected");
                that.Events["MediaDevicePermissionRequested"] = new eventTemplate("MediaDevicePermissionRequested");
                that.Events["Error"] = that.Events["Failed"] = new eventTemplate("Failed");

                MCServiceAPI.ready().then(function () {
                    that.Events.Error.listen(function (evt) {
                        var descriptor = {
                            channel: 'webrtc_video',
                            error: evt
                        }
                        _fireEvent(MCServiceAPI.Events.Error, descriptor)
                    });
                    that.Events.Unload.listen(function (evt) {
                        var params = evt.params,
                            container = params.container;
                        if (!container)
                            return;
                        var cntElement = typeof container === "string" ? document.querySelector(container) : container;

                        if (cntElement)
                            cntElement.innerHTML = "";
                    });
                    that.Events.Preload.listen(function (evt) {
                        var params = evt.params,
                            container = params.container,
                            cntElement = typeof container === "string" ? document.querySelector(container) : container,
                            view = that.initial_view,
                            additionalConfig = _getAdditionalConfig();

                        if (additionalConfig && additionalConfig.lang) {
                            var selectedLanguage = additionalConfig.lang,
                                languageFileName = Utils.mapLangToLCID(selectedLanguage),
                                languageFileToLoad = [
                                    MCServiceAPI.configuration.cloudContainer + "/rely/mcservice/resources/lang/" + languageFileName + ".js"
                                ];

                            _loadAllResources(languageFileToLoad).then(function () {
                                if (cntElement) {
                                    view = _setLanguageTextStrings(view);
                                    cntElement.innerHTML = unescape(view);
                                    // Setting the "Connecting" block size
                                    var startingVideoWrapper = Utils.$("startingVideo");
                                    var videoStartWrapper = Utils.$("videoStartWrapper");
                                    Utils.css(startingVideoWrapper, {
                                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                                        borderWidth: "1px",
                                        borderStyle: "solid",
                                        borderColor: "#3a3a3a",
                                        display: "table-cell"
                                    });
                                    Utils.css(videoStartWrapper, {
                                        width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                        height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                                    });
                                    // Adding a class name to the webrtc container
                                    Utils.addClass(cntElement, "ll_webrtc_parent_container");
                                }
                            });
                        } else {
                            if (cntElement) {
                                view = _setLanguageTextStrings(view);
                                cntElement.innerHTML = unescape(view);
                                // Setting the "Connecting" block size
                                var startingVideoWrapper = Utils.$("startingVideo");
                                var videoStartWrapper = Utils.$("videoStartWrapper");
                                Utils.css(startingVideoWrapper, {
                                    width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                    height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px",
                                    borderWidth: "1px",
                                    borderStyle: "solid",
                                    borderColor: "#3a3a3a",
                                    display: "table-cell"
                                });
                                Utils.css(videoStartWrapper, {
                                    width: (params.uiVideoWidth ? params.uiVideoWidth : params.videoWidth) + "px",
                                    height: (params.uiVideoHeight ? params.uiVideoHeight : params.videoHeight) + "px"
                                });
                                // Adding a class name to the webrtc container
                                Utils.addClass(cntElement, "ll_webrtc_parent_container");
                            }
                        }

                    });
                    that.Events.Load.listen(function (evt) {

                        var channelMetadata = evt.session.channels.webrtc_video,
                            channelServer = undefined,
                            token = undefined;
                        if (channelMetadata) {
                            channelServer = channelMetadata.channelServer;
                            token = channelMetadata.token;
                        }
                        if (!channelServer) {
                            MCServiceAPI.debug.error("Required metadata missing for webrtc");
                            throw "WebRTC init error E0012";
                        }
                        if (!token) {
                            MCServiceAPI.debug.error("Required metadata missing for webrtc");
                            throw "WebRTC init error E0013";
                        }

                        if (_isHost) {
                            /* check if we already have webRTC session */
                            var sessionInProgress = undefined;
                            Object.keys(MCServiceAPI.Sessions).forEach(function (session) {
                                if (session !== evt.sessionID && sessionInProgress === undefined) {
                                    var channels = MCServiceAPI.Sessions[session].channels;
                                    if (channels && channels.webrtc_video) {
                                        /* looks to be an active session for this channel */
                                        sessionInProgress = session;
                                    }
                                }
                            });

                            if (sessionInProgress) {
                                var message = "WebRTC session " + sessionInProgress + " is already active";
                                console.error(message);
                                MCServiceAPI.debug.error(message);
                                _fireEvent(that.Events.Disconnected, {
                                    agent: false,
                                    context: that,
                                    code: "ERR_ALREADY_STARTED",
                                    reason: "ERR_ALREADY_STARTED",
                                    sessionID: evt.sessionID
                                });
                                _fireEvent(that.Events.Error, {
                                    agent: false,
                                    context: that,
                                    code: "ERR_ALREADY_STARTED",
                                    sessionID: evt.sessionID
                                });
                                return;
                            }
                        }
                        that.communicationHandler.setConfig(evt);
                        sessionStorage.setItem('CloudAuthJWTKey', evt.params.token);
                        sessionStorage.setItem('CloudAuthTenantKey', evt.params.tenantName || "ServiceCloudQA");
                        sessionStorage.setItem('CloudUserNameKey', evt.params.peerID);
                        that.communicationHandler.init(evt.params, evt.session);
                    });
                });
                MCServiceAPI.Events.Disconnecting.listen(function (evt) {
                    evt.context = that;
                    _fireEvent(that.Events.Disconnecting, evt);
                    if (evt.stopSession) {
                        that.stop(evt);
                    }
                    else {
                        try {
                            if (that.communicationHandler.peer)
                                that.communicationHandler.peer.close();
                        }
                        catch (e) { }
                        if (evt.code && !evt.reason) {
                            evt.reason = evt.code;
                        }
                        if (!evt.code && evt.reason) {
                            evt.code = evt.reason;
                        }
                        _fireEvent(that.Events.Disconnected, evt);
                    }
                });

                MCServiceAPI.Events.Disconnected.listen(function (evt) {
                    that.stop(evt);
                });

                that.Events.Render.listen(function (params) {
                    //init UI
                    that.UI.init(params);
                });

                that.ready = true;

                return new Promise(function (resolve, reject) {
                    checkDeviceSupport(function () {
                        resolve();
                    });
                });
            },
            hasMicrophone: false,
            hasSpeakers: false,
            hasWebcam: false,
            hasVideo: false,
            isWebsiteHasWebcamPermissions: false,
            isWebsiteHasMicrophonePermissions: false,
            MediaDevices: [],
            audioInputDevices: [],
            audioOutputDevices: [],
            videoInputDevices: [],
            isWebRTCSupported: false,
            environmentErrorReason: [],
            resources: [
                MCServiceAPI.configuration.cloudContainer + "/rely/video/vlauncher_baremetal.js",
                MCServiceAPI.configuration.cloudContainer + "/rely/mcservice/resources/css/mcsstyle.css"
                // "https://webvipdv101.livelook.net/webinterfaces/mcservice/vlauncher_baremetal1.js",
                // "https://webvipdv101.livelook.net/ilia/mcservice/resources/css/mcsstyle.css"
            ],
            Events: {}
        };

        var globalEnvironmentReason = [],
            initComplete = false,
            readyChecked = false;

        MCServiceAPI.init = function (isVisitor) {
            var initAsyncUpdater = MCServiceAPI.debug.logAsync("Checking environment");
            var supportedChannels = [],
                asyncWaitList = [];
            if (!("Promise" in window))
                globalEnvironmentReason.push("UNSUPPORTED_BROWSER");
            if (window.location.protocol === "http:") {
                var disallowHttp = true;
                if (document && document.currentScript) {
                    var attrValue = document.currentScript.getAttribute("data-isWebRtcHttp");
                    if (attrValue && attrValue.toLowerCase() === "on")
                        disallowHttp = false;
                }
                if (disallowHttp)
                    globalEnvironmentReason.push("INSECURE_ORIGIN");
            }
            if (globalEnvironmentReason.length !== 0) {
                MCServiceAPI.Channels.webrtc_video.environmentErrorReason = MCServiceAPI.Channels.webrtc_video.environmentErrorReason.concat(globalEnvironmentReason);
                initAsyncUpdater.reject("ENV_ERROR: " + MCServiceAPI.Channels.webrtc_video.environmentErrorReason.join(", "));
                return;
            }

            initAsyncUpdater.resolve("OK");
            initAsyncUpdater = MCServiceAPI.debug.logAsync("Initializing channels...");

            for (var channelName in MCServiceAPI.Channels) {
                if (!MCServiceAPI.Channels.hasOwnProperty(channelName))
                    continue;

                var channel = MCServiceAPI.Channels[channelName];
                if (channel.abstract)
                    continue;

                var channelUpdater = MCServiceAPI.debug.logAsync("Initializing " + channelName);

                var promise = channel.init(isVisitor);
                asyncWaitList.push(promise);

                (function (cn, cname, promise, channelUpdater) {
                    promise.then(function () {
                        if (cn.supported) {
                            channelUpdater.resolve();
                            supportedChannels.push(cname);
                        }
                        else {
                            channelUpdater.reject("not supported");
                        }
                    });
                })(channel, channelName, promise, channelUpdater);
            }

            if (typeof (MCServiceAPI.StorageManager) === "object")
                asyncWaitList.push(MCServiceAPI.StorageManager.ready());

            Promise.all(asyncWaitList).then(function () {
                Object.defineProperty(MCServiceAPI, "supportedChannels", {
                    get: function () {
                        return supportedChannels.concat();
                    }
                });

                if (supportedChannels.length === 0) {
                    initAsyncUpdater.reject("NO_SUPPORTED_CHANNELS");
                }
                else {
                    initAsyncUpdater.resolve(MCServiceAPI.supportedChannels.join(", "));
                    MCServiceAPI.debug.info("Fired MCServiceAPI.Ready");
                    _fireEvent(MCServiceAPI.Events.Ready, { type: "Ready" });
                    initComplete = true;
                }
            });

            if (isVisitor) {
                MCServiceAPI.ready().then(function () {
                    MCServiceAPI.StorageManager.getItemAsync("mcservice.host", "sessionID").then(function (value) {
                        if (value) {
                            try {
                                var json = JSON.parse(value),
                                    expired = (typeof json.lastActiveTime !== "number") || (new Date().getTime() - json.lastActiveTime > 200000),
                                    resumeMessage = MCServiceAPI.debug.logAsync("Found session: " + json.sessionID);

                                if (expired || true) {
                                    resumeMessage.reject("Expired");
                                    MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                                }
                                else {
                                    MCServiceAPI.Site.resume({ session: json.sessionID, apiKey: json.siteCode, accessToken: json.accessToken }, json.channels)
                                        .then(function () {
                                            resumeMessage.resolve();
                                        })
                                        .catch(function (err) {
                                            resumeMessage.reject(err.status);
                                            MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                                        });
                                }
                            }
                            catch (e) {
                                MCServiceAPI.StorageManager.removeItemAsync("mcservice.host", "sessionID");
                            }
                        }
                    })
                });
            }
        }

        MCServiceAPI.ready = function () {
            var readyWait = readyChecked ? null : MCServiceAPI.debug.logAsync("Waiting for the READY state...");
            readyChecked = true;
            return new Promise(function (resolve, reject) {
                if (initComplete) {
                    resolve();
                }
                else {
                    /*TMP_DEBUG: ugly fix for Field Service*/
                    MCServiceAPI.Channels.webrtc_video_both = MCServiceAPI.Channels.webrtc_video;
                    if (globalEnvironmentReason.length !== 0) {
                        //READY will never fire here
                        if (readyWait)
                            readyWait.reject("ENV_ERROR");
                        reject({ reason: "ENV_ERROR", code: globalEnvironmentReason.join(", ") });
                    }
                    else {
                        MCServiceAPI.Events.Ready.wait(function () {
                            if (readyWait)
                                readyWait.resolve("READY");

                            resolve();
                        });
                    }

                }
            });
        }


        var _waitForActiveSession = function (err, maxTime) {
            var currentTime = new Date().getTime();
            if (currentTime > maxTime)
                return false;

            var code = err ? (err.status || err.code) : null;
            return code == "404";
        }

        MCServiceAPI.Agent.connect = MCServiceAPI.Agent.start = function (authData, channels, config) {
            if(config) {
                _setAdditionalConfig(config);
            }

            var maxTimeout = 3 * 60 * 1000,
                connectionAttemptStarted = new Date().getTime();

            if (typeof authData.session === "string") {
                authData.session = authData.session.toLowerCase();
            }

            return new Promise(function (resolve, reject) {
                MCServiceAPI.ready().then(function () {
                    //check if requested channels are supported
                    var validateLog = MCServiceAPI.debug.logAsync("Validating requested channels"),
                        invalidChannels = [];

                    if (channels["webrtc_video_both"] !== undefined && channels["webtrc_video"] === undefined) {
                        console.error("Channel webrtc_video_both is deprecated, and its support will be discontinued. Please refer to the documentation on how to make bi-directional video calls in a supported way.");
                        channels.webrtc_video = channels.webrtc_video_both;
                        delete channels.webrtc_video_both;
                    }

                    Object.keys(channels).forEach(function (channel) {
                        if (!MCServiceAPI.Channels[channel].supported) {
                            invalidChannels.push(channel);
                        }
                    });
                    if (invalidChannels.length !== 0) {
                        validateLog.reject("ENV_ERROR: " + invalidChannels.join(", "));
                        reject({ code: "ENV_ERROR", reason: JSON.stringify(invalidChannels) });
                        return;
                    }

                    _fireEvent(MCServiceAPI.Events.Connecting, {});
                    validateLog.resolve("OK");

                    // Showing an initial view until the components are initialized
                    Object.keys(channels).forEach(function (channel) {
                        var mcChannel = MCServiceAPI.Channels[channel];
                        if (mcChannel && mcChannel.Events["Preload"]) {
                            console.log(Utils.getTimeString() + ": firing onpreload for: " + channel + " as agent");
                            _fireEvent(mcChannel.Events.Preload, {
                                context: mcChannel,
                                sessionID: authData.session,
                                apiKey: authData.apiKey,
                                params: channels[channel],
                                agent: true
                            });
                        }
                    });

                    var authAsyncLog = MCServiceAPI.debug.logAsync("Authenticating agent connection"),
                        channelsToStart = JSON.stringify(Object.keys(channels).reduce(
                            function (object, key) {
                                object[key] = true;
                                return object
                            }, {}));

                    _retry(function () {
                        var requestURL = MCServiceAPI.configuration.auth.start + "/agent";
                        if (authData.session !== undefined)
                            requestURL += "/" + authData.session;

                        return _request("POST", requestURL,
                            channelsToStart,
                            {
                                "x-jwt-token": authData.authToken,
                                "x-api-key": authData.apiKey
                            })

                    }, _waitForActiveSession, connectionAttemptStarted + maxTimeout, 5000)
                        .then(function (data) {
                            authAsyncLog.resolve("200 OK");
                            var failedChannels = 0,
                                totalChannels = Object.keys(channels).length,
                                ignoredChannels = [],
                                responseParserMessage = MCServiceAPI.debug.logAsync("Parsing response");

                            //new flow: multiple sessions
                            var session = JSON.parse(data);
                            if (authData.session !== undefined) {
                                MCServiceAPI.Sessions[authData.session] = session;
                                MCServiceAPI.Sessions[authData.session].siteCode = authData.apiKey;
                            }

                            Object.keys(channels).forEach(function (key) {
                                var channelMessage = MCServiceAPI.debug.logAsync("Parsing metadata for " + key);
                                var parseError = false,
                                    userChannel = channels[key],
                                    serverChannel = session.channels[key];
                                if (serverChannel && userChannel) {
                                    userChannel.agent = true;
                                    Object.keys(serverChannel).forEach(function (serverKey) {
                                        userChannel[serverKey] = serverChannel[serverKey];
                                    });

                                    // Parsing the token to get the peerID
                                    if (!serverChannel.token) {
                                        failedChannels++;
                                        parseError = true;
                                        channelMessage.reject("501 Unavailable");
                                        MCServiceAPI.debug.error("Channel " + key + " not implemented");
                                        delete session.channels[key];
                                        delete channels[key];

                                        if (MCServiceAPI.Channels[key].Events.Error) {
                                            _fireEvent(MCServiceAPI.Channels[key].Events.Error,
                                                {
                                                    code: "ERR_MISSING_METADATA",
                                                    context: MCServiceAPI.Channels[key],
                                                    sessionID: authData.session,
                                                    responseText: "Server failed to supply required data. Channel will not start."
                                                });
                                        }

                                        reject({ code: "501", channel: key, reason: "ERR_NOT_IMPLEMENTED" });
                                        return;
                                    }
                                    var peerID = serverChannel.peerID,
                                        visitorPeerID = serverChannel.visitorPeerID,
                                        iss = "example.com"; //serverChannel.iss;
                                    if (peerID) {
                                        // Setting the channel server for WebRTC
                                        channels.webrtc_video.peerID = MCServiceAPI.Sessions[authData.session].channels.webrtc_video.peerID = peerID + "@" + iss;
                                        channels.webrtc_video.visitorPeerID = MCServiceAPI.Sessions[authData.session].channels.webrtc_video.visitorPeerID = visitorPeerID + "@" + iss;
                                    }

                                    if (serverChannel.videoDirection)
                                        MCServiceAPI.Sessions[authData.session].channels.webrtc_video.videoDirection = serverChannel.videoDirection;

                                    userChannel.siteCode = authData.apiKey;
                                    channelMessage.resolve();
                                }
                                else {
                                    ignoredChannels.push(key);
                                    channelMessage.resolve("deactivated", "warning");
                                }
                            });

                            // Appending the needed resources
                            if (failedChannels < totalChannels) {
                                if (failedChannels === 0)
                                    responseParserMessage.resolve();
                                else {
                                    responseParserMessage.resolve("Unsupported channels: " + failedChannels, "warning");
                                }

                                if (ignoredChannels.length > 0)
                                    MCServiceAPI.debug.log("Not supported by visitor: " + ignoredChannels.join(", ") + ", deactivated");

                                _renderJSAndStyles(channels, authData.session);
                                resolve();

                            }
                            else {
                                responseParserMessage.reject();
                            }
                        }).catch(function (result) {
                            if (typeof ((result.stack) !== "undefined") && (typeof (result.message) !== "undefined"))
                                MCServiceAPI.debug.error(result);

                            var errorObject = { code: result && result.status ? result.status : "403", reason: result && result.statusText ? result.statusText : "Authentication error" };
                            authAsyncLog.reject(errorObject.code + " (" + errorObject.reason + ")");
                            Object.keys(channels).forEach(function (channel) {
                                var mcChannel = MCServiceAPI.Channels[channel];
                                if (mcChannel && mcChannel.Events["Unload"]) {
                                    console.log(Utils.getTimeString() + ": firing onunload for: " + channel + " as agent");
                                    _fireEvent(mcChannel.Events.Unload, {
                                        context: mcChannel,
                                        sessionID: authData.session,
                                        apiKey: authData.apiKey,
                                        params: channels[channel],
                                        agent: true
                                    });
                                }
                            });

                            reject(errorObject);
                        });
                });
            });
        };

        MCServiceAPI.Agent.endSession = function (descriptor) {
            return new Promise (function (resolve, reject) {
                var id = undefined,
                    reason = undefined;
                if (descriptor && typeof descriptor === "object") {
                    id = typeof (descriptor.sessionID) === "string" ? descriptor.sessionID.toLowerCase() : descriptor.sessionID;
                    reason = descriptor.reason;
                }

                if (id === undefined)
                    id = Object.keys(MCServiceAPI.Sessions)[0];

                if (id === undefined) {
                    MCServiceAPI.debug.error("No active session found");
                    reject("No active session found");
                }
                else if (!MCServiceAPI.Sessions[id]) {
                    MCServiceAPI.debug.error("Session not found: " + id);
                    reject("Session not found: " + id);
                }

                var allChannels = true,
                    channels = [];
                if (descriptor && typeof descriptor === "object" && "channels" in descriptor && descriptor.channels.length) {
                    descriptor.channels.forEach(function (channel) {
                        if (channel === "*") {
                            Object.keys(MCServiceAPI.Sessions[id]).forEach(function (sessionChannel) {
                                if (channels.indexOf(sessionChannel) === -1)
                                    channels.push(sessionChannel);
                            });
                        }
                        else if (channels.indexOf(channel) === -1)
                            channels.push(channel);
                    });
                    if (channels.length !== Object.keys(MCServiceAPI.Sessions[id].channels).length)
                        allChannels = false;
                }

                if (allChannels) {
                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnecting for " + id);
                    _fireEvent(MCServiceAPI.Events.Disconnecting, {
                        sessionID: id,
                        reason: reason,
                        agent: true,
                        stopSession: true
                    });

                    _terminateSession(id, false);
                }
                else {
                    channels.forEach(function (channel) {
                        //TODO: inform MCServiceAPI backend
                        if (MCServiceAPI.Channels[channel] && typeof MCServiceAPI.Channels[channel].stop === "function") {
                            MCServiceAPI.Channels[channel].stop({ sessionID: id, reason: descriptor.reason });
                        }
                        else {
                            MCServiceAPI.debug.error("Can't terminate channel " + channel);
                        }
                    })
                    _removeChannels(id, channels, false);
                }

                resolve();
            });
        }

        MCServiceAPI.Agent.disconnect = function (descriptor) {
            return new Promise (function (resolve, reject) {
                var id = undefined,
                    reason = undefined;
                if (descriptor && typeof descriptor === "object") {
                    id = typeof (descriptor.sessionID) === "string" ? descriptor.sessionID.toLowerCase() : descriptor.sessionID;
                    reason = descriptor.reason;
                }

                if (id === undefined)
                    id = Object.keys(MCServiceAPI.Sessions)[0];

                if (id === undefined) {
                    MCServiceAPI.debug.error("No active session found");
                    reject("No active session found");
                }
                else if (!MCServiceAPI.Sessions[id]) {
                    MCServiceAPI.debug.error("Session not found: " + id);
                    reject("Session not found: " + id);
                }

                var allChannels = true,
                    channels = [];
                if (descriptor && typeof descriptor === "object" && "channels" in descriptor && descriptor.channels.length) {
                    descriptor.channels.forEach(function (channel) {
                        if (channel === "*") {
                            Object.keys(MCServiceAPI.Sessions[id]).forEach(function (sessionChannel) {
                                if (channels.indexOf(sessionChannel) === -1)
                                    channels.push(sessionChannel);
                            });
                        }
                        else if (channels.indexOf(channel) === -1)
                            channels.push(channel);
                    });
                    if (channels.length !== Object.keys(MCServiceAPI.Sessions[id].channels).length)
                        allChannels = false;
                }
                if (allChannels) {
                    MCServiceAPI.debug.info("Fired MCServiceAPI.Disconnecting for " + id);
                    _fireEvent(MCServiceAPI.Events.Disconnecting, {
                        sessionID: id,
                        agent: true,
                        reason: reason,
                        stopSession: false
                    });
                    setTimeout(function (id) {
                        delete MCServiceAPI.Sessions[id];
                    }, 1000, id);
                }
                else {
                    channels.forEach(function (channel) {
                        if (MCServiceAPI.Channels[channel] && typeof MCServiceAPI.Channels[channel].stop === "function") {
                            MCServiceAPI.Channels[channel].stop({ sessionID: id, reason: descriptor.reason, soft: true });
                        }
                        else {
                            MCServiceAPI.debug.error("Can't terminate channel " + channel);
                        }
                    })
                }
                resolve();
            });
        }


        var _logAsyncOperation = function (message, type) {
            var element = null,
                finished = false,
                that = MCServiceAPI.debug,
                div = that.container,
                msg = document.createElement("span"),
                span = document.createElement("span"),
                p = document.createElement("p"),
                progressTimer = 0;

            if (that.enabled) {
                if (typeof div !== "object") {
                    that.initContainer();
                    div = that.container;
                }

                msg.innerHTML = msg.innerText = Utils.getTimeString() + ": " + message;
                span.id = "log" + Math.random() * 1000;
                Utils.css(span, {
                    "font-weight": "bold",
                    position: "relative",
                    float: "right",
                    left: "-30px",
                    "text-align": "right",
                    "max-width": "250px",
                    "word-wrap": "break-word"
                });
                Utils.css(p, {
                    "vertical-align": "top",
                    "margin-top": "3px",
                    "margin-bottom": 0,
                    "margin-left": "10px",
                    "clear": "both",
                    color: "inherit"
                });

                if (type === "warning")
                    p.style.color = "orange";
                else if (type === "info") {
                    p.style.color = "white";
                }
                else if (type === "error")
                    p.style.color = "red";

                p.appendChild(msg);
                p.appendChild(span);
                span.style.setProperty("float", "right"); //mac firefox bug

                div.appendChild(p);
                div.scrollTop = div.scrollHeight;

                span.start = performance.now();
                element = span;

                progressTimer = setTimeout(function () {
                    span.innerHTML = "<span style='color:lightslategray;font-style:italic'>Pending...</span>"
                }, 1000);
            }

            return {
                resolve: function (message, type) {
                    if (progressTimer !== 0) {
                        clearTimeout(progressTimer);
                        progressTimer = 0;
                    }

                    if (!MCServiceAPI.debug.enabled || finished || !element)
                        return;
                    var startTime = element.start,
                        elapsedTime = startTime ? performance.now() - startTime : 0;

                    var timeMessage = "",
                        timeColor = "";
                    if (elapsedTime > 50) {
                        timeMessage += "(" + elapsedTime.toFixed(3) + " ms) ";
                        if (elapsedTime > 10000) {
                            timeColor = "Red";
                        }
                        else if (elapsedTime > 5000)
                            timeColor = "Orange";
                        else if (elapsedTime > 1000)
                            timeColor = "Yellow";

                        if (timeColor)
                            timeMessage = "<span style='color:" + timeColor + ";'>" + timeMessage + "</span>";
                    }

                    if (type === "warning") {
                        timeColor = "Orange";
                        element.innerHTML = timeMessage + "<span style='color:orange;'>" + (message !== undefined ? message : "SUCCESS") + "</span>";
                    } else {
                        element.innerHTML = timeMessage + (message !== undefined ? message : "SUCCESS");
                    }
                    finished = true;
                },
                reject: function (message) {
                    if (progressTimer !== 0) {
                        clearTimeout(progressTimer);
                        progressTimer = 0;
                    }

                    if (!MCServiceAPI.debug.enabled || finished || !element)
                        return;
                    Utils.css(element, {
                        color: "Red",
                        "font-weight": "Normal"
                    });
                    element.innerHTML = message ? message : "FAILED";
                    finished = true;
                }
            }
        }

        MCServiceAPI.debug = {
            enabled: false,
            container: "#log",
            messages: {},
            initContainer: function () {
                var container = this.container;
                if (typeof (container) === "string") {
                    container = document.querySelector(this.container);
                    if (!container) {
                        container = document.createElement("DIV");
                        if (document.body)
                            document.body.appendChild(container)
                        else {
                            var _bodyCheckTimer = function () {
                                if (document.body)
                                    document.body.appendChild(container);
                                else
                                    setTimeout(_bodyCheckTimer, 1000);
                            }
                            setTimeout(_bodyCheckTimer, 1000);
                        }
                    }
                    this.container = container;
                }

                container.innerHTML = "TRACE LOG<br />----------<br />";
                Utils.css(container, {
                    "min-height": "100px",
                    "max-height": "480px",
                    "overflow-y": "auto",
                    width: "40%",
                    padding: "10px",
                    border: "1px solid #000",
                    color: "green",
                    position: "absolute",
                    "background-color": "black",
                    font: "normal 12px 'Lucida Console', Monaco"
                });
            },
            logAsync: function (message) {
                return new _logAsyncOperation(message);
            },
            info: function (message, result) {
                new _logAsyncOperation(message, "info").resolve(result === undefined ? "" : result);
            },
            log: function (message, result) {
                new _logAsyncOperation(message, "log").resolve(result === undefined ? "" : result);
            },
            warn: function (message) {
                new _logAsyncOperation(message, "warning").resolve("");
            },
            error: function (message) {
                new _logAsyncOperation(message, "error").resolve("");
            }
        };

        if (document && typeof document.currentScript !== "undefined") {
            var src = document.currentScript.src || "",
                search = src.indexOf("?") === -1 ? "" : src.substr(src.indexOf("?") + 1),
                params = search.split('&'),
                urlObject = params.reduce(function (acc, val) {
                    var parts = val.split("=");
                    acc[parts[0]] = parts[1];
                    return acc;
                }, {});
            if (urlObject.debug === "yes" || urlObject.debug === "true")
                MCServiceAPI.debug.enabled = true;
    
        }
})();



    var Utils = function () {
        "use sctrict";

        return {
            $: function (id) {
                return document.getElementById(id);
            },
            listen: function (evnt, elem, func) {
                if (typeof elem === "string") {
                    var els = elem.split(',');
                    els.forEach(function (eld) {
                        var el = document.getElementById(eld.trim());
                        if (el)
                            Utils.listen(evnt, el, func);
                    });
                    return;
                }
                else {
                    try { //QA 170907-000124
                        if (elem.addEventListener)  // W3C DOMdis
                            elem.addEventListener(evnt, func, false);
                        else if (elem.attachEvent) { // IE DOM
                            elem.attachEvent("on" + evnt, func);
                        }
                        else { // Not much to do
                            elem[evnt] = func;
                        }
                    }
                    catch (ex) { }
                }
            },
            hasClass: function (el, className) {
                if (!el) {
                    return;
                }
                if (el.classList)
                    return el.classList.contains(className)
                else
                    return !!el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'))
            },
            addClass: function (el, className) {
                if (!el) {
                    return;
                }
                if (el.constructor === Array) {
                    el.forEach(function (element) {
                        Utils.addClass(element, className);
                    });
                }
                else {
                    if (typeof (el) === "string") {
                        el = Utils.$(el);
                        if (!el)
                            return;
                    }
                    var classArray = className.constructor === Array ? className : className.split(" ");
                    if (el.classList && !("ActiveXObject" in window)) {
                        el.classList.add.apply(el.classList, classArray)
                    }

                    else
                        classArray.forEach(function (className) {
                            if (className && !Utils.hasClass(el, className))
                                el.className += " " + className;
                        });
                }
            },

            /**
            * Removes the specified class from the element
            * <params>
            *      el: DOM element, the element to remove the class from
            *      className: string, the class to remove from the given element
            * </params>
            */
            removeClass: function (el, className) {
                if (!el) {
                    return;
                }
                if (el.constructor === Array) {
                    el.forEach(function (element) {
                        Utils.removeClass(element, className);
                    });
                }
                else {
                    if (typeof (el) === "string") {
                        el = Utils.$(el);
                        if (!el)
                            return;
                    }
                    var classArray = className.constructor === Array ? className : className.split(" ");

                    if (el.classList && !("ActiveXObject" in window))
                        el.classList.remove.apply(el.classList, classArray)
                    else {
                        classArray.forEach(function (className) {
                            if (className && hasClass(el, className)) {
                                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                                el.className = el.className.replace(reg, ' ');
                            }
                        });
                    }
                }
            },

            /**
            * Applies CSS properties to the given element
            * <params>
            *      elem: DOM element, the element to apply the styles to
            *      properties: object, properties in key : value form
            * </params>
            */
            css: function (elem, properties) {
                if (elem) {
                    Object.keys(properties).forEach(function (key) {
                        var cssKey = key;
                        while (cssKey.indexOf('-') !== -1) {
                            var z = cssKey.indexOf('-');
                            cssKey = cssKey.substr(0, z) + cssKey[z + 1].toUpperCase() + cssKey.substr(z + 2);
                        }
                        elem.style[cssKey] = properties[key];
                    });
                }
            },

            getTimeString: function () {
                var today = new Date(),
                    hours = today.getHours();
                if (hours < 10)
                    hours = "0" + hours;
                var mins = today.getMinutes();
                if (mins < 10)
                    mins = "0" + mins;
                var secs = today.getSeconds();
                if (secs < 10)
                    secs = "0" + secs;
                var ms = today.getMilliseconds().toString();
                while (ms.length < 3)
                    ms = "0" + ms;

                return "" + hours + ":" + mins + ":" + secs + "." + ms;
            },

            DetectBrowser: function () {
                var ua = navigator.userAgent.toLowerCase();
                var Browser = {};
                Browser.OS = "";
                Browser.OSVersion = "";
                Browser.BrowserName = "";
                Browser.BrowserVersion = "";
                Browser.NetVersion = "";
                Browser.WebSocket = false;
                Browser.PostMessage = false;
                Browser.LocalStorage = false;

                //OS detection
                if (/windows/i.test(ua)) {
                    Browser.OS = "Windows";
                } else if (/mac os x/i.test(ua)) {
                    Browser.OS = "Mac OS X";
                } else if (/mac/i.test(ua)) {
                    Browser.OS = "Mac OS";
                } else if (/linux/i.test(ua)) {
                    Browser.OS = "Linux";
                }
                //System version
                if (Browser.OS == "Windows") {
                    if (/windows nt.+\sarm\;/i.test(ua)) {
                        Browser.OSVersion = "RT";
                    }
                    else if (/windows nt[\/\s](\d+\.\d+)/i.test(ua)) {
                        if (RegExp.$1 == "6.0") {
                            Browser.OSVersion = "Vista";
                        }
                        else if (RegExp.$1 == "6.1") {
                            Browser.OSVersion = "7";
                        }
                        else if (RegExp.$1 == "6.2") {
                            Browser.OSVersion = "8";
                        }
                        else if (RegExp.$1 == "6.3") {
                            Browser.OSVersion = "8.1";
                        }
                        else if (RegExp.$1 == "6.4" || RegExp.$1 == "10.0") {
                            Browser.OSVersion = "10";
                        }
                    }
                }
                else if (Browser.OS == "Mac OS X") {
                    if (/mac os x[\/\s](\d+_\d+_\d+)/i.test(ua) || /mac os x[\/\s](\d+_\d+)/i.test(ua))
                        Browser.OSVersion = ("" + RegExp.$1).replace(/_/g, ".");
                    else if (/mac os x[\/\s](\d+\.\d+\.\d+)/i.test(ua) || /mac os x[\/\s](\d+\.\d+)/i.test(ua))
                        Browser.OSVersion = RegExp.$1;
                    else if (/cpu os[\/\s](\d+_\d+)/i.test(ua)) {
                        Browser.OS = "IOS";
                        Browser.OSVersion = ("" + RegExp.$1).replace(/_/g, ".");
                    }
                    else if (/cpu iphone os[\/\s](\d+_\d+)/i.test(ua)) {
                        Browser.OS = "IOS";
                        Browser.OSVersion = ("" + RegExp.$1).replace(/_/g, ".");
                    }
                    var arr = Browser.OSVersion.split('.');
                    if (arr.length > 1)
                        Browser.OSVersion = arr[0] + "." + arr[1];
                }
                //Browser detection
                if (/firefox[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Firefox";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/msie[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "MSIE";
                    var actualIEVersion = 11.0;
                    Browser.BrowserVersion = actualIEVersion.toFixed(1);
                } else if (/trident\/7.0/i.test(ua)) {
                    Browser.BrowserName = "MSIE";
                    Browser.BrowserVersion = "11.0";
                } else if (/edge\/(\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "MS Edge";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/opera/i.test(ua) && /version[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Opera";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/chrome/i.test(ua) && /opr[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Opera";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/chrome[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Chrome";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/crios[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Chrome";
                    Browser.BrowserVersion = "" + RegExp.$1;
                } else if (/safari[\/\s](\d+\.\d+)/i.test(ua)) {
                    Browser.BrowserName = "Safari";
                    Browser.BrowserVersion = "" + RegExp.$1;
                    if (/version[\/\s](\d+\.\d+)/i.test(ua)) {
                        Browser.BrowserVersion = "" + RegExp.$1;
                    }
                } else {
                    if (Browser.OS == "Mac OS" || Browser.OS == "Mac OS X" || Browser.OS == "IOS") {
                        //assume safari
                        if (/version[\/\s](\d+\.\d+)/i.test(ua)) {
                            Browser.BrowserName = "Safari";
                            Browser.BrowserVersion = "" + RegExp.$1;
                        }
                    }
                }
                //.NET detection
                if (Browser.OS == "Windows" && Browser.OSVersion != "RT") {
                    var match = ua.match(/\.net(\d+\.\d+)|\.net\sclr\s(\d+\.\d+)/g);
                    if (match) {
                        for (var i = 0; i < match.length; i++) {
                            match[i] = match[i].replace(/\.net\sclr\s/, "").replace(/\.net/, "");
                        }
                        match.sort();
                        Browser.NetVersion = match[match.length - 1];
                    }
                }
                //WebSocket, PostMessage, LocalStorage
                Browser.WebSocket = ("WebSocket" in window);
                Browser.PostMessage = ("postMessage" in window);
                Browser.LocalStorage = ("localStorage" in window);

                return Browser;
            },

            mapLangToLCID: function (lang) {
                var mapping = MCServiceAPI.configuration.languageMapping;
                if (lang && lang.toString().length < 256) {
                    lang = lang.toString().toLowerCase().trim();
                    for (var key in mapping) {
                        if (!mapping.hasOwnProperty(key))
                            continue;
                        else if (key === lang) 
                            return key;
                        for (var i = 0; i< mapping[key].length; i++) {
                            var id = mapping[key][i].toString();
                            if (id === lang)
                                return key;
                        }
                    }
                    if (lang.indexOf("-") !== -1) {
                        var truncatedLang = lang.substr(0, lang.lastIndexOf("-"));
                        return Utils.mapLangToLCID(truncatedLang); //RFC 4647 section 3.4
                    }
                }
                return MCServiceAPI.configuration.defaultLanguage;
            }
        }
    }();

    MCServiceAPI.init(false);

